<div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a

        href="http://xregexp.com/"

    >xregexp (v3.1.1)</a>
</h1>
<h4>Extended regular expressions</h4>
<div class="apidocSectionDiv"><a
    href="#apidoc.tableOfContents"
    id="apidoc.tableOfContents"
><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.xregexp">module xregexp</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.xregexp._dec">
            function <span class="apidocSignatureSpan">xregexp.</span>_dec
            <span class="apidocSignatureSpan">(hex)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.xregexp._hasNativeFlag">
            function <span class="apidocSignatureSpan">xregexp.</span>_hasNativeFlag
            <span class="apidocSignatureSpan">(flag)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.xregexp._hex">
            function <span class="apidocSignatureSpan">xregexp.</span>_hex
            <span class="apidocSignatureSpan">(dec)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.xregexp._pad4">
            function <span class="apidocSignatureSpan">xregexp.</span>_pad4
            <span class="apidocSignatureSpan">(str)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.xregexp.addToken">
            function <span class="apidocSignatureSpan">xregexp.</span>addToken
            <span class="apidocSignatureSpan">(regex, handler, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.xregexp.addUnicodeData">
            function <span class="apidocSignatureSpan">xregexp.</span>addUnicodeData
            <span class="apidocSignatureSpan">(data)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.xregexp.build">
            function <span class="apidocSignatureSpan">xregexp.</span>build
            <span class="apidocSignatureSpan">(pattern, subs, flags)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.xregexp.cache">
            function <span class="apidocSignatureSpan">xregexp.</span>cache
            <span class="apidocSignatureSpan">(pattern, flags)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.xregexp.escape">
            function <span class="apidocSignatureSpan">xregexp.</span>escape
            <span class="apidocSignatureSpan">(str)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.xregexp.exec">
            function <span class="apidocSignatureSpan">xregexp.</span>exec
            <span class="apidocSignatureSpan">(str, regex, pos, sticky)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.xregexp.forEach">
            function <span class="apidocSignatureSpan">xregexp.</span>forEach
            <span class="apidocSignatureSpan">(str, regex, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.xregexp.globalize">
            function <span class="apidocSignatureSpan">xregexp.</span>globalize
            <span class="apidocSignatureSpan">(regex)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.xregexp.install">
            function <span class="apidocSignatureSpan">xregexp.</span>install
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.xregexp.isInstalled">
            function <span class="apidocSignatureSpan">xregexp.</span>isInstalled
            <span class="apidocSignatureSpan">(feature)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.xregexp.isRegExp">
            function <span class="apidocSignatureSpan">xregexp.</span>isRegExp
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.xregexp.match">
            function <span class="apidocSignatureSpan">xregexp.</span>match
            <span class="apidocSignatureSpan">(str, regex, scope)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.xregexp.matchChain">
            function <span class="apidocSignatureSpan">xregexp.</span>matchChain
            <span class="apidocSignatureSpan">(str, chain)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.xregexp.matchRecursive">
            function <span class="apidocSignatureSpan">xregexp.</span>matchRecursive
            <span class="apidocSignatureSpan">(str, left, right, flags, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.xregexp.replace">
            function <span class="apidocSignatureSpan">xregexp.</span>replace
            <span class="apidocSignatureSpan">(str, search, replacement, scope)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.xregexp.replaceEach">
            function <span class="apidocSignatureSpan">xregexp.</span>replaceEach
            <span class="apidocSignatureSpan">(str, replacements)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.xregexp.split">
            function <span class="apidocSignatureSpan">xregexp.</span>split
            <span class="apidocSignatureSpan">(str, separator, limit)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.xregexp.test">
            function <span class="apidocSignatureSpan">xregexp.</span>test
            <span class="apidocSignatureSpan">(str, regex, pos, sticky)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.xregexp.uninstall">
            function <span class="apidocSignatureSpan">xregexp.</span>uninstall
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.xregexp.union">
            function <span class="apidocSignatureSpan">xregexp.</span>union
            <span class="apidocSignatureSpan">(patterns, flags)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">xregexp.</span>version</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.xregexp.cache">module xregexp.cache</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.xregexp.cache.cache">
            function <span class="apidocSignatureSpan">xregexp.</span>cache
            <span class="apidocSignatureSpan">(pattern, flags)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.xregexp.cache.flush">
            function <span class="apidocSignatureSpan">xregexp.cache.</span>flush
            <span class="apidocSignatureSpan">(cacheName)</span>
            </a>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.xregexp" id="apidoc.module.xregexp">module xregexp</a></h1>


    <h2>
        <a href="#apidoc.element.xregexp._dec" id="apidoc.element.xregexp._dec">
        function <span class="apidocSignatureSpan">xregexp.</span>_dec
        <span class="apidocSignatureSpan">(hex)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function dec(hex) {
    return parseInt(hex, 16);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.xregexp._hasNativeFlag" id="apidoc.element.xregexp._hasNativeFlag">
        function <span class="apidocSignatureSpan">xregexp.</span>_hasNativeFlag
        <span class="apidocSignatureSpan">(flag)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function hasNativeFlag(flag) {
    // Can&#x27;t check based on the presense of properties/getters since browsers might support such
    // properties even when they don&#x27;t support the corresponding flag in regex construction (tested
    // in Chrome 48, where `&#x27;unicode&#x27; in /x/` is true but trying to construct a regex with flag `u`
    // throws an error)
    var isSupported = true;
    try {
        // Can&#x27;t use regex literals for testing even in a `try` because regex literals with
        // unsupported flags cause a compilation error in IE
        new RegExp(&#x27;&#x27;, flag);
    } catch (exception) {
        isSupported = false;
    }
    if (isSupported &#x26;&#x26; flag === &#x27;y&#x27;) {
        // Work around Safari 9.1.1 bug
        return new RegExp(&#x27;aa|.&#x27;, &#x27;y&#x27;).test(&#x27;b&#x27;);
    }
    return isSupported;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.xregexp._hex" id="apidoc.element.xregexp._hex">
        function <span class="apidocSignatureSpan">xregexp.</span>_hex
        <span class="apidocSignatureSpan">(dec)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function hex(dec) {
    return parseInt(dec, 10).toString(16);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.xregexp._pad4" id="apidoc.element.xregexp._pad4">
        function <span class="apidocSignatureSpan">xregexp.</span>_pad4
        <span class="apidocSignatureSpan">(str)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function pad4(str) {
    while (str.length &#x3c; 4) {
        str = &#x27;0&#x27; + str;
    }
    return str;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.xregexp.addToken" id="apidoc.element.xregexp.addToken">
        function <span class="apidocSignatureSpan">xregexp.</span>addToken
        <span class="apidocSignatureSpan">(regex, handler, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">addToken = function (regex, handler, options) {
    options = options || {};
    var optionalFlags = options.optionalFlags, i;

    if (options.flag) {
        registerFlag(options.flag);
    }

    if (optionalFlags) {
        optionalFlags = nativ.split.call(optionalFlags, &#x27;&#x27;);
        for (i = 0; i &#x3c; optionalFlags.length; ++i) {
            registerFlag(optionalFlags[i]);
        }
    }

    // Add to the private list of syntax tokens
    tokens.push({
        regex: copyRegex(regex, {
            addG: true,
            addY: hasNativeY,
            isInternalOnly: true
        }),
        handler: handler,
        scope: options.scope || defaultScope,
        flag: options.flag,
        reparse: options.reparse,
        leadChar: options.leadChar
    });

    // Reset the pattern cache used by the `XRegExp` constructor, since the same pattern and flags
    // might now produce different results
    XRegExp.cache.flush(&#x27;patterns&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.xregexp.addUnicodeData" id="apidoc.element.xregexp.addUnicodeData">
        function <span class="apidocSignatureSpan">xregexp.</span>addUnicodeData
        <span class="apidocSignatureSpan">(data)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">addUnicodeData = function (data) {
    var ERR_NO_NAME = &#x27;Unicode token requires name&#x27;,
        ERR_NO_DATA = &#x27;Unicode token has no character data &#x27;,
        item,
        i;

    for (i = 0; i &#x3c; data.length; ++i) {
        item = data[i];
        if (!item.name) {
            throw new Error(ERR_NO_NAME);
        }
        if (!(item.inverseOf || item.bmp || item.astral)) {
            throw new Error(ERR_NO_DATA + item.name);
        }
        unicode[normalize(item.name)] = item;
        if (item.alias) {
            unicode[normalize(item.alias)] = item;
        }
    }

    // Reset the pattern cache used by the `XRegExp` constructor, since the same pattern and
    // flags might now produce different results
    XRegExp.cache.flush(&#x27;patterns&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.xregexp.build" id="apidoc.element.xregexp.build">
        function <span class="apidocSignatureSpan">xregexp.</span>build
        <span class="apidocSignatureSpan">(pattern, subs, flags)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">build = function (pattern, subs, flags) {
    var inlineFlags = /^\(\?([\w$]+)\)/.exec(pattern),
        data = {},
        numCaps = 0, // &#x27;Caps&#x27; is short for captures
        numPriorCaps,
        numOuterCaps = 0,
        outerCapsMap = [0],
        outerCapNames,
        sub,
        p;

    // Add flags within a leading mode modifier to the overall pattern&#x27;s flags
    if (inlineFlags) {
        flags = flags || &#x27;&#x27;;
        inlineFlags[1].replace(/./g, function(flag) {
            // Don&#x27;t add duplicates
            flags += (flags.indexOf(flag) &#x3e; -1 ? &#x27;&#x27; : flag);
        });
    }

    for (p in subs) {
        if (subs.hasOwnProperty(p)) {
            // Passing to XRegExp enables extended syntax and ensures independent validity,
            // lest an unescaped `(`, `)`, `[`, or trailing `\` breaks the `(?:)` wrapper. For
            // subpatterns provided as native regexes, it dies on octals and adds the property
            // used to hold extended regex instance data, for simplicity
            sub = asXRegExp(subs[p]);
            data[p] = {
                // Deanchoring allows embedding independently useful anchored regexes. If you
                // really need to keep your anchors, double them (i.e., `^^...$$`)
                pattern: deanchor(sub.source),
                names: sub[REGEX_DATA].captureNames || []
            };
        }
    }

    // Passing to XRegExp dies on octals and ensures the outer pattern is independently valid;
    // helps keep this simple. Named captures will be put back
    pattern = asXRegExp(pattern);
    outerCapNames = pattern[REGEX_DATA].captureNames || [];
    pattern = pattern.source.replace(parts, function($0, $1, $2, $3, $4) {
        var subName = $1 || $2,
            capName,
            intro,
            localCapIndex;
        // Named subpattern
        if (subName) {
            if (!data.hasOwnProperty(subName)) {
                throw new ReferenceError(&#x27;Undefined property &#x27; + $0);
            }
            // Named subpattern was wrapped in a capturing group
            if ($1) {
                capName = outerCapNames[numOuterCaps];
                outerCapsMap[++numOuterCaps] = ++numCaps;
                // If it&#x27;s a named group, preserve the name. Otherwise, use the subpattern name
                // as the capture name
                intro = &#x27;(?&#x3c;&#x27; + (capName || subName) + &#x27;&#x3e;&#x27;;
            } else {
                intro = &#x27;(?:&#x27;;
            }
            numPriorCaps = numCaps;
            return intro + data[subName].pattern.replace(subParts, function(match, paren, backref) {
                // Capturing group
                if (paren) {
                    capName = data[subName].names[numCaps - numPriorCaps];
                    ++numCaps;
                    // If the current capture has a name, preserve the name
                    if (capName) {
                        return &#x27;(?&#x3c;&#x27; + capName + &#x27;&#x3e;&#x27;;
                    }
                // Backreference
                } else if (backref) {
                    localCapIndex = +backref - 1;
                    // Rewrite the backreference
                    return data[subName].names[localCapIndex] ?
                        // Need to preserve the backreference name in case using flag `n`
                        &#x27;\\k&#x3c;&#x27; + data[subName].names[localCapIndex] + &#x27;&#x3e;&#x27; :
                        &#x27;\\&#x27; + (+backref + numPriorCaps);
                }
                return match;
            }) + &#x27;)&#x27;;
        }
        // Capturing group
        if ($3) {
            capName = outerCapNames[numOuterCaps];
            outerCapsMap[++numOuterCaps] = ++numCaps;
            // If the current capture has a name, preserve the name
            if (capName) {
                return &#x27;(?&#x3c;&#x27; + capName + &#x27;&#x3e;&#x27;;
            }
        // Backreference
        } else if ($4) {
            localCapIndex = +$4 - 1;
            // Rewrite the backreference
            return outerCapNames[localCapIndex] ?
                // Need to preserve the backreference name in case using flag `n`
                &#x27;\\k&#x3c;&#x27; + outerCapNames[localCapInde ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
XRegExp uses Unicode 8.0.0.

### XRegExp.build

Build regular expressions using named subpatterns, for readability and pattern reuse:

```js
var time = XRegExp.<span class="apidocCodeKeywordSpan">build</span>(&#x27;(?x)^ {{hours}} ({{minutes}}) $&#x27;, {
    hours: XRegExp.build(&#x27;{{h12}} : | {{h24}}&#x27;, {
        h12: /1[0-2]|0?[1-9]/,
        h24: /2[0-3]|[01][0-9]/
    }),
    minutes: /^[0-5][0-9]$/
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.xregexp.cache" id="apidoc.element.xregexp.cache">
        function <span class="apidocSignatureSpan">xregexp.</span>cache
        <span class="apidocSignatureSpan">(pattern, flags)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">cache = function (pattern, flags) {
    if (!regexCache[pattern]) {
        regexCache[pattern] = {};
    }
    return regexCache[pattern][flags] || (
        regexCache[pattern][flags] = XRegExp(pattern, flags)
    );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.xregexp.escape" id="apidoc.element.xregexp.escape">
        function <span class="apidocSignatureSpan">xregexp.</span>escape
        <span class="apidocSignatureSpan">(str)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">escape = function (str) {
    return nativ.replace.call(toObject(str), /[-[\]{}()*+?.,\\^$|#\s]/g, &#x27;\\$&#x26;&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.xregexp.exec" id="apidoc.element.xregexp.exec">
        function <span class="apidocSignatureSpan">xregexp.</span>exec
        <span class="apidocSignatureSpan">(str, regex, pos, sticky)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">exec = function (str, regex, pos, sticky) {
    var cacheKey = &#x27;g&#x27;,
        addY = false,
        match,
        r2;

    addY = hasNativeY &#x26;&#x26; !!(sticky || (regex.sticky &#x26;&#x26; sticky !== false));
    if (addY) {
        cacheKey += &#x27;y&#x27;;
    }

    regex[REGEX_DATA] = regex[REGEX_DATA] || {};

    // Shares cached copies with `XRegExp.match`/`replace`
    r2 = regex[REGEX_DATA][cacheKey] || (
        regex[REGEX_DATA][cacheKey] = copyRegex(regex, {
            addG: true,
            addY: addY,
            removeY: sticky === false,
            isInternalOnly: true
        })
    );

    r2.lastIndex = pos = pos || 0;

    // Fixed `exec` required for `lastIndex` fix, named backreferences, etc.
    match = fixed.exec.call(r2, str);

    if (sticky &#x26;&#x26; match &#x26;&#x26; match.index !== pos) {
        match = null;
    }

    if (regex.global) {
        regex.lastIndex = match ? r2.lastIndex : 0;
    }

    return match;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
```js
// Using named capture and flag x (free-spacing and line comments)
var date = XRegExp(&#x27;(?&#x3c;year&#x3e;  [0-9]{4} ) -?  # year  \n\
                (?&#x3c;month&#x3e; [0-9]{2} ) -?  # month \n\
                (?&#x3c;day&#x3e;   [0-9]{2} )     # day   &#x27;, &#x27;x&#x27;);

// XRegExp.exec gives you named backreferences on the match result
var match = XRegExp.<span class="apidocCodeKeywordSpan">exec</span>(&#x27;2015-02-22&#x27;, date);
match.year; // -&#x3e; &#x27;2015&#x27;

// It also includes optional pos and sticky arguments
var pos = 3;
var result = [];
while (match = XRegExp.exec(&#x27;&#x3c;1&#x3e;&#x3c;2&#x3e;&#x3c;3&#x3e;&#x3c;4&#x3e;5&#x3c;6&#x3e;&#x27;, /&#x3c;(\d+)&#x3e;/,
pos, &#x27;sticky&#x27;)) {
result.push(match[1]);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.xregexp.forEach" id="apidoc.element.xregexp.forEach">
        function <span class="apidocSignatureSpan">xregexp.</span>forEach
        <span class="apidocSignatureSpan">(str, regex, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">forEach = function (str, regex, callback) {
    var pos = 0,
        i = -1,
        match;

    while ((match = XRegExp.exec(str, regex, pos))) {
        // Because `regex` is provided to `callback`, the function could use the deprecated/
        // nonstandard `RegExp.prototype.compile` to mutate the regex. However, since `XRegExp.exec`
        // doesn&#x27;t use `lastIndex` to set the search position, this can&#x27;t lead to an infinite loop,
        // at least. Actually, because of the way `XRegExp.exec` caches globalized versions of
        // regexes, mutating the regex will not have any effect on the iteration or matched strings,
        // which is a nice side effect that brings extra safety.
        callback(match, ++i, str, regex);

        pos = match.index + (match[0].length || 1);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// The only caveat is that named captures must be referenced using numbered
// backreferences if used with native methods
&#x27;2015-02-22&#x27;.replace(date, &#x27;$2/$3/$1&#x27;);
// -&#x3e; &#x27;02/22/2015&#x27;

// Extract every other digit from a string using XRegExp.forEach
var evens = [];
XRegExp.<span class="apidocCodeKeywordSpan">forEach</span>(&#x27;1a2345&#x27;, /\d/, function(match, i) {
if (i % 2) evens.push(+match[0]);
});
// evens -&#x3e; [2, 4]

// Get numbers within &#x3c;b&#x3e; tags using XRegExp.matchChain
XRegExp.matchChain(&#x27;1 &#x3c;b&#x3e;2&#x3c;/b&#x3e; 3 &#x3c;b&#x3e;4 a 56&#x3c;/b&#x3e;&#x27;, [
XRegExp(&#x27;(?is)&#x3c;b&#x3e;.*?&#x3c;/b&#x3e;&#x27;),
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.xregexp.globalize" id="apidoc.element.xregexp.globalize">
        function <span class="apidocSignatureSpan">xregexp.</span>globalize
        <span class="apidocSignatureSpan">(regex)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">globalize = function (regex) {
    return copyRegex(regex, {addG: true});
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.xregexp.install" id="apidoc.element.xregexp.install">
        function <span class="apidocSignatureSpan">xregexp.</span>install
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">install = function (options) {
    options = prepareOptions(options);

    if (!features.astral &#x26;&#x26; options.astral) {
        setAstral(true);
    }

    if (!features.natives &#x26;&#x26; options.natives) {
        setNatives(true);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
unicodeWord.test(&#x27;العربية&#x27;); // -&#x3e; true

// Test some Unicode scripts
XRegExp(&#x27;^\\p{Hiragana}+$&#x27;).test(&#x27;ひらがな&#x27;); // -&#x3e; true
XRegExp(&#x27;^[\\p{Latin}\\p{Common}]+$&#x27;).test(&#x27;Über Café.&#x27;); // -&#x3e; true
```

By default, `\p{…}` and `\P{…}` support the Basic Multilingual Plane (i.e. code points up to `U+FFFF`). You can opt-in to full 21
-bit Unicode support (with code points up to `U+10FFFF`) on a per-regex basis by using flag `A`. In XRegExp, this is called *astral
 mode*. You can automatically add flag `A` for all new regexes by running `XRegExp.<span class="apidocCodeKeywordSpan">install</
span>(&#x27;astral&#x27;)`. When in astral mode, `\p{…}` and `\P{…}` always match a full code point rather than a code unit, using surrogate pairs for code points above `U+FFFF`.

```js
// Using flag A to match astral code points
XRegExp(&#x27;^\\pS$&#x27;).test(&#x27;💩&#x27;); // -&#x3e; false
XRegExp(&#x27;^\\pS$&#x27;, &#x27;A&#x27;).test(&#x27;💩&#x27;); // -&#x3e; true
XRegExp(&#x27;(?A)^\\pS$&#x27;).test(&#x27;💩&#x27;); // -&#x3e; true
// Using surrogate pair U+D83D U+DCA9 to represent U+1F4A9 (pile of poo)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.xregexp.isInstalled" id="apidoc.element.xregexp.isInstalled">
        function <span class="apidocSignatureSpan">xregexp.</span>isInstalled
        <span class="apidocSignatureSpan">(feature)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isInstalled = function (feature) {
    return !!(features[feature]);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.xregexp.isRegExp" id="apidoc.element.xregexp.isRegExp">
        function <span class="apidocSignatureSpan">xregexp.</span>isRegExp
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isRegExp = function (value) {
    return toString.call(value) === &#x27;[object RegExp]&#x27;;
    //return isType(value, &#x27;RegExp&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.xregexp.match" id="apidoc.element.xregexp.match">
        function <span class="apidocSignatureSpan">xregexp.</span>match
        <span class="apidocSignatureSpan">(str, regex, scope)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">match = function (str, regex, scope) {
    var global = (regex.global &#x26;&#x26; scope !== &#x27;one&#x27;) || scope === &#x27;all&#x27;,
        cacheKey = ((global ? &#x27;g&#x27; : &#x27;&#x27;) + (regex.sticky ? &#x27;y&#x27; : &#x27;&#x27;)) || &#x27;noGY&#x27;,
        result,
        r2;

    regex[REGEX_DATA] = regex[REGEX_DATA] || {};

    // Shares cached copies with `XRegExp.exec`/`replace`
    r2 = regex[REGEX_DATA][cacheKey] || (
        regex[REGEX_DATA][cacheKey] = copyRegex(regex, {
            addG: !!global,
            removeG: scope === &#x27;one&#x27;,
            isInternalOnly: true
        })
    );

    result = nativ.match.call(toObject(str), r2);

    if (regex.global) {
        regex.lastIndex = (
            (scope === &#x27;one&#x27; &#x26;&#x26; result) ?
                // Can&#x27;t use `r2.lastIndex` since `r2` is nonglobal in this case
                (result.index + result[0].length) : 0
        );
    }

    return global ? (result || []) : (result &#x26;&#x26; result[0]);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.xregexp.matchChain" id="apidoc.element.xregexp.matchChain">
        function <span class="apidocSignatureSpan">xregexp.</span>matchChain
        <span class="apidocSignatureSpan">(str, chain)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">matchChain = function (str, chain) {
    return (function recurseChain(values, level) {
        var item = chain[level].regex ? chain[level] : {regex: chain[level]};
        var matches = [];

        function addMatch(match) {
            if (item.backref) {
                // Safari 4.0.5 (but not 5.0.5+) inappropriately uses sparse arrays to hold the
                // `undefined`s for backreferences to nonparticipating capturing groups. In such
                // cases, a `hasOwnProperty` or `in` check on its own would inappropriately throw
                // the exception, so also check if the backreference is a number that is within the
                // bounds of the array.
                if (!(match.hasOwnProperty(item.backref) || +item.backref &#x3c; match.length)) {
                    throw new ReferenceError(&#x27;Backreference to undefined group: &#x27; + item.backref);
                }

                matches.push(match[item.backref] || &#x27;&#x27;);
            } else {
                matches.push(match[0]);
            }
        }

        for (var i = 0; i &#x3c; values.length; ++i) {
            XRegExp.forEach(values[i], item.regex, addMatch);
        }

        return ((level === chain.length - 1) || !matches.length) ?
            matches :
            recurseChain(matches, level + 1);
    }([str], 0));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var evens = [];
XRegExp.forEach(&#x27;1a2345&#x27;, /\d/, function(match, i) {
    if (i % 2) evens.push(+match[0]);
});
// evens -&#x3e; [2, 4]

// Get numbers within &#x3c;b&#x3e; tags using XRegExp.matchChain
XRegExp.<span class="apidocCodeKeywordSpan">matchChain</span>(&#x27;1 &#x3c;b&#x3e;2&#x3c;/b&#x3e; 3 &#x3c;b&#x3e;4 a 56&#x3c;/b
&#x3e;&#x27;, [
    XRegExp(&#x27;(?is)&#x3c;b&#x3e;.*?&#x3c;/b&#x3e;&#x27;),
    /\d+/
]);
// -&#x3e; [&#x27;2&#x27;, &#x27;4&#x27;, &#x27;56&#x27;]

// You can also pass forward and return specific backreferences
var html = &#x27;&#x3c;a href=&#x22;http://xregexp.com/&#x22;&#x3e;XRegExp&#x3c;/a&#x3e;&#x27; +
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.xregexp.matchRecursive" id="apidoc.element.xregexp.matchRecursive">
        function <span class="apidocSignatureSpan">xregexp.</span>matchRecursive
        <span class="apidocSignatureSpan">(str, left, right, flags, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">matchRecursive = function (str, left, right, flags, options) {
    flags = flags || &#x27;&#x27;;
    options = options || {};
    var global = flags.indexOf(&#x27;g&#x27;) &#x3e; -1,
        sticky = flags.indexOf(&#x27;y&#x27;) &#x3e; -1,
        // Flag `y` is controlled internally
        basicFlags = flags.replace(/y/g, &#x27;&#x27;),
        escapeChar = options.escapeChar,
        vN = options.valueNames,
        output = [],
        openTokens = 0,
        delimStart = 0,
        delimEnd = 0,
        lastOuterEnd = 0,
        outerStart,
        innerStart,
        leftMatch,
        rightMatch,
        esc;
    left = XRegExp(left, basicFlags);
    right = XRegExp(right, basicFlags);

    if (escapeChar) {
        if (escapeChar.length &#x3e; 1) {
            throw new Error(&#x27;Cannot use more than one escape character&#x27;);
        }
        escapeChar = XRegExp.escape(escapeChar);
        // Using `XRegExp.union` safely rewrites backreferences in `left` and `right`
        esc = new RegExp(
            &#x27;(?:&#x27; + escapeChar + &#x27;[\\S\\s]|(?:(?!&#x27; +
                XRegExp.union([left, right]).source +
                &#x27;)[^&#x27; + escapeChar + &#x27;])+)+&#x27;,
            // Flags `gy` not needed here
            flags.replace(/[^imu]+/g, &#x27;&#x27;)
        );
    }

    while (true) {
        // If using an escape character, advance to the delimiter&#x27;s next starting position,
        // skipping any escaped characters in between
        if (escapeChar) {
            delimEnd += (XRegExp.exec(str, esc, delimEnd, &#x27;sticky&#x27;) || [&#x27;&#x27;])[0].length;
        }
        leftMatch = XRegExp.exec(str, left, delimEnd);
        rightMatch = XRegExp.exec(str, right, delimEnd);
        // Keep the leftmost match only
        if (leftMatch &#x26;&#x26; rightMatch) {
            if (leftMatch.index &#x3c;= rightMatch.index) {
                rightMatch = null;
            } else {
                leftMatch = null;
            }
        }
        // Paths (LM: leftMatch, RM: rightMatch, OT: openTokens):
        // LM | RM | OT | Result
        // 1  | 0  | 1  | loop
        // 1  | 0  | 0  | loop
        // 0  | 1  | 1  | loop
        // 0  | 1  | 0  | throw
        // 0  | 0  | 1  | throw
        // 0  | 0  | 0  | break
        // The paths above don&#x27;t include the sticky mode special case. The loop ends after the
        // first completed match if not `global`.
        if (leftMatch || rightMatch) {
            delimStart = (leftMatch || rightMatch).index;
            delimEnd = delimStart + (leftMatch || rightMatch)[0].length;
        } else if (!openTokens) {
            break;
        }
        if (sticky &#x26;&#x26; !openTokens &#x26;&#x26; delimStart &#x3e; lastOuterEnd) {
            break;
        }
        if (leftMatch) {
            if (!openTokens) {
                outerStart = delimStart;
                innerStart = delimEnd;
            }
            ++openTokens;
        } else if (rightMatch &#x26;&#x26; openTokens) {
            if (!--openTokens) {
                if (vN) {
                    if (vN[0] &#x26;&#x26; outerStart &#x3e; lastOuterEnd) {
                        output.push(row(vN[0], str.slice(lastOuterEnd, outerStart), lastOuterEnd, outerStart));
                    }
                    if (vN[1]) {
                        output.push(row(vN[1], str.slice(outerStart, innerStart), outerStart, innerStart));
                    }
                    if (vN[2]) {
                        output.push(row(vN[2], str.slice(innerStart, delimStart), innerStart, delimStart));
                    }
                    if (vN[3]) {
                        output.push(row(vN[3], str.slice(delimStart, delimEnd), delimStart, delimEnd));
                    }
                } else {
                    output.push(str.slice(innerStart, delimStart));
                }
                lastOuterEnd = delimEnd;
                if (!global) {
                    break;
                }
            }
        } else {
            throw new Error(&#x27;Unbalanced delimiter found in string&#x27;);
        }
        // If the delimiter matched an empty string, avoid an infinite loop
        if (delimStart === delimEnd) {
            ++delimEnd;
        }
    }

    if (global &#x26;&#x26; !sticky &#x26;&#x26; vN &#x26; ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...

### XRegExp.matchRecursive

Match recursive constructs using XRegExp pattern strings as left and right delimiters:

```js
var str = &#x27;(t((e))s)t()(ing)&#x27;;
XRegExp.<span class="apidocCodeKeywordSpan">matchRecursive</span>(str, &#x27;\\(&#x27;, &#x27;\\)&#x27;, &#x27;g&#x27;);
// -&#x3e; [&#x27;t((e))s&#x27;, &#x27;&#x27;, &#x27;ing&#x27;]

// Extended information mode with valueNames
str = &#x27;Here is &#x3c;div&#x3e; &#x3c;div&#x3e;an&#x3c;/div&#x3e;&#x3c;/div&#x3e; example&#x27;;
XRegExp.matchRecursive(str, &#x27;&#x3c;div\\s*&#x3e;&#x27;, &#x27;&#x3c;/div&#x3e;&#x27;, &#x27;gi&#x27;, {
    valueNames: [&#x27;between&#x27;, &#x27;left&#x27;, &#x27;match&#x27;, &#x27;right&#x27;]
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.xregexp.replace" id="apidoc.element.xregexp.replace">
        function <span class="apidocSignatureSpan">xregexp.</span>replace
        <span class="apidocSignatureSpan">(str, search, replacement, scope)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">replace = function (str, search, replacement, scope) {
    var isRegex = XRegExp.isRegExp(search),
        global = (search.global &#x26;&#x26; scope !== &#x27;one&#x27;) || scope === &#x27;all&#x27;,
        cacheKey = ((global ? &#x27;g&#x27; : &#x27;&#x27;) + (search.sticky ? &#x27;y&#x27; : &#x27;&#x27;)) || &#x27;noGY&#x27;,
        s2 = search,
        result;

    if (isRegex) {
        search[REGEX_DATA] = search[REGEX_DATA] || {};

        // Shares cached copies with `XRegExp.exec`/`match`. Since a copy is used, `search`&#x27;s
        // `lastIndex` isn&#x27;t updated *during* replacement iterations
        s2 = search[REGEX_DATA][cacheKey] || (
            search[REGEX_DATA][cacheKey] = copyRegex(search, {
                addG: !!global,
                removeG: scope === &#x27;one&#x27;,
                isInternalOnly: true
            })
        );
    } else if (global) {
        s2 = new RegExp(XRegExp.escape(String(search)), &#x27;g&#x27;);
    }

    // Fixed `replace` required for named backreferences, etc.
    result = fixed.replace.call(toObject(str), s2, replacement);

    if (isRegex &#x26;&#x26; search.global) {
        // Fixes IE, Safari bug (last tested IE 9, Safari 5.1)
        search.lastIndex = 0;
    }

    return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
while (match = XRegExp.exec(&#x27;&#x3c;1&#x3e;&#x3c;2&#x3e;&#x3c;3&#x3e;&#x3c;4&#x3e;5&#x3c;6&#x3e;&#x27;, /&#x3c;(\d+)&#x3e;/,
pos, &#x27;sticky&#x27;)) {
    result.push(match[1]);
    pos = match.index + match[0].length;
}
// result -&#x3e; [&#x27;2&#x27;, &#x27;3&#x27;, &#x27;4&#x27;]

// XRegExp.replace allows named backreferences in replacements
XRegExp.<span class="apidocCodeKeywordSpan">replace</span>(&#x27;2015-02-22&#x27;, date, &#x27;${month}/${day}/${year}&#x27;);
// -&#x3e; &#x27;02/22/2015&#x27;
XRegExp.replace(&#x27;2015-02-22&#x27;, date, function(match) {
    return match.month + &#x27;/&#x27; + match.day + &#x27;/&#x27; + match.year;
});
// -&#x3e; &#x27;02/22/2015&#x27;

// In fact, XRegExps compile to RegExps and work perfectly with native methods
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.xregexp.replaceEach" id="apidoc.element.xregexp.replaceEach">
        function <span class="apidocSignatureSpan">xregexp.</span>replaceEach
        <span class="apidocSignatureSpan">(str, replacements)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">replaceEach = function (str, replacements) {
    var i, r;

    for (i = 0; i &#x3c; replacements.length; ++i) {
        r = replacements[i];
        str = XRegExp.replace(str, r[0], r[1], r[2]);
    }

    return str;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.xregexp.split" id="apidoc.element.xregexp.split">
        function <span class="apidocSignatureSpan">xregexp.</span>split
        <span class="apidocSignatureSpan">(str, separator, limit)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">split = function (str, separator, limit) {
    return fixed.split.call(toObject(str), separator, limit);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.xregexp.test" id="apidoc.element.xregexp.test">
        function <span class="apidocSignatureSpan">xregexp.</span>test
        <span class="apidocSignatureSpan">(str, regex, pos, sticky)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">test = function (str, regex, pos, sticky) {
    // Do this the easy way :-)
    return !!XRegExp.exec(str, regex, pos, sticky);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// -&#x3e; &#x27;02/22/2015&#x27;
XRegExp.replace(&#x27;2015-02-22&#x27;, date, function(match) {
    return match.month + &#x27;/&#x27; + match.day + &#x27;/&#x27; + match.year;
});
// -&#x3e; &#x27;02/22/2015&#x27;

// In fact, XRegExps compile to RegExps and work perfectly with native methods
date.<span class="apidocCodeKeywordSpan">test</span>(&#x27;2015-02-22&#x27;);
// -&#x3e; true

// The only caveat is that named captures must be referenced using numbered
// backreferences if used with native methods
&#x27;2015-02-22&#x27;.replace(date, &#x27;$2/$3/$1&#x27;);
// -&#x3e; &#x27;02/22/2015&#x27;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.xregexp.uninstall" id="apidoc.element.xregexp.uninstall">
        function <span class="apidocSignatureSpan">xregexp.</span>uninstall
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">uninstall = function (options) {
    options = prepareOptions(options);

    if (features.astral &#x26;&#x26; options.astral) {
        setAstral(false);
    }

    if (features.natives &#x26;&#x26; options.natives) {
        setNatives(false);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.xregexp.union" id="apidoc.element.xregexp.union">
        function <span class="apidocSignatureSpan">xregexp.</span>union
        <span class="apidocSignatureSpan">(patterns, flags)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">union = function (patterns, flags) {
    var numCaptures = 0;
    var numPriorCaptures;
    var captureNames;

    function rewrite(match, paren, backref) {
        var name = captureNames[numCaptures - numPriorCaptures];

        // Capturing group
        if (paren) {
            ++numCaptures;
            // If the current capture has a name, preserve the name
            if (name) {
                return &#x27;(?&#x3c;&#x27; + name + &#x27;&#x3e;&#x27;;
            }
        // Backreference
        } else if (backref) {
            // Rewrite the backreference
            return &#x27;\\&#x27; + (+backref + numPriorCaptures);
        }

        return match;
    }

    if (!(isType(patterns, &#x27;Array&#x27;) &#x26;&#x26; patterns.length)) {
        throw new TypeError(&#x27;Must provide a nonempty array of patterns to merge&#x27;);
    }

    var parts = /(\()(?!\?)|\\([1-9]\d*)|\\[\s\S]|\[(?:[^\\\]]|\\[\s\S])*]/g;
    var output = [];
    var pattern;
    for (var i = 0; i &#x3c; patterns.length; ++i) {
        pattern = patterns[i];

        if (XRegExp.isRegExp(pattern)) {
            numPriorCaptures = numCaptures;
            captureNames = (pattern[REGEX_DATA] &#x26;&#x26; pattern[REGEX_DATA].captureNames) || [];

            // Rewrite backreferences. Passing to XRegExp dies on octals and ensures patterns are
            // independently valid; helps keep this simple. Named captures are put back
            output.push(nativ.replace.call(XRegExp(pattern.source).source, parts, rewrite));
        } else {
            output.push(XRegExp.escape(pattern));
        }
    }

    return XRegExp(output.join(&#x27;|&#x27;), flags);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
XRegExp.matchChain(html, [
    {regex: /&#x3c;a href=&#x22;([^&#x22;]+)&#x22;&#x3e;/i, backref: 1},
    {regex: XRegExp(&#x27;(?i)^https?://(?&#x3c;domain&#x3e;[^/?#]+)&#x27;), backref: &#x27;domain&#x27;}
]);
// -&#x3e; [&#x27;xregexp.com&#x27;, &#x27;www.google.com&#x27;]

// Merge strings and regexes into a single pattern with updated backreferences
XRegExp.<span class="apidocCodeKeywordSpan">union</span>([&#x27;a+b*c&#x27;, /(dog)\1/, /(cat)\1/], &#x27;i&#x27;);
// -&#x3e; /a\+b\*c|(dog)\1|(cat)\2/i
```

These examples give the flavor of what&#x27;s possible, but XRegExp has more syntax, flags, methods, options, and browser fixes
that aren&#x27;t shown here. You can even augment XRegExp&#x27;s regular expression syntax with addons (see below) or write your
 own. See [xregexp.com](http://xregexp.com/) for details.

## Addons
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.xregexp.cache" id="apidoc.module.xregexp.cache">module xregexp.cache</a></h1>


    <h2>
        <a href="#apidoc.element.xregexp.cache.cache" id="apidoc.element.xregexp.cache.cache">
        function <span class="apidocSignatureSpan">xregexp.</span>cache
        <span class="apidocSignatureSpan">(pattern, flags)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">cache = function (pattern, flags) {
    if (!regexCache[pattern]) {
        regexCache[pattern] = {};
    }
    return regexCache[pattern][flags] || (
        regexCache[pattern][flags] = XRegExp(pattern, flags)
    );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.xregexp.cache.flush" id="apidoc.element.xregexp.cache.flush">
        function <span class="apidocSignatureSpan">xregexp.cache.</span>flush
        <span class="apidocSignatureSpan">(cacheName)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">flush = function (cacheName) {
    if (cacheName === &#x27;patterns&#x27;) {
        // Flush the pattern cache used by the `XRegExp` constructor
        patternCache = {};
    } else {
        // Flush the regex cache populated by `XRegExp.cache`
        regexCache = {};
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>

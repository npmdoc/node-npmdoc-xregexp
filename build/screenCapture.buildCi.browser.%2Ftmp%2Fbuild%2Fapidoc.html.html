<html><head></head><body><div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a href="http://xregexp.com/">xregexp (v3.2.0)</a>
</h1>
<h4>Extended regular expressions</h4>
<div class="apidocSectionDiv"><a href="#apidoc.tableOfContents" id="apidoc.tableOfContents"><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.xregexp">module xregexp</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.xregexp.xregexp">
            function <span class="apidocSignatureSpan"></span>xregexp
            <span class="apidocSignatureSpan">(pattern, flags)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.xregexp._clipDuplicates">
            function <span class="apidocSignatureSpan">xregexp.</span>_clipDuplicates
            <span class="apidocSignatureSpan">(str)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.xregexp._dec">
            function <span class="apidocSignatureSpan">xregexp.</span>_dec
            <span class="apidocSignatureSpan">(hex)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.xregexp._getUnicodeProperty">
            function <span class="apidocSignatureSpan">xregexp.</span>_getUnicodeProperty
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.xregexp._hasNativeFlag">
            function <span class="apidocSignatureSpan">xregexp.</span>_hasNativeFlag
            <span class="apidocSignatureSpan">(flag)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.xregexp._hex">
            function <span class="apidocSignatureSpan">xregexp.</span>_hex
            <span class="apidocSignatureSpan">(dec)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.xregexp._pad4">
            function <span class="apidocSignatureSpan">xregexp.</span>_pad4
            <span class="apidocSignatureSpan">(str)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.xregexp.addToken">
            function <span class="apidocSignatureSpan">xregexp.</span>addToken
            <span class="apidocSignatureSpan">(regex, handler, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.xregexp.addUnicodeData">
            function <span class="apidocSignatureSpan">xregexp.</span>addUnicodeData
            <span class="apidocSignatureSpan">(data)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.xregexp.build">
            function <span class="apidocSignatureSpan">xregexp.</span>build
            <span class="apidocSignatureSpan">(pattern, subs, flags)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.xregexp.cache">
            function <span class="apidocSignatureSpan">xregexp.</span>cache
            <span class="apidocSignatureSpan">(pattern, flags)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.xregexp.cache.flush">
            function <span class="apidocSignatureSpan">xregexp.</span>cache.flush
            <span class="apidocSignatureSpan">(cacheName)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.xregexp.escape">
            function <span class="apidocSignatureSpan">xregexp.</span>escape
            <span class="apidocSignatureSpan">(str)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.xregexp.exec">
            function <span class="apidocSignatureSpan">xregexp.</span>exec
            <span class="apidocSignatureSpan">(str, regex, pos, sticky)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.xregexp.forEach">
            function <span class="apidocSignatureSpan">xregexp.</span>forEach
            <span class="apidocSignatureSpan">(str, regex, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.xregexp.globalize">
            function <span class="apidocSignatureSpan">xregexp.</span>globalize
            <span class="apidocSignatureSpan">(regex)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.xregexp.install">
            function <span class="apidocSignatureSpan">xregexp.</span>install
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.xregexp.isInstalled">
            function <span class="apidocSignatureSpan">xregexp.</span>isInstalled
            <span class="apidocSignatureSpan">(feature)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.xregexp.isRegExp">
            function <span class="apidocSignatureSpan">xregexp.</span>isRegExp
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.xregexp.match">
            function <span class="apidocSignatureSpan">xregexp.</span>match
            <span class="apidocSignatureSpan">(str, regex, scope)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.xregexp.matchChain">
            function <span class="apidocSignatureSpan">xregexp.</span>matchChain
            <span class="apidocSignatureSpan">(str, chain)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.xregexp.matchRecursive">
            function <span class="apidocSignatureSpan">xregexp.</span>matchRecursive
            <span class="apidocSignatureSpan">(str, left, right, flags, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.xregexp.replace">
            function <span class="apidocSignatureSpan">xregexp.</span>replace
            <span class="apidocSignatureSpan">(str, search, replacement, scope)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.xregexp.replaceEach">
            function <span class="apidocSignatureSpan">xregexp.</span>replaceEach
            <span class="apidocSignatureSpan">(str, replacements)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.xregexp.split">
            function <span class="apidocSignatureSpan">xregexp.</span>split
            <span class="apidocSignatureSpan">(str, separator, limit)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.xregexp.test">
            function <span class="apidocSignatureSpan">xregexp.</span>test
            <span class="apidocSignatureSpan">(str, regex, pos, sticky)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.xregexp.toString">
            function <span class="apidocSignatureSpan">xregexp.</span>toString
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.xregexp.uninstall">
            function <span class="apidocSignatureSpan">xregexp.</span>uninstall
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.xregexp.union">
            function <span class="apidocSignatureSpan">xregexp.</span>union
            <span class="apidocSignatureSpan">(patterns, flags, options)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">xregexp.</span>version</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.xregexp._clipDuplicates">module xregexp._clipDuplicates</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.xregexp._clipDuplicates._clipDuplicates">
            function <span class="apidocSignatureSpan">xregexp.</span>_clipDuplicates
            <span class="apidocSignatureSpan">(str)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.xregexp._dec">module xregexp._dec</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.xregexp._dec._dec">
            function <span class="apidocSignatureSpan">xregexp.</span>_dec
            <span class="apidocSignatureSpan">(hex)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.xregexp._getUnicodeProperty">module xregexp._getUnicodeProperty</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.xregexp._getUnicodeProperty._getUnicodeProperty">
            function <span class="apidocSignatureSpan">xregexp.</span>_getUnicodeProperty
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.xregexp._hasNativeFlag">module xregexp._hasNativeFlag</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.xregexp._hasNativeFlag._hasNativeFlag">
            function <span class="apidocSignatureSpan">xregexp.</span>_hasNativeFlag
            <span class="apidocSignatureSpan">(flag)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.xregexp._hex">module xregexp._hex</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.xregexp._hex._hex">
            function <span class="apidocSignatureSpan">xregexp.</span>_hex
            <span class="apidocSignatureSpan">(dec)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.xregexp._pad4">module xregexp._pad4</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.xregexp._pad4._pad4">
            function <span class="apidocSignatureSpan">xregexp.</span>_pad4
            <span class="apidocSignatureSpan">(str)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.xregexp.addToken">module xregexp.addToken</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.xregexp.addToken.addToken">
            function <span class="apidocSignatureSpan">xregexp.</span>addToken
            <span class="apidocSignatureSpan">(regex, handler, options)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.xregexp.addUnicodeData">module xregexp.addUnicodeData</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.xregexp.addUnicodeData.addUnicodeData">
            function <span class="apidocSignatureSpan">xregexp.</span>addUnicodeData
            <span class="apidocSignatureSpan">(data)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.xregexp.build">module xregexp.build</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.xregexp.build.build">
            function <span class="apidocSignatureSpan">xregexp.</span>build
            <span class="apidocSignatureSpan">(pattern, subs, flags)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.xregexp.cache">module xregexp.cache</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.xregexp.cache.cache">
            function <span class="apidocSignatureSpan">xregexp.</span>cache
            <span class="apidocSignatureSpan">(pattern, flags)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.xregexp.cache.flush">
            function <span class="apidocSignatureSpan">xregexp.cache.</span>flush
            <span class="apidocSignatureSpan">(cacheName)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.xregexp.cache.flush">module xregexp.cache.flush</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.xregexp.cache.flush.flush">
            function <span class="apidocSignatureSpan">xregexp.cache.</span>flush
            <span class="apidocSignatureSpan">(cacheName)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.xregexp.escape">module xregexp.escape</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.xregexp.escape.escape">
            function <span class="apidocSignatureSpan">xregexp.</span>escape
            <span class="apidocSignatureSpan">(str)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.xregexp.exec">module xregexp.exec</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.xregexp.exec.exec">
            function <span class="apidocSignatureSpan">xregexp.</span>exec
            <span class="apidocSignatureSpan">(str, regex, pos, sticky)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.xregexp.forEach">module xregexp.forEach</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.xregexp.forEach.forEach">
            function <span class="apidocSignatureSpan">xregexp.</span>forEach
            <span class="apidocSignatureSpan">(str, regex, callback)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.xregexp.globalize">module xregexp.globalize</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.xregexp.globalize.globalize">
            function <span class="apidocSignatureSpan">xregexp.</span>globalize
            <span class="apidocSignatureSpan">(regex)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.xregexp.install">module xregexp.install</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.xregexp.install.install">
            function <span class="apidocSignatureSpan">xregexp.</span>install
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.xregexp.isInstalled">module xregexp.isInstalled</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.xregexp.isInstalled.isInstalled">
            function <span class="apidocSignatureSpan">xregexp.</span>isInstalled
            <span class="apidocSignatureSpan">(feature)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.xregexp.isRegExp">module xregexp.isRegExp</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.xregexp.isRegExp.isRegExp">
            function <span class="apidocSignatureSpan">xregexp.</span>isRegExp
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.xregexp.match">module xregexp.match</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.xregexp.match.match">
            function <span class="apidocSignatureSpan">xregexp.</span>match
            <span class="apidocSignatureSpan">(str, regex, scope)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.xregexp.matchChain">module xregexp.matchChain</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.xregexp.matchChain.matchChain">
            function <span class="apidocSignatureSpan">xregexp.</span>matchChain
            <span class="apidocSignatureSpan">(str, chain)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.xregexp.matchRecursive">module xregexp.matchRecursive</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.xregexp.matchRecursive.matchRecursive">
            function <span class="apidocSignatureSpan">xregexp.</span>matchRecursive
            <span class="apidocSignatureSpan">(str, left, right, flags, options)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.xregexp.replace">module xregexp.replace</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.xregexp.replace.replace">
            function <span class="apidocSignatureSpan">xregexp.</span>replace
            <span class="apidocSignatureSpan">(str, search, replacement, scope)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.xregexp.replaceEach">module xregexp.replaceEach</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.xregexp.replaceEach.replaceEach">
            function <span class="apidocSignatureSpan">xregexp.</span>replaceEach
            <span class="apidocSignatureSpan">(str, replacements)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.xregexp.split">module xregexp.split</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.xregexp.split.split">
            function <span class="apidocSignatureSpan">xregexp.</span>split
            <span class="apidocSignatureSpan">(str, separator, limit)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.xregexp.test">module xregexp.test</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.xregexp.test.test">
            function <span class="apidocSignatureSpan">xregexp.</span>test
            <span class="apidocSignatureSpan">(str, regex, pos, sticky)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.xregexp.toString">module xregexp.toString</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.xregexp.toString.toString">
            function <span class="apidocSignatureSpan">xregexp.</span>toString
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.xregexp.uninstall">module xregexp.uninstall</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.xregexp.uninstall.uninstall">
            function <span class="apidocSignatureSpan">xregexp.</span>uninstall
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.xregexp.union">module xregexp.union</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.xregexp.union.union">
            function <span class="apidocSignatureSpan">xregexp.</span>union
            <span class="apidocSignatureSpan">(patterns, flags, options)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.xregexp.xregexp">module xregexp.xregexp</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.xregexp.xregexp.xregexp">
            function <span class="apidocSignatureSpan">xregexp.</span>xregexp
            <span class="apidocSignatureSpan">(pattern, flags)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.xregexp.xregexp._clipDuplicates">
            function <span class="apidocSignatureSpan">xregexp.xregexp.</span>_clipDuplicates
            <span class="apidocSignatureSpan">(str)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.xregexp.xregexp._dec">
            function <span class="apidocSignatureSpan">xregexp.xregexp.</span>_dec
            <span class="apidocSignatureSpan">(hex)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.xregexp.xregexp._hasNativeFlag">
            function <span class="apidocSignatureSpan">xregexp.xregexp.</span>_hasNativeFlag
            <span class="apidocSignatureSpan">(flag)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.xregexp.xregexp._hex">
            function <span class="apidocSignatureSpan">xregexp.xregexp.</span>_hex
            <span class="apidocSignatureSpan">(dec)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.xregexp.xregexp._pad4">
            function <span class="apidocSignatureSpan">xregexp.xregexp.</span>_pad4
            <span class="apidocSignatureSpan">(str)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.xregexp.xregexp.addToken">
            function <span class="apidocSignatureSpan">xregexp.xregexp.</span>addToken
            <span class="apidocSignatureSpan">(regex, handler, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.xregexp.xregexp.cache">
            function <span class="apidocSignatureSpan">xregexp.xregexp.</span>cache
            <span class="apidocSignatureSpan">(pattern, flags)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.xregexp.xregexp.escape">
            function <span class="apidocSignatureSpan">xregexp.xregexp.</span>escape
            <span class="apidocSignatureSpan">(str)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.xregexp.xregexp.exec">
            function <span class="apidocSignatureSpan">xregexp.xregexp.</span>exec
            <span class="apidocSignatureSpan">(str, regex, pos, sticky)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.xregexp.xregexp.forEach">
            function <span class="apidocSignatureSpan">xregexp.xregexp.</span>forEach
            <span class="apidocSignatureSpan">(str, regex, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.xregexp.xregexp.globalize">
            function <span class="apidocSignatureSpan">xregexp.xregexp.</span>globalize
            <span class="apidocSignatureSpan">(regex)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.xregexp.xregexp.install">
            function <span class="apidocSignatureSpan">xregexp.xregexp.</span>install
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.xregexp.xregexp.isInstalled">
            function <span class="apidocSignatureSpan">xregexp.xregexp.</span>isInstalled
            <span class="apidocSignatureSpan">(feature)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.xregexp.xregexp.isRegExp">
            function <span class="apidocSignatureSpan">xregexp.xregexp.</span>isRegExp
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.xregexp.xregexp.match">
            function <span class="apidocSignatureSpan">xregexp.xregexp.</span>match
            <span class="apidocSignatureSpan">(str, regex, scope)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.xregexp.xregexp.matchChain">
            function <span class="apidocSignatureSpan">xregexp.xregexp.</span>matchChain
            <span class="apidocSignatureSpan">(str, chain)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.xregexp.xregexp.replace">
            function <span class="apidocSignatureSpan">xregexp.xregexp.</span>replace
            <span class="apidocSignatureSpan">(str, search, replacement, scope)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.xregexp.xregexp.replaceEach">
            function <span class="apidocSignatureSpan">xregexp.xregexp.</span>replaceEach
            <span class="apidocSignatureSpan">(str, replacements)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.xregexp.xregexp.split">
            function <span class="apidocSignatureSpan">xregexp.xregexp.</span>split
            <span class="apidocSignatureSpan">(str, separator, limit)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.xregexp.xregexp.test">
            function <span class="apidocSignatureSpan">xregexp.xregexp.</span>test
            <span class="apidocSignatureSpan">(str, regex, pos, sticky)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.xregexp.xregexp.uninstall">
            function <span class="apidocSignatureSpan">xregexp.xregexp.</span>uninstall
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.xregexp.xregexp.union">
            function <span class="apidocSignatureSpan">xregexp.xregexp.</span>union
            <span class="apidocSignatureSpan">(patterns, flags, options)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">xregexp.xregexp.</span>version</span>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.xregexp" id="apidoc.module.xregexp">module xregexp</a></h1>


    <h2>
        <a href="#apidoc.element.xregexp.xregexp" id="apidoc.element.xregexp.xregexp">
        function <span class="apidocSignatureSpan"></span>xregexp
        <span class="apidocSignatureSpan">(pattern, flags)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function XRegExp(pattern, flags) {
    if (XRegExp.isRegExp(pattern)) {
        if (flags !== undefined) {
            throw new TypeError('Cannot supply flags when copying a RegExp');
        }
        return copyRegex(pattern);
    }

    // Copy the argument behavior of `RegExp`
    pattern = pattern === undefined ? '' : String(pattern);
    flags = flags === undefined ? '' : String(flags);

    if (XRegExp.isInstalled('astral') &amp;&amp; flags.indexOf('A') === -1) {
        // This causes an error to be thrown if the Unicode Base addon is not available
        flags += 'A';
    }

    if (!patternCache[pattern]) {
        patternCache[pattern] = {};
    }

    if (!patternCache[pattern][flags]) {
        var context = {
            hasNamedCapture: false,
            captureNames: []
        };
        var scope = defaultScope;
        var output = '';
        var pos = 0;
        var result;

        // Check for flag-related errors, and strip/apply flags in a leading mode modifier
        var applied = prepareFlags(pattern, flags);
        var appliedPattern = applied.pattern;
        var appliedFlags = applied.flags;

        // Use XRegExp's tokens to translate the pattern to a native regex pattern.
        // `appliedPattern.length` may change on each iteration if tokens use `reparse`
        while (pos &lt; appliedPattern.length) {
            do {
                // Check for custom tokens at the current position
                result = runTokens(appliedPattern, appliedFlags, pos, scope, context);
                // If the matched token used the `reparse` option, splice its output into the
                // pattern before running tokens again at the same position
                if (result &amp;&amp; result.reparse) {
                    appliedPattern = appliedPattern.slice(0, pos) +
                        result.output +
                        appliedPattern.slice(pos + result.matchLength);
                }
            } while (result &amp;&amp; result.reparse);

            if (result) {
                output += result.output;
                pos += (result.matchLength || 1);
            } else {
                // Get the native token at the current position
                var token = XRegExp.exec(appliedPattern, nativeTokens[scope], pos, 'sticky')[0];
                output += token;
                pos += token.length;
                if (token === '[' &amp;&amp; scope === defaultScope) {
                    scope = classScope;
                } else if (token === ']' &amp;&amp; scope === classScope) {
                    scope = defaultScope;
                }
            }
        }

        patternCache[pattern][flags] = {
            // Use basic cleanup to collapse repeated empty groups like `(?:)(?:)` to `(?:)`. Empty
            // groups are sometimes inserted during regex transpilation in order to keep tokens
            // separated. However, more than one empty group in a row is never needed.
            pattern: nativ.replace.call(output, /(?:\(\?:\))+/g, '(?:)'),
            // Strip all but native flags
            flags: nativ.replace.call(appliedFlags, /[^gimuy]+/g, ''),
            // `context.captureNames` has an item for each capturing group, even if unnamed
            captures: context.hasNamedCapture ? context.captureNames : null
        };
    }

    var generated = patternCache[pattern][flags];
    return augment(
        new RegExp(generated.pattern, generated.flags),
        generated.captures,
        pattern,
        flags
    );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.xregexp._clipDuplicates" id="apidoc.element.xregexp._clipDuplicates">
        function <span class="apidocSignatureSpan">xregexp.</span>_clipDuplicates
        <span class="apidocSignatureSpan">(str)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function clipDuplicates(str) {
    return nativ.replace.call(str, /([\s\S])(?=[\s\S]*\1)/g, '');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// Used with `asXRegExp` calls for `pattern` and subpatterns in `subs`, to work around how
// some browsers convert `RegExp('\n')` to a regex that contains the literal characters `\`
// and `n`. See more details at &lt;https://github.com/slevithan/xregexp/pull/163&gt;.
var addFlagX = flags.indexOf('x') &gt; -1;
var inlineFlags = /^\(\?([\w$]+)\)/.exec(pattern);
// Add flags within a leading mode modifier to the overall pattern's flags
if (inlineFlags) {
    flags = XRegExp.<span class="apidocCodeKeywordSpan">_clipDuplicates</span>(flags + inlineFlags[1]);
}

var data = {};
for (var p in subs) {
    if (subs.hasOwnProperty(p)) {
        // Passing to XRegExp enables extended syntax and ensures independent validity,
        // lest an unescaped `(`, `)`, `[`, or trailing `\` breaks the `(?:)` wrapper. For
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.xregexp._dec" id="apidoc.element.xregexp._dec">
        function <span class="apidocSignatureSpan">xregexp.</span>_dec
        <span class="apidocSignatureSpan">(hex)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function dec(hex) {
    return parseInt(hex, 16);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.xregexp._getUnicodeProperty" id="apidoc.element.xregexp._getUnicodeProperty">
        function <span class="apidocSignatureSpan">xregexp.</span>_getUnicodeProperty
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_getUnicodeProperty = function (name) {
    var slug = normalize(name);
    return unicode[slug];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.xregexp._hasNativeFlag" id="apidoc.element.xregexp._hasNativeFlag">
        function <span class="apidocSignatureSpan">xregexp.</span>_hasNativeFlag
        <span class="apidocSignatureSpan">(flag)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function hasNativeFlag(flag) {
    // Can't check based on the presence of properties/getters since browsers might support such
    // properties even when they don't support the corresponding flag in regex construction (tested
    // in Chrome 48, where `'unicode' in /x/` is true but trying to construct a regex with flag `u`
    // throws an error)
    var isSupported = true;
    try {
        // Can't use regex literals for testing even in a `try` because regex literals with
        // unsupported flags cause a compilation error in IE
        new RegExp('', flag);
    } catch (exception) {
        isSupported = false;
    }
    return isSupported;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.xregexp._hex" id="apidoc.element.xregexp._hex">
        function <span class="apidocSignatureSpan">xregexp.</span>_hex
        <span class="apidocSignatureSpan">(dec)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function hex(dec) {
    return parseInt(dec, 10).toString(16);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.xregexp._pad4" id="apidoc.element.xregexp._pad4">
        function <span class="apidocSignatureSpan">xregexp.</span>_pad4
        <span class="apidocSignatureSpan">(str)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function pad4(str) {
    while (str.length &lt; 4) {
        str = '0' + str;
    }
    return str;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.xregexp.addToken" id="apidoc.element.xregexp.addToken">
        function <span class="apidocSignatureSpan">xregexp.</span>addToken
        <span class="apidocSignatureSpan">(regex, handler, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">addToken = function (regex, handler, options) {
    options = options || {};
    var optionalFlags = options.optionalFlags;
    var i;

    if (options.flag) {
        registerFlag(options.flag);
    }

    if (optionalFlags) {
        optionalFlags = nativ.split.call(optionalFlags, '');
        for (i = 0; i &lt; optionalFlags.length; ++i) {
            registerFlag(optionalFlags[i]);
        }
    }

    // Add to the private list of syntax tokens
    tokens.push({
        regex: copyRegex(regex, {
            addG: true,
            addY: hasNativeY,
            isInternalOnly: true
        }),
        handler: handler,
        scope: options.scope || defaultScope,
        flag: options.flag,
        reparse: options.reparse,
        leadChar: options.leadChar
    });

    // Reset the pattern cache used by the `XRegExp` constructor, since the same pattern and flags
    // might now produce different results
    XRegExp.cache.flush('patterns');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// ==--------------------------==
// Core functionality
// ==--------------------------==

/*
 * Add astral mode (flag A) and Unicode token syntax: `\p{..}`, `\P{..}`, `\p{^..}`, `\pC`.
 */
XRegExp.<span class="apidocCodeKeywordSpan">addToken</span>(
    // Use `*` instead of `+` to avoid capturing `^` as the token name in `\p{^}`
    /\\([pP])(?:{(\^?)([^}]*)}|([A-Za-z]))/,
    function(match, scope, flags) {
        var ERR_DOUBLE_NEG = 'Invalid double negation ';
        var ERR_UNKNOWN_NAME = 'Unknown Unicode token ';
        var ERR_UNKNOWN_REF = 'Unicode token missing data ';
        var ERR_ASTRAL_ONLY = 'Astral mode required for Unicode token ';
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.xregexp.addUnicodeData" id="apidoc.element.xregexp.addUnicodeData">
        function <span class="apidocSignatureSpan">xregexp.</span>addUnicodeData
        <span class="apidocSignatureSpan">(data)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">addUnicodeData = function (data) {
    var ERR_NO_NAME = 'Unicode token requires name';
    var ERR_NO_DATA = 'Unicode token has no character data ';
    var item;

    for (var i = 0; i &lt; data.length; ++i) {
        item = data[i];
        if (!item.name) {
            throw new Error(ERR_NO_NAME);
        }
        if (!(item.inverseOf || item.bmp || item.astral)) {
            throw new Error(ERR_NO_DATA + item.name);
        }
        unicode[normalize(item.name)] = item;
        if (item.alias) {
            unicode[normalize(item.alias)] = item;
        }
    }

    // Reset the pattern cache used by the `XRegExp` constructor, since the same pattern and
    // flags might now produce different results
    XRegExp.cache.flush('patterns');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 *   escaped, apart from range-creating hyphens. The `astral` data can additionally use
 *   character classes and alternation, and should use surrogate pairs to represent astral code
 *   points. `inverseOf` can be used to avoid duplicating character data if a Unicode token is
 *   defined as the exact inverse of another token.
 * @example
 *
 * // Basic use
 * XRegExp.<span class="apidocCodeKeywordSpan">addUnicodeData</span>([{
 *   name: 'XDigit',
 *   alias: 'Hexadecimal',
 *   bmp: '0-9A-Fa-f'
 * }]);
 * XRegExp('\\p{XDigit}:\\p{Hexadecimal}+').test('0:3D'); // -&gt; true
 */
XRegExp.addUnicodeData = function(data) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.xregexp.build" id="apidoc.element.xregexp.build">
        function <span class="apidocSignatureSpan">xregexp.</span>build
        <span class="apidocSignatureSpan">(pattern, subs, flags)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">build = function (pattern, subs, flags) {
    flags = flags || '';
    // Used with `asXRegExp` calls for `pattern` and subpatterns in `subs`, to work around how
    // some browsers convert `RegExp('\n')` to a regex that contains the literal characters `\`
    // and `n`. See more details at &lt;https://github.com/slevithan/xregexp/pull/163&gt;.
    var addFlagX = flags.indexOf('x') &gt; -1;
    var inlineFlags = /^\(\?([\w$]+)\)/.exec(pattern);
    // Add flags within a leading mode modifier to the overall pattern's flags
    if (inlineFlags) {
        flags = XRegExp._clipDuplicates(flags + inlineFlags[1]);
    }

    var data = {};
    for (var p in subs) {
        if (subs.hasOwnProperty(p)) {
            // Passing to XRegExp enables extended syntax and ensures independent validity,
            // lest an unescaped `(`, `)`, `[`, or trailing `\` breaks the `(?:)` wrapper. For
            // subpatterns provided as native regexes, it dies on octals and adds the property
            // used to hold extended regex instance data, for simplicity.
            var sub = asXRegExp(subs[p], addFlagX);
            data[p] = {
                // Deanchoring allows embedding independently useful anchored regexes. If you
                // really need to keep your anchors, double them (i.e., `^^...$$`).
                pattern: deanchor(sub.source),
                names: sub[REGEX_DATA].captureNames || []
            };
        }
    }

    // Passing to XRegExp dies on octals and ensures the outer pattern is independently valid;
    // helps keep this simple. Named captures will be put back.
    var patternAsRegex = asXRegExp(pattern, addFlagX);

    // 'Caps' is short for 'captures'
    var numCaps = 0;
    var numPriorCaps;
    var numOuterCaps = 0;
    var outerCapsMap = [0];
    var outerCapNames = patternAsRegex[REGEX_DATA].captureNames || [];
    var output = patternAsRegex.source.replace(parts, function($0, $1, $2, $3, $4) {
        var subName = $1 || $2;
        var capName;
        var intro;
        var localCapIndex;
        // Named subpattern
        if (subName) {
            if (!data.hasOwnProperty(subName)) {
                throw new ReferenceError('Undefined property ' + $0);
            }
            // Named subpattern was wrapped in a capturing group
            if ($1) {
                capName = outerCapNames[numOuterCaps];
                outerCapsMap[++numOuterCaps] = ++numCaps;
                // If it's a named group, preserve the name. Otherwise, use the subpattern name
                // as the capture name
                intro = '(?&lt;' + (capName || subName) + '&gt;';
            } else {
                intro = '(?:';
            }
            numPriorCaps = numCaps;
            return intro + data[subName].pattern.replace(subParts, function(match, paren, backref) {
                // Capturing group
                if (paren) {
                    capName = data[subName].names[numCaps - numPriorCaps];
                    ++numCaps;
                    // If the current capture has a name, preserve the name
                    if (capName) {
                        return '(?&lt;' + capName + '&gt;';
                    }
                // Backreference
                } else if (backref) {
                    localCapIndex = +backref - 1;
                    // Rewrite the backreference
                    return data[subName].names[localCapIndex] ?
                        // Need to preserve the backreference name in case using flag `n`
                        '\\k&lt;' + data[subName].names[localCapIndex] + '&gt;' :
                        '\\' + (+backref + numPriorCaps);
                }
                return match;
            }) + ')';
        }
        // Capturing group
        if ($3) {
            capName = outerCapNames[numOuterCaps];
            outerCapsMap[++numOuterCaps] = ++numCaps;
            // If the current capture has a name, preserve the name
            if (capName) {
                return '(?&lt;' + capName + '&gt;' ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
XRegExp uses Unicode 9.0.0.

### XRegExp.build

Build regular expressions using named subpatterns, for readability and pattern reuse:

```js
var time = XRegExp.<span class="apidocCodeKeywordSpan">build</span>('(?x)^ {{hours}} ({{minutes}}) $', {
    hours: XRegExp.build('{{h12}} : | {{h24}}', {
        h12: /1[0-2]|0?[1-9]/,
        h24: /2[0-3]|[01][0-9]/
    }),
    minutes: /^[0-5][0-9]$/
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.xregexp.cache" id="apidoc.element.xregexp.cache">
        function <span class="apidocSignatureSpan">xregexp.</span>cache
        <span class="apidocSignatureSpan">(pattern, flags)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">cache = function (pattern, flags) {
    if (!regexCache[pattern]) {
        regexCache[pattern] = {};
    }
    return regexCache[pattern][flags] || (
        regexCache[pattern][flags] = XRegExp(pattern, flags)
    );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 *
 * @memberOf XRegExp
 * @param {String} pattern Regex pattern string.
 * @param {String} [flags] Any combination of XRegExp flags.
 * @returns {RegExp} Cached XRegExp object.
 * @example
 *
 * while (match = XRegExp.<span class="apidocCodeKeywordSpan">cache</span>('.', 'gs').exec(str)) {
 *   // The regex is compiled once only
 * }
 */
XRegExp.cache = function(pattern, flags) {
if (!regexCache[pattern]) {
    regexCache[pattern] = {};
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.xregexp.cache.flush" id="apidoc.element.xregexp.cache.flush">
        function <span class="apidocSignatureSpan">xregexp.</span>cache.flush
        <span class="apidocSignatureSpan">(cacheName)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">cache.flush = function (cacheName) {
    if (cacheName === 'patterns') {
        // Flush the pattern cache used by the `XRegExp` constructor
        patternCache = {};
    } else {
        // Flush the regex cache populated by `XRegExp.cache`
        regexCache = {};
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        if (item.alias) {
            unicode[normalize(item.alias)] = item;
        }
    }

    // Reset the pattern cache used by the `XRegExp` constructor, since the same pattern and
    // flags might now produce different results
    XRegExp.<span class="apidocCodeKeywordSpan">cache.flush</span>('patterns');
};

/**
 * @ignore
 *
 * Return a reference to the internal Unicode definition structure for the given Unicode
 * Property if the given name is a legal Unicode Property for use in XRegExp `\p` or `\P` regex
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.xregexp.escape" id="apidoc.element.xregexp.escape">
        function <span class="apidocSignatureSpan">xregexp.</span>escape
        <span class="apidocSignatureSpan">(str)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">escape = function (str) {
    return nativ.replace.call(toObject(str), /[-\[\]{}()*+?.,\\^$|#\s]/g, '\\$&amp;');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
left = XRegExp(left, basicFlags);
right = XRegExp(right, basicFlags);

if (escapeChar) {
    if (escapeChar.length &gt; 1) {
        throw new Error('Cannot use more than one escape character');
    }
    escapeChar = XRegExp.<span class="apidocCodeKeywordSpan">escape</span>(escapeChar);
    // Example of concatenated `esc` regex:
    // `escapeChar`: '%'
    // `left`: '&lt;'
    // `right`: '&gt;'
    // Regex is: /(?:%[\S\s]|(?:(?!&lt;|&gt;)[^%])+)+/
    esc = new RegExp(
        '(?:' + escapeChar + '[\\S\\s]|(?:(?!' +
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.xregexp.exec" id="apidoc.element.xregexp.exec">
        function <span class="apidocSignatureSpan">xregexp.</span>exec
        <span class="apidocSignatureSpan">(str, regex, pos, sticky)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">exec = function (str, regex, pos, sticky) {
    var cacheKey = 'g';
    var addY = false;
    var fakeY = false;
    var match;
    var r2;

    addY = hasNativeY &amp;&amp; !!(sticky || (regex.sticky &amp;&amp; sticky !== false));
    if (addY) {
        cacheKey += 'y';
    } else if (sticky) {
        // Simulate sticky matching by appending an empty capture to the original regex. The
        // resulting regex will succeed no matter what at the current index (set with `lastIndex`),
        // and will not search the rest of the subject string. We'll know that the original regex
        // has failed if that last capture is `''` rather than `undefined` (i.e., if that last
        // capture participated in the match).
        fakeY = true;
        cacheKey += 'FakeY';
    }

    regex[REGEX_DATA] = regex[REGEX_DATA] || {};

    // Shares cached copies with `XRegExp.match`/`replace`
    r2 = regex[REGEX_DATA][cacheKey] || (
        regex[REGEX_DATA][cacheKey] = copyRegex(regex, {
            addG: true,
            addY: addY,
            source: fakeY ? regex.source + '|()' : undefined,
            removeY: sticky === false,
            isInternalOnly: true
        })
    );

    pos = pos || 0;
    r2.lastIndex = pos;

    // Fixed `exec` required for `lastIndex` fix, named backreferences, etc.
    match = fixed.exec.call(r2, str);

    // Get rid of the capture added by the pseudo-sticky matcher if needed. An empty string means
    // the original regexp failed (see above).
    if (fakeY &amp;&amp; match &amp;&amp; match.pop() === '') {
        match = null;
    }

    if (regex.global) {
        regex.lastIndex = match ? r2.lastIndex : 0;
    }

    return match;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
```js
// Using named capture and flag x (free-spacing and line comments)
var date = XRegExp(`(?&lt;year&gt;  [0-9]{4} ) -?  # year
                (?&lt;month&gt; [0-9]{2} ) -?  # month
                (?&lt;day&gt;   [0-9]{2} )     # day`, 'x');

// XRegExp.exec gives you named backreferences on the match result
var match = XRegExp.<span class="apidocCodeKeywordSpan">exec</span>('2017-02-22', date);
match.year; // -&gt; '2017'

// It also includes optional pos and sticky arguments
var pos = 3;
var result = [];
while (match = XRegExp.exec('&lt;1&gt;&lt;2&gt;&lt;3&gt;&lt;4&gt;5&lt;6&gt;', /&lt;(\d+)&gt;/,
pos, 'sticky')) {
result.push(match[1]);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.xregexp.forEach" id="apidoc.element.xregexp.forEach">
        function <span class="apidocSignatureSpan">xregexp.</span>forEach
        <span class="apidocSignatureSpan">(str, regex, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">forEach = function (str, regex, callback) {
    var pos = 0;
    var i = -1;
    var match;

    while ((match = XRegExp.exec(str, regex, pos))) {
        // Because `regex` is provided to `callback`, the function could use the deprecated/
        // nonstandard `RegExp.prototype.compile` to mutate the regex. However, since `XRegExp.exec`
        // doesn't use `lastIndex` to set the search position, this can't lead to an infinite loop,
        // at least. Actually, because of the way `XRegExp.exec` caches globalized versions of
        // regexes, mutating the regex will not have any effect on the iteration or matched strings,
        // which is a nice side effect that brings extra safety.
        callback(match, ++i, str, regex);

        pos = match.index + (match[0].length || 1);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// The only caveat is that named captures must be referenced using numbered
// backreferences if used with native methods
'2017-02-22'.replace(date, '$2/$3/$1');
// -&gt; '02/22/2017'

// Use XRegExp.forEach to extract every other digit from a string
var evens = [];
XRegExp.<span class="apidocCodeKeywordSpan">forEach</span>('1a2345', /\d/, (match, i) =&gt; {
if (i % 2) evens.push(+match[0]);
});
// evens -&gt; [2, 4]

// Use XRegExp.matchChain to get numbers within &lt;b&gt; tags
XRegExp.matchChain('1 &lt;b&gt;2&lt;/b&gt; 3 &lt;B&gt;4 \n 56&lt;/B&gt;', [
XRegExp('(?is)&lt;b&gt;.*?&lt;/b&gt;'),
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.xregexp.globalize" id="apidoc.element.xregexp.globalize">
        function <span class="apidocSignatureSpan">xregexp.</span>globalize
        <span class="apidocSignatureSpan">(regex)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">globalize = function (regex) {
    return copyRegex(regex, {addG: true});
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * regexes are not recompiled using XRegExp syntax.
 *
 * @memberOf XRegExp
 * @param {RegExp} regex Regex to globalize.
 * @returns {RegExp} Copy of the provided regex with flag `g` added.
 * @example
 *
 * var globalCopy = XRegExp.<span class="apidocCodeKeywordSpan">globalize</span>(/regex/);
 * globalCopy.global; // -&gt; true
 */
XRegExp.globalize = function(regex) {
    return copyRegex(regex, {addG: true});
};

/**
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.xregexp.install" id="apidoc.element.xregexp.install">
        function <span class="apidocSignatureSpan">xregexp.</span>install
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">install = function (options) {
    options = prepareOptions(options);

    if (!features.astral &amp;&amp; options.astral) {
        setAstral(true);
    }

    if (!features.natives &amp;&amp; options.natives) {
        setNatives(true);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
unicodeWord.test('Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©'); // -&gt; true

// Test some Unicode scripts
XRegExp('^\\p{Hiragana}+$').test('ã²ã‚‰ãŒãª'); // -&gt; true
XRegExp('^[\\p{Latin}\\p{Common}]+$').test('Ãœber CafÃ©.'); // -&gt; true
```

By default, `\p{â€¦}` and `\P{â€¦}` support the Basic Multilingual Plane (i.e. code points up to `U+FFFF`). You can opt-in to full 21
-bit Unicode support (with code points up to `U+10FFFF`) on a per-regex basis by using flag `A`. This is called *astral mode*. You
 can automatically add flag `A` for all new regexes by running `XRegExp.<span class="apidocCodeKeywordSpan">install</span>('
;astral')`. When in astral mode, `\p{â€¦}` and `\P{â€¦}` always match a full code point rather than a code unit, using surrogate pairs for code points above `U+FFFF`.

```js
// Using flag A to match astral code points
XRegExp('^\\pS$').test('ðŸ’©'); // -&gt; false
XRegExp('^\\pS$', 'A').test('ðŸ’©'); // -&gt; true
XRegExp('(?A)^\\pS$').test('ðŸ’©'); // -&gt; true
// Using surrogate pair U+D83D U+DCA9 to represent U+1F4A9 (pile of poo)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.xregexp.isInstalled" id="apidoc.element.xregexp.isInstalled">
        function <span class="apidocSignatureSpan">xregexp.</span>isInstalled
        <span class="apidocSignatureSpan">(feature)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isInstalled = function (feature) {
    return !!(features[feature]);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    return copyRegex(pattern);
}

// Copy the argument behavior of `RegExp`
pattern = pattern === undefined ? '' : String(pattern);
flags = flags === undefined ? '' : String(flags);

if (XRegExp.<span class="apidocCodeKeywordSpan">isInstalled</span>('astral') &amp;&amp; flags.indexOf('A') === -
1) {
    // This causes an error to be thrown if the Unicode Base addon is not available
    flags += 'A';
}

if (!patternCache[pattern]) {
    patternCache[pattern] = {};
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.xregexp.isRegExp" id="apidoc.element.xregexp.isRegExp">
        function <span class="apidocSignatureSpan">xregexp.</span>isRegExp
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isRegExp = function (value) {
    return toString.call(value) === '[object RegExp]';
    //return isType(value, 'RegExp');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @param {String|RegExp} value Value to convert.
 * @param {Boolean} [addFlagX] Whether to apply the `x` flag in cases when `value` is not
 *   already a regex generated by XRegExp
 * @returns {RegExp} XRegExp object with XRegExp syntax applied.
 */
function asXRegExp(value, addFlagX) {
    var flags = addFlagX ? 'x' : '';
    return XRegExp.<span class="apidocCodeKeywordSpan">isRegExp</span>(value) ?
        (value[REGEX_DATA] &amp;&amp; value[REGEX_DATA].captureNames ?
            // Don't recompile, to preserve capture names
            value :
            // Recompile as XRegExp
            XRegExp(value.source, flags)
        ) :
        // Compile string as XRegExp
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.xregexp.match" id="apidoc.element.xregexp.match">
        function <span class="apidocSignatureSpan">xregexp.</span>match
        <span class="apidocSignatureSpan">(str, regex, scope)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">match = function (str, regex, scope) {
    var global = (regex.global &amp;&amp; scope !== 'one') || scope === 'all';
    var cacheKey = ((global ? 'g' : '') + (regex.sticky ? 'y' : '')) || 'noGY';
    var result;
    var r2;

    regex[REGEX_DATA] = regex[REGEX_DATA] || {};

    // Shares cached copies with `XRegExp.exec`/`replace`
    r2 = regex[REGEX_DATA][cacheKey] || (
        regex[REGEX_DATA][cacheKey] = copyRegex(regex, {
            addG: !!global,
            removeG: scope === 'one',
            isInternalOnly: true
        })
    );

    result = nativ.match.call(toObject(str), r2);

    if (regex.global) {
        regex.lastIndex = (
            (scope === 'one' &amp;&amp; result) ?
                // Can't use `r2.lastIndex` since `r2` is nonglobal in this case
                (result.index + result[0].length) : 0
        );
    }

    return global ? (result || []) : (result &amp;&amp; result[0]);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
*   return an array of all matched strings. If not explicitly specified and `regex` uses flag g,
*   `scope` is 'all'.
* @returns {String|Array} In match-first mode: First match as a string, or `null`. In match-all
*   mode: Array of all matched strings, or an empty array.
* @example
*
* // Match first
* XRegExp.<span class="apidocCodeKeywordSpan">match</span>('abc', /\w/); // -&gt; 'a'
* XRegExp.match('abc', /\w/g, 'one'); // -&gt; 'a'
* XRegExp.match('abc', /x/g, 'one'); // -&gt; null
*
* // Match all
* XRegExp.match('abc', /\w/g); // -&gt; ['a', 'b', 'c']
* XRegExp.match('abc', /\w/, 'all'); // -&gt; ['a', 'b', 'c']
* XRegExp.match('abc', /x/, 'all'); // -&gt; []
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.xregexp.matchChain" id="apidoc.element.xregexp.matchChain">
        function <span class="apidocSignatureSpan">xregexp.</span>matchChain
        <span class="apidocSignatureSpan">(str, chain)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">matchChain = function (str, chain) {
    return (function recurseChain(values, level) {
        var item = chain[level].regex ? chain[level] : {regex: chain[level]};
        var matches = [];

        function addMatch(match) {
            if (item.backref) {
                // Safari 4.0.5 (but not 5.0.5+) inappropriately uses sparse arrays to hold the
                // `undefined`s for backreferences to nonparticipating capturing groups. In such
                // cases, a `hasOwnProperty` or `in` check on its own would inappropriately throw
                // the exception, so also check if the backreference is a number that is within the
                // bounds of the array.
                if (!(match.hasOwnProperty(item.backref) || +item.backref &lt; match.length)) {
                    throw new ReferenceError('Backreference to undefined group: ' + item.backref);
                }

                matches.push(match[item.backref] || '');
            } else {
                matches.push(match[0]);
            }
        }

        for (var i = 0; i &lt; values.length; ++i) {
            XRegExp.forEach(values[i], item.regex, addMatch);
        }

        return ((level === chain.length - 1) || !matches.length) ?
            matches :
            recurseChain(matches, level + 1);
    }([str], 0));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var evens = [];
XRegExp.forEach('1a2345', /\d/, (match, i) =&gt; {
    if (i % 2) evens.push(+match[0]);
});
// evens -&gt; [2, 4]

// Use XRegExp.matchChain to get numbers within &lt;b&gt; tags
XRegExp.<span class="apidocCodeKeywordSpan">matchChain</span>('1 &lt;b&gt;2&lt;/b&gt; 3 &lt;B&gt;4 \n 56&lt;/
B&gt;', [
    XRegExp('(?is)&lt;b&gt;.*?&lt;/b&gt;'),
    /\d+/
]);
// -&gt; ['2', '4', '56']

// You can also pass forward and return specific backreferences
var html = '&lt;a href="http://xregexp.com/"&gt;XRegExp&lt;/a&gt;' +
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.xregexp.matchRecursive" id="apidoc.element.xregexp.matchRecursive">
        function <span class="apidocSignatureSpan">xregexp.</span>matchRecursive
        <span class="apidocSignatureSpan">(str, left, right, flags, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">matchRecursive = function (str, left, right, flags, options) {
    flags = flags || '';
    options = options || {};
    var global = flags.indexOf('g') &gt; -1;
    var sticky = flags.indexOf('y') &gt; -1;
    // Flag `y` is controlled internally
    var basicFlags = flags.replace(/y/g, '');
    var escapeChar = options.escapeChar;
    var vN = options.valueNames;
    var output = [];
    var openTokens = 0;
    var delimStart = 0;
    var delimEnd = 0;
    var lastOuterEnd = 0;
    var outerStart;
    var innerStart;
    var leftMatch;
    var rightMatch;
    var esc;
    left = XRegExp(left, basicFlags);
    right = XRegExp(right, basicFlags);

    if (escapeChar) {
        if (escapeChar.length &gt; 1) {
            throw new Error('Cannot use more than one escape character');
        }
        escapeChar = XRegExp.escape(escapeChar);
        // Example of concatenated `esc` regex:
        // `escapeChar`: '%'
        // `left`: '&lt;'
        // `right`: '&gt;'
        // Regex is: /(?:%[\S\s]|(?:(?!&lt;|&gt;)[^%])+)+/
        esc = new RegExp(
            '(?:' + escapeChar + '[\\S\\s]|(?:(?!' +
                // Using `XRegExp.union` safely rewrites backreferences in `left` and `right`.
                // Intentionally not passing `basicFlags` to `XRegExp.union` since any syntax
                // transformation resulting from those flags was already applied to `left` and
                // `right` when they were passed through the XRegExp constructor above.
                XRegExp.union([left, right], '', {conjunction: 'or'}).source +
                ')[^' + escapeChar + '])+)+',
            // Flags `gy` not needed here
            flags.replace(/[^imu]+/g, '')
        );
    }

    while (true) {
        // If using an escape character, advance to the delimiter's next starting position,
        // skipping any escaped characters in between
        if (escapeChar) {
            delimEnd += (XRegExp.exec(str, esc, delimEnd, 'sticky') || [''])[0].length;
        }
        leftMatch = XRegExp.exec(str, left, delimEnd);
        rightMatch = XRegExp.exec(str, right, delimEnd);
        // Keep the leftmost match only
        if (leftMatch &amp;&amp; rightMatch) {
            if (leftMatch.index &lt;= rightMatch.index) {
                rightMatch = null;
            } else {
                leftMatch = null;
            }
        }
        // Paths (LM: leftMatch, RM: rightMatch, OT: openTokens):
        // LM | RM | OT | Result
        // 1  | 0  | 1  | loop
        // 1  | 0  | 0  | loop
        // 0  | 1  | 1  | loop
        // 0  | 1  | 0  | throw
        // 0  | 0  | 1  | throw
        // 0  | 0  | 0  | break
        // The paths above don't include the sticky mode special case. The loop ends after the
        // first completed match if not `global`.
        if (leftMatch || rightMatch) {
            delimStart = (leftMatch || rightMatch).index;
            delimEnd = delimStart + (leftMatch || rightMatch)[0].length;
        } else if (!openTokens) {
            break;
        }
        if (sticky &amp;&amp; !openTokens &amp;&amp; delimStart &gt; lastOuterEnd) {
            break;
        }
        if (leftMatch) {
            if (!openTokens) {
                outerStart = delimStart;
                innerStart = delimEnd;
            }
            ++openTokens;
        } else if (rightMatch &amp;&amp; openTokens) {
            if (!--openTokens) {
                if (vN) {
                    if (vN[0] &amp;&amp; outerStart &gt; lastOuterEnd) {
                        output.push(row(vN[0], str.slice(lastOuterEnd, outerStart), lastOuterEnd, outerStart));
                    }
                    if (vN[1]) {
                        output.push(row(vN[1], str.slice(outerStart, innerStart), outerStart, innerStart));
                    }
                    if (vN[2]) {
                        output.push(row(vN[2], str.slice(innerStart, delimStart), innerStart, delimStart));
                    }
                    if (vN[3]) {
                        output.push(row(vN[3], str.slice(delimStart, d ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...

### XRegExp.matchRecursive

Match recursive constructs using XRegExp pattern strings as left and right delimiters:

```js
var str = '(t((e))s)t()(ing)';
XRegExp.<span class="apidocCodeKeywordSpan">matchRecursive</span>(str, '\\(', '\\)', 'g');
// -&gt; ['t((e))s', '', 'ing']

// Extended information mode with valueNames
str = 'Here is &lt;div&gt; &lt;div&gt;an&lt;/div&gt;&lt;/div&gt; example';
XRegExp.matchRecursive(str, '&lt;div\\s*&gt;', '&lt;/div&gt;', 'gi', {
    valueNames: ['between', 'left', 'match', 'right']
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.xregexp.replace" id="apidoc.element.xregexp.replace">
        function <span class="apidocSignatureSpan">xregexp.</span>replace
        <span class="apidocSignatureSpan">(str, search, replacement, scope)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">replace = function (str, search, replacement, scope) {
    var isRegex = XRegExp.isRegExp(search);
    var global = (search.global &amp;&amp; scope !== 'one') || scope === 'all';
    var cacheKey = ((global ? 'g' : '') + (search.sticky ? 'y' : '')) || 'noGY';
    var s2 = search;
    var result;

    if (isRegex) {
        search[REGEX_DATA] = search[REGEX_DATA] || {};

        // Shares cached copies with `XRegExp.exec`/`match`. Since a copy is used, `search`'s
        // `lastIndex` isn't updated *during* replacement iterations
        s2 = search[REGEX_DATA][cacheKey] || (
            search[REGEX_DATA][cacheKey] = copyRegex(search, {
                addG: !!global,
                removeG: scope === 'one',
                isInternalOnly: true
            })
        );
    } else if (global) {
        s2 = new RegExp(XRegExp.escape(String(search)), 'g');
    }

    // Fixed `replace` required for named backreferences, etc.
    result = fixed.replace.call(toObject(str), s2, replacement);

    if (isRegex &amp;&amp; search.global) {
        // Fixes IE, Safari bug (last tested IE 9, Safari 5.1)
        search.lastIndex = 0;
    }

    return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
while (match = XRegExp.exec('&lt;1&gt;&lt;2&gt;&lt;3&gt;&lt;4&gt;5&lt;6&gt;', /&lt;(\d+)&gt;/,
pos, 'sticky')) {
    result.push(match[1]);
    pos = match.index + match[0].length;
}
// result -&gt; ['2', '3', '4']

// XRegExp.replace allows named backreferences in replacements
XRegExp.<span class="apidocCodeKeywordSpan">replace</span>('2017-02-22', date, '${month}/${day}/${year}');
// -&gt; '02/22/2017'
XRegExp.replace('2017-02-22', date, (match) =&gt; {
    return match.month + '/' + match.day + '/' + match.year;
});
// -&gt; '02/22/2017'

// XRegExps compile to RegExps and work perfectly with native methods
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.xregexp.replaceEach" id="apidoc.element.xregexp.replaceEach">
        function <span class="apidocSignatureSpan">xregexp.</span>replaceEach
        <span class="apidocSignatureSpan">(str, replacements)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">replaceEach = function (str, replacements) {
    var i;
    var r;

    for (i = 0; i &lt; replacements.length; ++i) {
        r = replacements[i];
        str = XRegExp.replace(str, r[0], r[1], r[2]);
    }

    return str;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
*
* @memberOf XRegExp
* @param {String} str String to search.
* @param {Array} replacements Array of replacement detail arrays.
* @returns {String} New string with all replacements.
* @example
*
* str = XRegExp.<span class="apidocCodeKeywordSpan">replaceEach</span>(str, [
*   [XRegExp('(?&lt;name&gt;a)'), 'z${name}'],
*   [/b/gi, 'y'],
*   [/c/g, 'x', 'one'], // scope 'one' overrides /g
*   [/d/, 'w', 'all'],  // scope 'all' overrides lack of /g
*   ['e', 'v', 'all'],  // scope 'all' allows replace-all for strings
*   [/f/g, function($0) {
*     return $0.toUpperCase();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.xregexp.split" id="apidoc.element.xregexp.split">
        function <span class="apidocSignatureSpan">xregexp.</span>split
        <span class="apidocSignatureSpan">(str, separator, limit)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">split = function (str, separator, limit) {
    return fixed.split.call(toObject(str), separator, limit);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
           // extensions exist on `regex.prototype` anyway
           regex[p] = XRegExp.prototype[p];
       }
   }

   regex[REGEX_DATA].source = xSource;
   // Emulate the ES6 `flags` prop by ensuring flags are in alphabetical order
   regex[REGEX_DATA].flags = xFlags ? xFlags.<span class="apidocCodeKeywordSpan">split</span>('').sort().join('&amp;#
x27;) : xFlags;

   return regex;
}

/**
* Removes any duplicate characters from the provided string.
*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.xregexp.test" id="apidoc.element.xregexp.test">
        function <span class="apidocSignatureSpan">xregexp.</span>test
        <span class="apidocSignatureSpan">(str, regex, pos, sticky)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">test = function (str, regex, pos, sticky) {
    // Do this the easy way :-)
    return !!XRegExp.exec(str, regex, pos, sticky);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// -&gt; '02/22/2017'
XRegExp.replace('2017-02-22', date, (match) =&gt; {
    return match.month + '/' + match.day + '/' + match.year;
});
// -&gt; '02/22/2017'

// XRegExps compile to RegExps and work perfectly with native methods
date.<span class="apidocCodeKeywordSpan">test</span>('2017-02-22');
// -&gt; true

// The only caveat is that named captures must be referenced using numbered
// backreferences if used with native methods
'2017-02-22'.replace(date, '$2/$3/$1');
// -&gt; '02/22/2017'
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.xregexp.toString" id="apidoc.element.xregexp.toString">
        function <span class="apidocSignatureSpan">xregexp.</span>toString
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toString = function () {
    return text;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Converts decimal to hexadecimal.
*
* @private
* @param {Number|String} dec
* @returns {String}
*/
function hex(dec) {
   return parseInt(dec, 10).<span class="apidocCodeKeywordSpan">toString</span>(16);
}

/**
* Returns the first index at which a given value can be found in an array.
*
* @private
* @param {Array} array Array to search.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.xregexp.uninstall" id="apidoc.element.xregexp.uninstall">
        function <span class="apidocSignatureSpan">xregexp.</span>uninstall
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">uninstall = function (options) {
    options = prepareOptions(options);

    if (features.astral &amp;&amp; options.astral) {
        setAstral(false);
    }

    if (features.natives &amp;&amp; options.natives) {
        setNatives(false);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* uninstalled, so this is used to undo the actions of `XRegExp.install`.
*
* @memberOf XRegExp
* @param {Object|String} options Options object or string.
* @example
*
* // With an options object
* XRegExp.<span class="apidocCodeKeywordSpan">uninstall</span>({
*   // Disables support for astral code points in Unicode addons
*   astral: true,
*
*   // DEPRECATED: Restores native regex methods
*   natives: true
* });
*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.xregexp.union" id="apidoc.element.xregexp.union">
        function <span class="apidocSignatureSpan">xregexp.</span>union
        <span class="apidocSignatureSpan">(patterns, flags, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">union = function (patterns, flags, options) {
    options = options || {};
    var conjunction = options.conjunction || 'or';
    var numCaptures = 0;
    var numPriorCaptures;
    var captureNames;

    function rewrite(match, paren, backref) {
        var name = captureNames[numCaptures - numPriorCaptures];

        // Capturing group
        if (paren) {
            ++numCaptures;
            // If the current capture has a name, preserve the name
            if (name) {
                return '(?&lt;' + name + '&gt;';
            }
        // Backreference
        } else if (backref) {
            // Rewrite the backreference
            return '\\' + (+backref + numPriorCaptures);
        }

        return match;
    }

    if (!(isType(patterns, 'Array') &amp;&amp; patterns.length)) {
        throw new TypeError('Must provide a nonempty array of patterns to merge');
    }

    var parts = /(\()(?!\?)|\\([1-9]\d*)|\\[\s\S]|\[(?:[^\\\]]|\\[\s\S])*\]/g;
    var output = [];
    var pattern;
    for (var i = 0; i &lt; patterns.length; ++i) {
        pattern = patterns[i];

        if (XRegExp.isRegExp(pattern)) {
            numPriorCaptures = numCaptures;
            captureNames = (pattern[REGEX_DATA] &amp;&amp; pattern[REGEX_DATA].captureNames) || [];

            // Rewrite backreferences. Passing to XRegExp dies on octals and ensures patterns are
            // independently valid; helps keep this simple. Named captures are put back
            output.push(nativ.replace.call(XRegExp(pattern.source).source, parts, rewrite));
        } else {
            output.push(XRegExp.escape(pattern));
        }
    }

    var separator = conjunction === 'none' ? '' : '|';
    return XRegExp(output.join(separator), flags);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
XRegExp.matchChain(html, [
    {regex: /&lt;a href="([^"]+)"&gt;/i, backref: 1},
    {regex: XRegExp('(?i)^https?://(?&lt;domain&gt;[^/?#]+)'), backref: 'domain'}
]);
// -&gt; ['xregexp.com', 'www.google.com']

// Merge strings and regexes into a single pattern with updated backreferences
XRegExp.<span class="apidocCodeKeywordSpan">union</span>(['a+b*c', /(dog)\1/, /(cat)\1/], 'i', {conjunction: &amp;#
x27;or'});
// -&gt; /a\+b\*c|(dog)\1|(cat)\2/i
```

These examples give the flavor of what's possible, but XRegExp has more syntax, flags, methods, options, and browser fixes
that aren't shown here. You can also augment XRegExp's regular expression syntax with addons (see below) or write your
 own. See [xregexp.com](http://xregexp.com/) for details.

## Addons
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.xregexp._clipDuplicates" id="apidoc.module.xregexp._clipDuplicates">module xregexp._clipDuplicates</a></h1>


    <h2>
        <a href="#apidoc.element.xregexp._clipDuplicates._clipDuplicates" id="apidoc.element.xregexp._clipDuplicates._clipDuplicates">
        function <span class="apidocSignatureSpan">xregexp.</span>_clipDuplicates
        <span class="apidocSignatureSpan">(str)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function clipDuplicates(str) {
    return nativ.replace.call(str, /([\s\S])(?=[\s\S]*\1)/g, '');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// Used with `asXRegExp` calls for `pattern` and subpatterns in `subs`, to work around how
// some browsers convert `RegExp('\n')` to a regex that contains the literal characters `\`
// and `n`. See more details at &lt;https://github.com/slevithan/xregexp/pull/163&gt;.
var addFlagX = flags.indexOf('x') &gt; -1;
var inlineFlags = /^\(\?([\w$]+)\)/.exec(pattern);
// Add flags within a leading mode modifier to the overall pattern's flags
if (inlineFlags) {
    flags = XRegExp.<span class="apidocCodeKeywordSpan">_clipDuplicates</span>(flags + inlineFlags[1]);
}

var data = {};
for (var p in subs) {
    if (subs.hasOwnProperty(p)) {
        // Passing to XRegExp enables extended syntax and ensures independent validity,
        // lest an unescaped `(`, `)`, `[`, or trailing `\` breaks the `(?:)` wrapper. For
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.xregexp._dec" id="apidoc.module.xregexp._dec">module xregexp._dec</a></h1>


    <h2>
        <a href="#apidoc.element.xregexp._dec._dec" id="apidoc.element.xregexp._dec._dec">
        function <span class="apidocSignatureSpan">xregexp.</span>_dec
        <span class="apidocSignatureSpan">(hex)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function dec(hex) {
    return parseInt(hex, 16);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.xregexp._getUnicodeProperty" id="apidoc.module.xregexp._getUnicodeProperty">module xregexp._getUnicodeProperty</a></h1>


    <h2>
        <a href="#apidoc.element.xregexp._getUnicodeProperty._getUnicodeProperty" id="apidoc.element.xregexp._getUnicodeProperty._getUnicodeProperty">
        function <span class="apidocSignatureSpan">xregexp.</span>_getUnicodeProperty
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_getUnicodeProperty = function (name) {
    var slug = normalize(name);
    return unicode[slug];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.xregexp._hasNativeFlag" id="apidoc.module.xregexp._hasNativeFlag">module xregexp._hasNativeFlag</a></h1>


    <h2>
        <a href="#apidoc.element.xregexp._hasNativeFlag._hasNativeFlag" id="apidoc.element.xregexp._hasNativeFlag._hasNativeFlag">
        function <span class="apidocSignatureSpan">xregexp.</span>_hasNativeFlag
        <span class="apidocSignatureSpan">(flag)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function hasNativeFlag(flag) {
    // Can't check based on the presence of properties/getters since browsers might support such
    // properties even when they don't support the corresponding flag in regex construction (tested
    // in Chrome 48, where `'unicode' in /x/` is true but trying to construct a regex with flag `u`
    // throws an error)
    var isSupported = true;
    try {
        // Can't use regex literals for testing even in a `try` because regex literals with
        // unsupported flags cause a compilation error in IE
        new RegExp('', flag);
    } catch (exception) {
        isSupported = false;
    }
    return isSupported;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.xregexp._hex" id="apidoc.module.xregexp._hex">module xregexp._hex</a></h1>


    <h2>
        <a href="#apidoc.element.xregexp._hex._hex" id="apidoc.element.xregexp._hex._hex">
        function <span class="apidocSignatureSpan">xregexp.</span>_hex
        <span class="apidocSignatureSpan">(dec)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function hex(dec) {
    return parseInt(dec, 10).toString(16);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.xregexp._pad4" id="apidoc.module.xregexp._pad4">module xregexp._pad4</a></h1>


    <h2>
        <a href="#apidoc.element.xregexp._pad4._pad4" id="apidoc.element.xregexp._pad4._pad4">
        function <span class="apidocSignatureSpan">xregexp.</span>_pad4
        <span class="apidocSignatureSpan">(str)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function pad4(str) {
    while (str.length &lt; 4) {
        str = '0' + str;
    }
    return str;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.xregexp.addToken" id="apidoc.module.xregexp.addToken">module xregexp.addToken</a></h1>


    <h2>
        <a href="#apidoc.element.xregexp.addToken.addToken" id="apidoc.element.xregexp.addToken.addToken">
        function <span class="apidocSignatureSpan">xregexp.</span>addToken
        <span class="apidocSignatureSpan">(regex, handler, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">addToken = function (regex, handler, options) {
    options = options || {};
    var optionalFlags = options.optionalFlags;
    var i;

    if (options.flag) {
        registerFlag(options.flag);
    }

    if (optionalFlags) {
        optionalFlags = nativ.split.call(optionalFlags, '');
        for (i = 0; i &lt; optionalFlags.length; ++i) {
            registerFlag(optionalFlags[i]);
        }
    }

    // Add to the private list of syntax tokens
    tokens.push({
        regex: copyRegex(regex, {
            addG: true,
            addY: hasNativeY,
            isInternalOnly: true
        }),
        handler: handler,
        scope: options.scope || defaultScope,
        flag: options.flag,
        reparse: options.reparse,
        leadChar: options.leadChar
    });

    // Reset the pattern cache used by the `XRegExp` constructor, since the same pattern and flags
    // might now produce different results
    XRegExp.cache.flush('patterns');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// ==--------------------------==
// Core functionality
// ==--------------------------==

/*
 * Add astral mode (flag A) and Unicode token syntax: `\p{..}`, `\P{..}`, `\p{^..}`, `\pC`.
 */
XRegExp.<span class="apidocCodeKeywordSpan">addToken</span>(
    // Use `*` instead of `+` to avoid capturing `^` as the token name in `\p{^}`
    /\\([pP])(?:{(\^?)([^}]*)}|([A-Za-z]))/,
    function(match, scope, flags) {
        var ERR_DOUBLE_NEG = 'Invalid double negation ';
        var ERR_UNKNOWN_NAME = 'Unknown Unicode token ';
        var ERR_UNKNOWN_REF = 'Unicode token missing data ';
        var ERR_ASTRAL_ONLY = 'Astral mode required for Unicode token ';
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.xregexp.addUnicodeData" id="apidoc.module.xregexp.addUnicodeData">module xregexp.addUnicodeData</a></h1>


    <h2>
        <a href="#apidoc.element.xregexp.addUnicodeData.addUnicodeData" id="apidoc.element.xregexp.addUnicodeData.addUnicodeData">
        function <span class="apidocSignatureSpan">xregexp.</span>addUnicodeData
        <span class="apidocSignatureSpan">(data)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">addUnicodeData = function (data) {
    var ERR_NO_NAME = 'Unicode token requires name';
    var ERR_NO_DATA = 'Unicode token has no character data ';
    var item;

    for (var i = 0; i &lt; data.length; ++i) {
        item = data[i];
        if (!item.name) {
            throw new Error(ERR_NO_NAME);
        }
        if (!(item.inverseOf || item.bmp || item.astral)) {
            throw new Error(ERR_NO_DATA + item.name);
        }
        unicode[normalize(item.name)] = item;
        if (item.alias) {
            unicode[normalize(item.alias)] = item;
        }
    }

    // Reset the pattern cache used by the `XRegExp` constructor, since the same pattern and
    // flags might now produce different results
    XRegExp.cache.flush('patterns');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 *   escaped, apart from range-creating hyphens. The `astral` data can additionally use
 *   character classes and alternation, and should use surrogate pairs to represent astral code
 *   points. `inverseOf` can be used to avoid duplicating character data if a Unicode token is
 *   defined as the exact inverse of another token.
 * @example
 *
 * // Basic use
 * XRegExp.<span class="apidocCodeKeywordSpan">addUnicodeData</span>([{
 *   name: 'XDigit',
 *   alias: 'Hexadecimal',
 *   bmp: '0-9A-Fa-f'
 * }]);
 * XRegExp('\\p{XDigit}:\\p{Hexadecimal}+').test('0:3D'); // -&gt; true
 */
XRegExp.addUnicodeData = function(data) {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.xregexp.build" id="apidoc.module.xregexp.build">module xregexp.build</a></h1>


    <h2>
        <a href="#apidoc.element.xregexp.build.build" id="apidoc.element.xregexp.build.build">
        function <span class="apidocSignatureSpan">xregexp.</span>build
        <span class="apidocSignatureSpan">(pattern, subs, flags)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">build = function (pattern, subs, flags) {
    flags = flags || '';
    // Used with `asXRegExp` calls for `pattern` and subpatterns in `subs`, to work around how
    // some browsers convert `RegExp('\n')` to a regex that contains the literal characters `\`
    // and `n`. See more details at &lt;https://github.com/slevithan/xregexp/pull/163&gt;.
    var addFlagX = flags.indexOf('x') &gt; -1;
    var inlineFlags = /^\(\?([\w$]+)\)/.exec(pattern);
    // Add flags within a leading mode modifier to the overall pattern's flags
    if (inlineFlags) {
        flags = XRegExp._clipDuplicates(flags + inlineFlags[1]);
    }

    var data = {};
    for (var p in subs) {
        if (subs.hasOwnProperty(p)) {
            // Passing to XRegExp enables extended syntax and ensures independent validity,
            // lest an unescaped `(`, `)`, `[`, or trailing `\` breaks the `(?:)` wrapper. For
            // subpatterns provided as native regexes, it dies on octals and adds the property
            // used to hold extended regex instance data, for simplicity.
            var sub = asXRegExp(subs[p], addFlagX);
            data[p] = {
                // Deanchoring allows embedding independently useful anchored regexes. If you
                // really need to keep your anchors, double them (i.e., `^^...$$`).
                pattern: deanchor(sub.source),
                names: sub[REGEX_DATA].captureNames || []
            };
        }
    }

    // Passing to XRegExp dies on octals and ensures the outer pattern is independently valid;
    // helps keep this simple. Named captures will be put back.
    var patternAsRegex = asXRegExp(pattern, addFlagX);

    // 'Caps' is short for 'captures'
    var numCaps = 0;
    var numPriorCaps;
    var numOuterCaps = 0;
    var outerCapsMap = [0];
    var outerCapNames = patternAsRegex[REGEX_DATA].captureNames || [];
    var output = patternAsRegex.source.replace(parts, function($0, $1, $2, $3, $4) {
        var subName = $1 || $2;
        var capName;
        var intro;
        var localCapIndex;
        // Named subpattern
        if (subName) {
            if (!data.hasOwnProperty(subName)) {
                throw new ReferenceError('Undefined property ' + $0);
            }
            // Named subpattern was wrapped in a capturing group
            if ($1) {
                capName = outerCapNames[numOuterCaps];
                outerCapsMap[++numOuterCaps] = ++numCaps;
                // If it's a named group, preserve the name. Otherwise, use the subpattern name
                // as the capture name
                intro = '(?&lt;' + (capName || subName) + '&gt;';
            } else {
                intro = '(?:';
            }
            numPriorCaps = numCaps;
            return intro + data[subName].pattern.replace(subParts, function(match, paren, backref) {
                // Capturing group
                if (paren) {
                    capName = data[subName].names[numCaps - numPriorCaps];
                    ++numCaps;
                    // If the current capture has a name, preserve the name
                    if (capName) {
                        return '(?&lt;' + capName + '&gt;';
                    }
                // Backreference
                } else if (backref) {
                    localCapIndex = +backref - 1;
                    // Rewrite the backreference
                    return data[subName].names[localCapIndex] ?
                        // Need to preserve the backreference name in case using flag `n`
                        '\\k&lt;' + data[subName].names[localCapIndex] + '&gt;' :
                        '\\' + (+backref + numPriorCaps);
                }
                return match;
            }) + ')';
        }
        // Capturing group
        if ($3) {
            capName = outerCapNames[numOuterCaps];
            outerCapsMap[++numOuterCaps] = ++numCaps;
            // If the current capture has a name, preserve the name
            if (capName) {
                return '(?&lt;' + capName + '&gt;' ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
XRegExp uses Unicode 9.0.0.

### XRegExp.build

Build regular expressions using named subpatterns, for readability and pattern reuse:

```js
var time = XRegExp.<span class="apidocCodeKeywordSpan">build</span>('(?x)^ {{hours}} ({{minutes}}) $', {
    hours: XRegExp.build('{{h12}} : | {{h24}}', {
        h12: /1[0-2]|0?[1-9]/,
        h24: /2[0-3]|[01][0-9]/
    }),
    minutes: /^[0-5][0-9]$/
});
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.xregexp.cache" id="apidoc.module.xregexp.cache">module xregexp.cache</a></h1>


    <h2>
        <a href="#apidoc.element.xregexp.cache.cache" id="apidoc.element.xregexp.cache.cache">
        function <span class="apidocSignatureSpan">xregexp.</span>cache
        <span class="apidocSignatureSpan">(pattern, flags)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">cache = function (pattern, flags) {
    if (!regexCache[pattern]) {
        regexCache[pattern] = {};
    }
    return regexCache[pattern][flags] || (
        regexCache[pattern][flags] = XRegExp(pattern, flags)
    );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 *
 * @memberOf XRegExp
 * @param {String} pattern Regex pattern string.
 * @param {String} [flags] Any combination of XRegExp flags.
 * @returns {RegExp} Cached XRegExp object.
 * @example
 *
 * while (match = XRegExp.<span class="apidocCodeKeywordSpan">cache</span>('.', 'gs').exec(str)) {
 *   // The regex is compiled once only
 * }
 */
XRegExp.cache = function(pattern, flags) {
if (!regexCache[pattern]) {
    regexCache[pattern] = {};
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.xregexp.cache.flush" id="apidoc.element.xregexp.cache.flush">
        function <span class="apidocSignatureSpan">xregexp.cache.</span>flush
        <span class="apidocSignatureSpan">(cacheName)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">flush = function (cacheName) {
    if (cacheName === 'patterns') {
        // Flush the pattern cache used by the `XRegExp` constructor
        patternCache = {};
    } else {
        // Flush the regex cache populated by `XRegExp.cache`
        regexCache = {};
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        if (item.alias) {
            unicode[normalize(item.alias)] = item;
        }
    }

    // Reset the pattern cache used by the `XRegExp` constructor, since the same pattern and
    // flags might now produce different results
    XRegExp.cache.<span class="apidocCodeKeywordSpan">flush</span>('patterns');
};

/**
 * @ignore
 *
 * Return a reference to the internal Unicode definition structure for the given Unicode
 * Property if the given name is a legal Unicode Property for use in XRegExp `\p` or `\P` regex
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.xregexp.cache.flush" id="apidoc.module.xregexp.cache.flush">module xregexp.cache.flush</a></h1>


    <h2>
        <a href="#apidoc.element.xregexp.cache.flush.flush" id="apidoc.element.xregexp.cache.flush.flush">
        function <span class="apidocSignatureSpan">xregexp.cache.</span>flush
        <span class="apidocSignatureSpan">(cacheName)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">flush = function (cacheName) {
    if (cacheName === 'patterns') {
        // Flush the pattern cache used by the `XRegExp` constructor
        patternCache = {};
    } else {
        // Flush the regex cache populated by `XRegExp.cache`
        regexCache = {};
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        if (item.alias) {
            unicode[normalize(item.alias)] = item;
        }
    }

    // Reset the pattern cache used by the `XRegExp` constructor, since the same pattern and
    // flags might now produce different results
    XRegExp.cache.<span class="apidocCodeKeywordSpan">flush</span>('patterns');
};

/**
 * @ignore
 *
 * Return a reference to the internal Unicode definition structure for the given Unicode
 * Property if the given name is a legal Unicode Property for use in XRegExp `\p` or `\P` regex
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.xregexp.escape" id="apidoc.module.xregexp.escape">module xregexp.escape</a></h1>


    <h2>
        <a href="#apidoc.element.xregexp.escape.escape" id="apidoc.element.xregexp.escape.escape">
        function <span class="apidocSignatureSpan">xregexp.</span>escape
        <span class="apidocSignatureSpan">(str)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">escape = function (str) {
    return nativ.replace.call(toObject(str), /[-\[\]{}()*+?.,\\^$|#\s]/g, '\\$&amp;');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
left = XRegExp(left, basicFlags);
right = XRegExp(right, basicFlags);

if (escapeChar) {
    if (escapeChar.length &gt; 1) {
        throw new Error('Cannot use more than one escape character');
    }
    escapeChar = XRegExp.<span class="apidocCodeKeywordSpan">escape</span>(escapeChar);
    // Example of concatenated `esc` regex:
    // `escapeChar`: '%'
    // `left`: '&lt;'
    // `right`: '&gt;'
    // Regex is: /(?:%[\S\s]|(?:(?!&lt;|&gt;)[^%])+)+/
    esc = new RegExp(
        '(?:' + escapeChar + '[\\S\\s]|(?:(?!' +
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.xregexp.exec" id="apidoc.module.xregexp.exec">module xregexp.exec</a></h1>


    <h2>
        <a href="#apidoc.element.xregexp.exec.exec" id="apidoc.element.xregexp.exec.exec">
        function <span class="apidocSignatureSpan">xregexp.</span>exec
        <span class="apidocSignatureSpan">(str, regex, pos, sticky)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">exec = function (str, regex, pos, sticky) {
    var cacheKey = 'g';
    var addY = false;
    var fakeY = false;
    var match;
    var r2;

    addY = hasNativeY &amp;&amp; !!(sticky || (regex.sticky &amp;&amp; sticky !== false));
    if (addY) {
        cacheKey += 'y';
    } else if (sticky) {
        // Simulate sticky matching by appending an empty capture to the original regex. The
        // resulting regex will succeed no matter what at the current index (set with `lastIndex`),
        // and will not search the rest of the subject string. We'll know that the original regex
        // has failed if that last capture is `''` rather than `undefined` (i.e., if that last
        // capture participated in the match).
        fakeY = true;
        cacheKey += 'FakeY';
    }

    regex[REGEX_DATA] = regex[REGEX_DATA] || {};

    // Shares cached copies with `XRegExp.match`/`replace`
    r2 = regex[REGEX_DATA][cacheKey] || (
        regex[REGEX_DATA][cacheKey] = copyRegex(regex, {
            addG: true,
            addY: addY,
            source: fakeY ? regex.source + '|()' : undefined,
            removeY: sticky === false,
            isInternalOnly: true
        })
    );

    pos = pos || 0;
    r2.lastIndex = pos;

    // Fixed `exec` required for `lastIndex` fix, named backreferences, etc.
    match = fixed.exec.call(r2, str);

    // Get rid of the capture added by the pseudo-sticky matcher if needed. An empty string means
    // the original regexp failed (see above).
    if (fakeY &amp;&amp; match &amp;&amp; match.pop() === '') {
        match = null;
    }

    if (regex.global) {
        regex.lastIndex = match ? r2.lastIndex : 0;
    }

    return match;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
```js
// Using named capture and flag x (free-spacing and line comments)
var date = XRegExp(`(?&lt;year&gt;  [0-9]{4} ) -?  # year
                (?&lt;month&gt; [0-9]{2} ) -?  # month
                (?&lt;day&gt;   [0-9]{2} )     # day`, 'x');

// XRegExp.exec gives you named backreferences on the match result
var match = XRegExp.<span class="apidocCodeKeywordSpan">exec</span>('2017-02-22', date);
match.year; // -&gt; '2017'

// It also includes optional pos and sticky arguments
var pos = 3;
var result = [];
while (match = XRegExp.exec('&lt;1&gt;&lt;2&gt;&lt;3&gt;&lt;4&gt;5&lt;6&gt;', /&lt;(\d+)&gt;/,
pos, 'sticky')) {
result.push(match[1]);
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.xregexp.forEach" id="apidoc.module.xregexp.forEach">module xregexp.forEach</a></h1>


    <h2>
        <a href="#apidoc.element.xregexp.forEach.forEach" id="apidoc.element.xregexp.forEach.forEach">
        function <span class="apidocSignatureSpan">xregexp.</span>forEach
        <span class="apidocSignatureSpan">(str, regex, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">forEach = function (str, regex, callback) {
    var pos = 0;
    var i = -1;
    var match;

    while ((match = XRegExp.exec(str, regex, pos))) {
        // Because `regex` is provided to `callback`, the function could use the deprecated/
        // nonstandard `RegExp.prototype.compile` to mutate the regex. However, since `XRegExp.exec`
        // doesn't use `lastIndex` to set the search position, this can't lead to an infinite loop,
        // at least. Actually, because of the way `XRegExp.exec` caches globalized versions of
        // regexes, mutating the regex will not have any effect on the iteration or matched strings,
        // which is a nice side effect that brings extra safety.
        callback(match, ++i, str, regex);

        pos = match.index + (match[0].length || 1);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// The only caveat is that named captures must be referenced using numbered
// backreferences if used with native methods
'2017-02-22'.replace(date, '$2/$3/$1');
// -&gt; '02/22/2017'

// Use XRegExp.forEach to extract every other digit from a string
var evens = [];
XRegExp.<span class="apidocCodeKeywordSpan">forEach</span>('1a2345', /\d/, (match, i) =&gt; {
if (i % 2) evens.push(+match[0]);
});
// evens -&gt; [2, 4]

// Use XRegExp.matchChain to get numbers within &lt;b&gt; tags
XRegExp.matchChain('1 &lt;b&gt;2&lt;/b&gt; 3 &lt;B&gt;4 \n 56&lt;/B&gt;', [
XRegExp('(?is)&lt;b&gt;.*?&lt;/b&gt;'),
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.xregexp.globalize" id="apidoc.module.xregexp.globalize">module xregexp.globalize</a></h1>


    <h2>
        <a href="#apidoc.element.xregexp.globalize.globalize" id="apidoc.element.xregexp.globalize.globalize">
        function <span class="apidocSignatureSpan">xregexp.</span>globalize
        <span class="apidocSignatureSpan">(regex)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">globalize = function (regex) {
    return copyRegex(regex, {addG: true});
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * regexes are not recompiled using XRegExp syntax.
 *
 * @memberOf XRegExp
 * @param {RegExp} regex Regex to globalize.
 * @returns {RegExp} Copy of the provided regex with flag `g` added.
 * @example
 *
 * var globalCopy = XRegExp.<span class="apidocCodeKeywordSpan">globalize</span>(/regex/);
 * globalCopy.global; // -&gt; true
 */
XRegExp.globalize = function(regex) {
    return copyRegex(regex, {addG: true});
};

/**
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.xregexp.install" id="apidoc.module.xregexp.install">module xregexp.install</a></h1>


    <h2>
        <a href="#apidoc.element.xregexp.install.install" id="apidoc.element.xregexp.install.install">
        function <span class="apidocSignatureSpan">xregexp.</span>install
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">install = function (options) {
    options = prepareOptions(options);

    if (!features.astral &amp;&amp; options.astral) {
        setAstral(true);
    }

    if (!features.natives &amp;&amp; options.natives) {
        setNatives(true);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
unicodeWord.test('Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©'); // -&gt; true

// Test some Unicode scripts
XRegExp('^\\p{Hiragana}+$').test('ã²ã‚‰ãŒãª'); // -&gt; true
XRegExp('^[\\p{Latin}\\p{Common}]+$').test('Ãœber CafÃ©.'); // -&gt; true
```

By default, `\p{â€¦}` and `\P{â€¦}` support the Basic Multilingual Plane (i.e. code points up to `U+FFFF`). You can opt-in to full 21
-bit Unicode support (with code points up to `U+10FFFF`) on a per-regex basis by using flag `A`. This is called *astral mode*. You
 can automatically add flag `A` for all new regexes by running `XRegExp.<span class="apidocCodeKeywordSpan">install</span>('
;astral')`. When in astral mode, `\p{â€¦}` and `\P{â€¦}` always match a full code point rather than a code unit, using surrogate pairs for code points above `U+FFFF`.

```js
// Using flag A to match astral code points
XRegExp('^\\pS$').test('ðŸ’©'); // -&gt; false
XRegExp('^\\pS$', 'A').test('ðŸ’©'); // -&gt; true
XRegExp('(?A)^\\pS$').test('ðŸ’©'); // -&gt; true
// Using surrogate pair U+D83D U+DCA9 to represent U+1F4A9 (pile of poo)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.xregexp.isInstalled" id="apidoc.module.xregexp.isInstalled">module xregexp.isInstalled</a></h1>


    <h2>
        <a href="#apidoc.element.xregexp.isInstalled.isInstalled" id="apidoc.element.xregexp.isInstalled.isInstalled">
        function <span class="apidocSignatureSpan">xregexp.</span>isInstalled
        <span class="apidocSignatureSpan">(feature)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isInstalled = function (feature) {
    return !!(features[feature]);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    return copyRegex(pattern);
}

// Copy the argument behavior of `RegExp`
pattern = pattern === undefined ? '' : String(pattern);
flags = flags === undefined ? '' : String(flags);

if (XRegExp.<span class="apidocCodeKeywordSpan">isInstalled</span>('astral') &amp;&amp; flags.indexOf('A') === -
1) {
    // This causes an error to be thrown if the Unicode Base addon is not available
    flags += 'A';
}

if (!patternCache[pattern]) {
    patternCache[pattern] = {};
}
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.xregexp.isRegExp" id="apidoc.module.xregexp.isRegExp">module xregexp.isRegExp</a></h1>


    <h2>
        <a href="#apidoc.element.xregexp.isRegExp.isRegExp" id="apidoc.element.xregexp.isRegExp.isRegExp">
        function <span class="apidocSignatureSpan">xregexp.</span>isRegExp
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isRegExp = function (value) {
    return toString.call(value) === '[object RegExp]';
    //return isType(value, 'RegExp');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @param {String|RegExp} value Value to convert.
 * @param {Boolean} [addFlagX] Whether to apply the `x` flag in cases when `value` is not
 *   already a regex generated by XRegExp
 * @returns {RegExp} XRegExp object with XRegExp syntax applied.
 */
function asXRegExp(value, addFlagX) {
    var flags = addFlagX ? 'x' : '';
    return XRegExp.<span class="apidocCodeKeywordSpan">isRegExp</span>(value) ?
        (value[REGEX_DATA] &amp;&amp; value[REGEX_DATA].captureNames ?
            // Don't recompile, to preserve capture names
            value :
            // Recompile as XRegExp
            XRegExp(value.source, flags)
        ) :
        // Compile string as XRegExp
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.xregexp.match" id="apidoc.module.xregexp.match">module xregexp.match</a></h1>


    <h2>
        <a href="#apidoc.element.xregexp.match.match" id="apidoc.element.xregexp.match.match">
        function <span class="apidocSignatureSpan">xregexp.</span>match
        <span class="apidocSignatureSpan">(str, regex, scope)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">match = function (str, regex, scope) {
    var global = (regex.global &amp;&amp; scope !== 'one') || scope === 'all';
    var cacheKey = ((global ? 'g' : '') + (regex.sticky ? 'y' : '')) || 'noGY';
    var result;
    var r2;

    regex[REGEX_DATA] = regex[REGEX_DATA] || {};

    // Shares cached copies with `XRegExp.exec`/`replace`
    r2 = regex[REGEX_DATA][cacheKey] || (
        regex[REGEX_DATA][cacheKey] = copyRegex(regex, {
            addG: !!global,
            removeG: scope === 'one',
            isInternalOnly: true
        })
    );

    result = nativ.match.call(toObject(str), r2);

    if (regex.global) {
        regex.lastIndex = (
            (scope === 'one' &amp;&amp; result) ?
                // Can't use `r2.lastIndex` since `r2` is nonglobal in this case
                (result.index + result[0].length) : 0
        );
    }

    return global ? (result || []) : (result &amp;&amp; result[0]);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
*   return an array of all matched strings. If not explicitly specified and `regex` uses flag g,
*   `scope` is 'all'.
* @returns {String|Array} In match-first mode: First match as a string, or `null`. In match-all
*   mode: Array of all matched strings, or an empty array.
* @example
*
* // Match first
* XRegExp.<span class="apidocCodeKeywordSpan">match</span>('abc', /\w/); // -&gt; 'a'
* XRegExp.match('abc', /\w/g, 'one'); // -&gt; 'a'
* XRegExp.match('abc', /x/g, 'one'); // -&gt; null
*
* // Match all
* XRegExp.match('abc', /\w/g); // -&gt; ['a', 'b', 'c']
* XRegExp.match('abc', /\w/, 'all'); // -&gt; ['a', 'b', 'c']
* XRegExp.match('abc', /x/, 'all'); // -&gt; []
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.xregexp.matchChain" id="apidoc.module.xregexp.matchChain">module xregexp.matchChain</a></h1>


    <h2>
        <a href="#apidoc.element.xregexp.matchChain.matchChain" id="apidoc.element.xregexp.matchChain.matchChain">
        function <span class="apidocSignatureSpan">xregexp.</span>matchChain
        <span class="apidocSignatureSpan">(str, chain)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">matchChain = function (str, chain) {
    return (function recurseChain(values, level) {
        var item = chain[level].regex ? chain[level] : {regex: chain[level]};
        var matches = [];

        function addMatch(match) {
            if (item.backref) {
                // Safari 4.0.5 (but not 5.0.5+) inappropriately uses sparse arrays to hold the
                // `undefined`s for backreferences to nonparticipating capturing groups. In such
                // cases, a `hasOwnProperty` or `in` check on its own would inappropriately throw
                // the exception, so also check if the backreference is a number that is within the
                // bounds of the array.
                if (!(match.hasOwnProperty(item.backref) || +item.backref &lt; match.length)) {
                    throw new ReferenceError('Backreference to undefined group: ' + item.backref);
                }

                matches.push(match[item.backref] || '');
            } else {
                matches.push(match[0]);
            }
        }

        for (var i = 0; i &lt; values.length; ++i) {
            XRegExp.forEach(values[i], item.regex, addMatch);
        }

        return ((level === chain.length - 1) || !matches.length) ?
            matches :
            recurseChain(matches, level + 1);
    }([str], 0));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var evens = [];
XRegExp.forEach('1a2345', /\d/, (match, i) =&gt; {
    if (i % 2) evens.push(+match[0]);
});
// evens -&gt; [2, 4]

// Use XRegExp.matchChain to get numbers within &lt;b&gt; tags
XRegExp.<span class="apidocCodeKeywordSpan">matchChain</span>('1 &lt;b&gt;2&lt;/b&gt; 3 &lt;B&gt;4 \n 56&lt;/
B&gt;', [
    XRegExp('(?is)&lt;b&gt;.*?&lt;/b&gt;'),
    /\d+/
]);
// -&gt; ['2', '4', '56']

// You can also pass forward and return specific backreferences
var html = '&lt;a href="http://xregexp.com/"&gt;XRegExp&lt;/a&gt;' +
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.xregexp.matchRecursive" id="apidoc.module.xregexp.matchRecursive">module xregexp.matchRecursive</a></h1>


    <h2>
        <a href="#apidoc.element.xregexp.matchRecursive.matchRecursive" id="apidoc.element.xregexp.matchRecursive.matchRecursive">
        function <span class="apidocSignatureSpan">xregexp.</span>matchRecursive
        <span class="apidocSignatureSpan">(str, left, right, flags, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">matchRecursive = function (str, left, right, flags, options) {
    flags = flags || '';
    options = options || {};
    var global = flags.indexOf('g') &gt; -1;
    var sticky = flags.indexOf('y') &gt; -1;
    // Flag `y` is controlled internally
    var basicFlags = flags.replace(/y/g, '');
    var escapeChar = options.escapeChar;
    var vN = options.valueNames;
    var output = [];
    var openTokens = 0;
    var delimStart = 0;
    var delimEnd = 0;
    var lastOuterEnd = 0;
    var outerStart;
    var innerStart;
    var leftMatch;
    var rightMatch;
    var esc;
    left = XRegExp(left, basicFlags);
    right = XRegExp(right, basicFlags);

    if (escapeChar) {
        if (escapeChar.length &gt; 1) {
            throw new Error('Cannot use more than one escape character');
        }
        escapeChar = XRegExp.escape(escapeChar);
        // Example of concatenated `esc` regex:
        // `escapeChar`: '%'
        // `left`: '&lt;'
        // `right`: '&gt;'
        // Regex is: /(?:%[\S\s]|(?:(?!&lt;|&gt;)[^%])+)+/
        esc = new RegExp(
            '(?:' + escapeChar + '[\\S\\s]|(?:(?!' +
                // Using `XRegExp.union` safely rewrites backreferences in `left` and `right`.
                // Intentionally not passing `basicFlags` to `XRegExp.union` since any syntax
                // transformation resulting from those flags was already applied to `left` and
                // `right` when they were passed through the XRegExp constructor above.
                XRegExp.union([left, right], '', {conjunction: 'or'}).source +
                ')[^' + escapeChar + '])+)+',
            // Flags `gy` not needed here
            flags.replace(/[^imu]+/g, '')
        );
    }

    while (true) {
        // If using an escape character, advance to the delimiter's next starting position,
        // skipping any escaped characters in between
        if (escapeChar) {
            delimEnd += (XRegExp.exec(str, esc, delimEnd, 'sticky') || [''])[0].length;
        }
        leftMatch = XRegExp.exec(str, left, delimEnd);
        rightMatch = XRegExp.exec(str, right, delimEnd);
        // Keep the leftmost match only
        if (leftMatch &amp;&amp; rightMatch) {
            if (leftMatch.index &lt;= rightMatch.index) {
                rightMatch = null;
            } else {
                leftMatch = null;
            }
        }
        // Paths (LM: leftMatch, RM: rightMatch, OT: openTokens):
        // LM | RM | OT | Result
        // 1  | 0  | 1  | loop
        // 1  | 0  | 0  | loop
        // 0  | 1  | 1  | loop
        // 0  | 1  | 0  | throw
        // 0  | 0  | 1  | throw
        // 0  | 0  | 0  | break
        // The paths above don't include the sticky mode special case. The loop ends after the
        // first completed match if not `global`.
        if (leftMatch || rightMatch) {
            delimStart = (leftMatch || rightMatch).index;
            delimEnd = delimStart + (leftMatch || rightMatch)[0].length;
        } else if (!openTokens) {
            break;
        }
        if (sticky &amp;&amp; !openTokens &amp;&amp; delimStart &gt; lastOuterEnd) {
            break;
        }
        if (leftMatch) {
            if (!openTokens) {
                outerStart = delimStart;
                innerStart = delimEnd;
            }
            ++openTokens;
        } else if (rightMatch &amp;&amp; openTokens) {
            if (!--openTokens) {
                if (vN) {
                    if (vN[0] &amp;&amp; outerStart &gt; lastOuterEnd) {
                        output.push(row(vN[0], str.slice(lastOuterEnd, outerStart), lastOuterEnd, outerStart));
                    }
                    if (vN[1]) {
                        output.push(row(vN[1], str.slice(outerStart, innerStart), outerStart, innerStart));
                    }
                    if (vN[2]) {
                        output.push(row(vN[2], str.slice(innerStart, delimStart), innerStart, delimStart));
                    }
                    if (vN[3]) {
                        output.push(row(vN[3], str.slice(delimStart, d ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...

### XRegExp.matchRecursive

Match recursive constructs using XRegExp pattern strings as left and right delimiters:

```js
var str = '(t((e))s)t()(ing)';
XRegExp.<span class="apidocCodeKeywordSpan">matchRecursive</span>(str, '\\(', '\\)', 'g');
// -&gt; ['t((e))s', '', 'ing']

// Extended information mode with valueNames
str = 'Here is &lt;div&gt; &lt;div&gt;an&lt;/div&gt;&lt;/div&gt; example';
XRegExp.matchRecursive(str, '&lt;div\\s*&gt;', '&lt;/div&gt;', 'gi', {
    valueNames: ['between', 'left', 'match', 'right']
});
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.xregexp.replace" id="apidoc.module.xregexp.replace">module xregexp.replace</a></h1>


    <h2>
        <a href="#apidoc.element.xregexp.replace.replace" id="apidoc.element.xregexp.replace.replace">
        function <span class="apidocSignatureSpan">xregexp.</span>replace
        <span class="apidocSignatureSpan">(str, search, replacement, scope)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">replace = function (str, search, replacement, scope) {
    var isRegex = XRegExp.isRegExp(search);
    var global = (search.global &amp;&amp; scope !== 'one') || scope === 'all';
    var cacheKey = ((global ? 'g' : '') + (search.sticky ? 'y' : '')) || 'noGY';
    var s2 = search;
    var result;

    if (isRegex) {
        search[REGEX_DATA] = search[REGEX_DATA] || {};

        // Shares cached copies with `XRegExp.exec`/`match`. Since a copy is used, `search`'s
        // `lastIndex` isn't updated *during* replacement iterations
        s2 = search[REGEX_DATA][cacheKey] || (
            search[REGEX_DATA][cacheKey] = copyRegex(search, {
                addG: !!global,
                removeG: scope === 'one',
                isInternalOnly: true
            })
        );
    } else if (global) {
        s2 = new RegExp(XRegExp.escape(String(search)), 'g');
    }

    // Fixed `replace` required for named backreferences, etc.
    result = fixed.replace.call(toObject(str), s2, replacement);

    if (isRegex &amp;&amp; search.global) {
        // Fixes IE, Safari bug (last tested IE 9, Safari 5.1)
        search.lastIndex = 0;
    }

    return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
while (match = XRegExp.exec('&lt;1&gt;&lt;2&gt;&lt;3&gt;&lt;4&gt;5&lt;6&gt;', /&lt;(\d+)&gt;/,
pos, 'sticky')) {
    result.push(match[1]);
    pos = match.index + match[0].length;
}
// result -&gt; ['2', '3', '4']

// XRegExp.replace allows named backreferences in replacements
XRegExp.<span class="apidocCodeKeywordSpan">replace</span>('2017-02-22', date, '${month}/${day}/${year}');
// -&gt; '02/22/2017'
XRegExp.replace('2017-02-22', date, (match) =&gt; {
    return match.month + '/' + match.day + '/' + match.year;
});
// -&gt; '02/22/2017'

// XRegExps compile to RegExps and work perfectly with native methods
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.xregexp.replaceEach" id="apidoc.module.xregexp.replaceEach">module xregexp.replaceEach</a></h1>


    <h2>
        <a href="#apidoc.element.xregexp.replaceEach.replaceEach" id="apidoc.element.xregexp.replaceEach.replaceEach">
        function <span class="apidocSignatureSpan">xregexp.</span>replaceEach
        <span class="apidocSignatureSpan">(str, replacements)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">replaceEach = function (str, replacements) {
    var i;
    var r;

    for (i = 0; i &lt; replacements.length; ++i) {
        r = replacements[i];
        str = XRegExp.replace(str, r[0], r[1], r[2]);
    }

    return str;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
*
* @memberOf XRegExp
* @param {String} str String to search.
* @param {Array} replacements Array of replacement detail arrays.
* @returns {String} New string with all replacements.
* @example
*
* str = XRegExp.<span class="apidocCodeKeywordSpan">replaceEach</span>(str, [
*   [XRegExp('(?&lt;name&gt;a)'), 'z${name}'],
*   [/b/gi, 'y'],
*   [/c/g, 'x', 'one'], // scope 'one' overrides /g
*   [/d/, 'w', 'all'],  // scope 'all' overrides lack of /g
*   ['e', 'v', 'all'],  // scope 'all' allows replace-all for strings
*   [/f/g, function($0) {
*     return $0.toUpperCase();
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.xregexp.split" id="apidoc.module.xregexp.split">module xregexp.split</a></h1>


    <h2>
        <a href="#apidoc.element.xregexp.split.split" id="apidoc.element.xregexp.split.split">
        function <span class="apidocSignatureSpan">xregexp.</span>split
        <span class="apidocSignatureSpan">(str, separator, limit)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">split = function (str, separator, limit) {
    return fixed.split.call(toObject(str), separator, limit);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
           // extensions exist on `regex.prototype` anyway
           regex[p] = XRegExp.prototype[p];
       }
   }

   regex[REGEX_DATA].source = xSource;
   // Emulate the ES6 `flags` prop by ensuring flags are in alphabetical order
   regex[REGEX_DATA].flags = xFlags ? xFlags.<span class="apidocCodeKeywordSpan">split</span>('').sort().join('&amp;#
x27;) : xFlags;

   return regex;
}

/**
* Removes any duplicate characters from the provided string.
*
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.xregexp.test" id="apidoc.module.xregexp.test">module xregexp.test</a></h1>


    <h2>
        <a href="#apidoc.element.xregexp.test.test" id="apidoc.element.xregexp.test.test">
        function <span class="apidocSignatureSpan">xregexp.</span>test
        <span class="apidocSignatureSpan">(str, regex, pos, sticky)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">test = function (str, regex, pos, sticky) {
    // Do this the easy way :-)
    return !!XRegExp.exec(str, regex, pos, sticky);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// -&gt; '02/22/2017'
XRegExp.replace('2017-02-22', date, (match) =&gt; {
    return match.month + '/' + match.day + '/' + match.year;
});
// -&gt; '02/22/2017'

// XRegExps compile to RegExps and work perfectly with native methods
date.<span class="apidocCodeKeywordSpan">test</span>('2017-02-22');
// -&gt; true

// The only caveat is that named captures must be referenced using numbered
// backreferences if used with native methods
'2017-02-22'.replace(date, '$2/$3/$1');
// -&gt; '02/22/2017'
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.xregexp.toString" id="apidoc.module.xregexp.toString">module xregexp.toString</a></h1>


    <h2>
        <a href="#apidoc.element.xregexp.toString.toString" id="apidoc.element.xregexp.toString.toString">
        function <span class="apidocSignatureSpan">xregexp.</span>toString
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function toString() { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Converts decimal to hexadecimal.
*
* @private
* @param {Number|String} dec
* @returns {String}
*/
function hex(dec) {
   return parseInt(dec, 10).<span class="apidocCodeKeywordSpan">toString</span>(16);
}

/**
* Returns the first index at which a given value can be found in an array.
*
* @private
* @param {Array} array Array to search.
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.xregexp.uninstall" id="apidoc.module.xregexp.uninstall">module xregexp.uninstall</a></h1>


    <h2>
        <a href="#apidoc.element.xregexp.uninstall.uninstall" id="apidoc.element.xregexp.uninstall.uninstall">
        function <span class="apidocSignatureSpan">xregexp.</span>uninstall
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">uninstall = function (options) {
    options = prepareOptions(options);

    if (features.astral &amp;&amp; options.astral) {
        setAstral(false);
    }

    if (features.natives &amp;&amp; options.natives) {
        setNatives(false);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* uninstalled, so this is used to undo the actions of `XRegExp.install`.
*
* @memberOf XRegExp
* @param {Object|String} options Options object or string.
* @example
*
* // With an options object
* XRegExp.<span class="apidocCodeKeywordSpan">uninstall</span>({
*   // Disables support for astral code points in Unicode addons
*   astral: true,
*
*   // DEPRECATED: Restores native regex methods
*   natives: true
* });
*
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.xregexp.union" id="apidoc.module.xregexp.union">module xregexp.union</a></h1>


    <h2>
        <a href="#apidoc.element.xregexp.union.union" id="apidoc.element.xregexp.union.union">
        function <span class="apidocSignatureSpan">xregexp.</span>union
        <span class="apidocSignatureSpan">(patterns, flags, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">union = function (patterns, flags, options) {
    options = options || {};
    var conjunction = options.conjunction || 'or';
    var numCaptures = 0;
    var numPriorCaptures;
    var captureNames;

    function rewrite(match, paren, backref) {
        var name = captureNames[numCaptures - numPriorCaptures];

        // Capturing group
        if (paren) {
            ++numCaptures;
            // If the current capture has a name, preserve the name
            if (name) {
                return '(?&lt;' + name + '&gt;';
            }
        // Backreference
        } else if (backref) {
            // Rewrite the backreference
            return '\\' + (+backref + numPriorCaptures);
        }

        return match;
    }

    if (!(isType(patterns, 'Array') &amp;&amp; patterns.length)) {
        throw new TypeError('Must provide a nonempty array of patterns to merge');
    }

    var parts = /(\()(?!\?)|\\([1-9]\d*)|\\[\s\S]|\[(?:[^\\\]]|\\[\s\S])*\]/g;
    var output = [];
    var pattern;
    for (var i = 0; i &lt; patterns.length; ++i) {
        pattern = patterns[i];

        if (XRegExp.isRegExp(pattern)) {
            numPriorCaptures = numCaptures;
            captureNames = (pattern[REGEX_DATA] &amp;&amp; pattern[REGEX_DATA].captureNames) || [];

            // Rewrite backreferences. Passing to XRegExp dies on octals and ensures patterns are
            // independently valid; helps keep this simple. Named captures are put back
            output.push(nativ.replace.call(XRegExp(pattern.source).source, parts, rewrite));
        } else {
            output.push(XRegExp.escape(pattern));
        }
    }

    var separator = conjunction === 'none' ? '' : '|';
    return XRegExp(output.join(separator), flags);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
XRegExp.matchChain(html, [
    {regex: /&lt;a href="([^"]+)"&gt;/i, backref: 1},
    {regex: XRegExp('(?i)^https?://(?&lt;domain&gt;[^/?#]+)'), backref: 'domain'}
]);
// -&gt; ['xregexp.com', 'www.google.com']

// Merge strings and regexes into a single pattern with updated backreferences
XRegExp.<span class="apidocCodeKeywordSpan">union</span>(['a+b*c', /(dog)\1/, /(cat)\1/], 'i', {conjunction: &amp;#
x27;or'});
// -&gt; /a\+b\*c|(dog)\1|(cat)\2/i
```

These examples give the flavor of what's possible, but XRegExp has more syntax, flags, methods, options, and browser fixes
that aren't shown here. You can also augment XRegExp's regular expression syntax with addons (see below) or write your
 own. See [xregexp.com](http://xregexp.com/) for details.

## Addons
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.xregexp.xregexp" id="apidoc.module.xregexp.xregexp">module xregexp.xregexp</a></h1>


    <h2>
        <a href="#apidoc.element.xregexp.xregexp.xregexp" id="apidoc.element.xregexp.xregexp.xregexp">
        function <span class="apidocSignatureSpan">xregexp.</span>xregexp
        <span class="apidocSignatureSpan">(pattern, flags)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function XRegExp(pattern, flags) {
    if (XRegExp.isRegExp(pattern)) {
        if (flags !== undefined) {
            throw new TypeError('Cannot supply flags when copying a RegExp');
        }
        return copyRegex(pattern);
    }

    // Copy the argument behavior of `RegExp`
    pattern = pattern === undefined ? '' : String(pattern);
    flags = flags === undefined ? '' : String(flags);

    if (XRegExp.isInstalled('astral') &amp;&amp; flags.indexOf('A') === -1) {
        // This causes an error to be thrown if the Unicode Base addon is not available
        flags += 'A';
    }

    if (!patternCache[pattern]) {
        patternCache[pattern] = {};
    }

    if (!patternCache[pattern][flags]) {
        var context = {
            hasNamedCapture: false,
            captureNames: []
        };
        var scope = defaultScope;
        var output = '';
        var pos = 0;
        var result;

        // Check for flag-related errors, and strip/apply flags in a leading mode modifier
        var applied = prepareFlags(pattern, flags);
        var appliedPattern = applied.pattern;
        var appliedFlags = applied.flags;

        // Use XRegExp's tokens to translate the pattern to a native regex pattern.
        // `appliedPattern.length` may change on each iteration if tokens use `reparse`
        while (pos &lt; appliedPattern.length) {
            do {
                // Check for custom tokens at the current position
                result = runTokens(appliedPattern, appliedFlags, pos, scope, context);
                // If the matched token used the `reparse` option, splice its output into the
                // pattern before running tokens again at the same position
                if (result &amp;&amp; result.reparse) {
                    appliedPattern = appliedPattern.slice(0, pos) +
                        result.output +
                        appliedPattern.slice(pos + result.matchLength);
                }
            } while (result &amp;&amp; result.reparse);

            if (result) {
                output += result.output;
                pos += (result.matchLength || 1);
            } else {
                // Get the native token at the current position
                var token = XRegExp.exec(appliedPattern, nativeTokens[scope], pos, 'sticky')[0];
                output += token;
                pos += token.length;
                if (token === '[' &amp;&amp; scope === defaultScope) {
                    scope = classScope;
                } else if (token === ']' &amp;&amp; scope === classScope) {
                    scope = defaultScope;
                }
            }
        }

        patternCache[pattern][flags] = {
            // Use basic cleanup to collapse repeated empty groups like `(?:)(?:)` to `(?:)`. Empty
            // groups are sometimes inserted during regex transpilation in order to keep tokens
            // separated. However, more than one empty group in a row is never needed.
            pattern: nativ.replace.call(output, /(?:\(\?:\))+/g, '(?:)'),
            // Strip all but native flags
            flags: nativ.replace.call(appliedFlags, /[^gimuy]+/g, ''),
            // `context.captureNames` has an item for each capturing group, even if unnamed
            captures: context.hasNamedCapture ? context.captureNames : null
        };
    }

    var generated = patternCache[pattern][flags];
    return augment(
        new RegExp(generated.pattern, generated.flags),
        generated.captures,
        pattern,
        flags
    );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.xregexp.xregexp._clipDuplicates" id="apidoc.element.xregexp.xregexp._clipDuplicates">
        function <span class="apidocSignatureSpan">xregexp.xregexp.</span>_clipDuplicates
        <span class="apidocSignatureSpan">(str)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function clipDuplicates(str) {
    return nativ.replace.call(str, /([\s\S])(?=[\s\S]*\1)/g, '');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// Used with `asXRegExp` calls for `pattern` and subpatterns in `subs`, to work around how
// some browsers convert `RegExp('\n')` to a regex that contains the literal characters `\`
// and `n`. See more details at &lt;https://github.com/slevithan/xregexp/pull/163&gt;.
var addFlagX = flags.indexOf('x') &gt; -1;
var inlineFlags = /^\(\?([\w$]+)\)/.exec(pattern);
// Add flags within a leading mode modifier to the overall pattern's flags
if (inlineFlags) {
    flags = XRegExp.<span class="apidocCodeKeywordSpan">_clipDuplicates</span>(flags + inlineFlags[1]);
}

var data = {};
for (var p in subs) {
    if (subs.hasOwnProperty(p)) {
        // Passing to XRegExp enables extended syntax and ensures independent validity,
        // lest an unescaped `(`, `)`, `[`, or trailing `\` breaks the `(?:)` wrapper. For
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.xregexp.xregexp._dec" id="apidoc.element.xregexp.xregexp._dec">
        function <span class="apidocSignatureSpan">xregexp.xregexp.</span>_dec
        <span class="apidocSignatureSpan">(hex)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function dec(hex) {
    return parseInt(hex, 16);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.xregexp.xregexp._hasNativeFlag" id="apidoc.element.xregexp.xregexp._hasNativeFlag">
        function <span class="apidocSignatureSpan">xregexp.xregexp.</span>_hasNativeFlag
        <span class="apidocSignatureSpan">(flag)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function hasNativeFlag(flag) {
    // Can't check based on the presence of properties/getters since browsers might support such
    // properties even when they don't support the corresponding flag in regex construction (tested
    // in Chrome 48, where `'unicode' in /x/` is true but trying to construct a regex with flag `u`
    // throws an error)
    var isSupported = true;
    try {
        // Can't use regex literals for testing even in a `try` because regex literals with
        // unsupported flags cause a compilation error in IE
        new RegExp('', flag);
    } catch (exception) {
        isSupported = false;
    }
    return isSupported;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.xregexp.xregexp._hex" id="apidoc.element.xregexp.xregexp._hex">
        function <span class="apidocSignatureSpan">xregexp.xregexp.</span>_hex
        <span class="apidocSignatureSpan">(dec)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function hex(dec) {
    return parseInt(dec, 10).toString(16);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.xregexp.xregexp._pad4" id="apidoc.element.xregexp.xregexp._pad4">
        function <span class="apidocSignatureSpan">xregexp.xregexp.</span>_pad4
        <span class="apidocSignatureSpan">(str)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function pad4(str) {
    while (str.length &lt; 4) {
        str = '0' + str;
    }
    return str;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.xregexp.xregexp.addToken" id="apidoc.element.xregexp.xregexp.addToken">
        function <span class="apidocSignatureSpan">xregexp.xregexp.</span>addToken
        <span class="apidocSignatureSpan">(regex, handler, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">addToken = function (regex, handler, options) {
    options = options || {};
    var optionalFlags = options.optionalFlags;
    var i;

    if (options.flag) {
        registerFlag(options.flag);
    }

    if (optionalFlags) {
        optionalFlags = nativ.split.call(optionalFlags, '');
        for (i = 0; i &lt; optionalFlags.length; ++i) {
            registerFlag(optionalFlags[i]);
        }
    }

    // Add to the private list of syntax tokens
    tokens.push({
        regex: copyRegex(regex, {
            addG: true,
            addY: hasNativeY,
            isInternalOnly: true
        }),
        handler: handler,
        scope: options.scope || defaultScope,
        flag: options.flag,
        reparse: options.reparse,
        leadChar: options.leadChar
    });

    // Reset the pattern cache used by the `XRegExp` constructor, since the same pattern and flags
    // might now produce different results
    XRegExp.cache.flush('patterns');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// ==--------------------------==
// Core functionality
// ==--------------------------==

/*
 * Add astral mode (flag A) and Unicode token syntax: `\p{..}`, `\P{..}`, `\p{^..}`, `\pC`.
 */
XRegExp.<span class="apidocCodeKeywordSpan">addToken</span>(
    // Use `*` instead of `+` to avoid capturing `^` as the token name in `\p{^}`
    /\\([pP])(?:{(\^?)([^}]*)}|([A-Za-z]))/,
    function(match, scope, flags) {
        var ERR_DOUBLE_NEG = 'Invalid double negation ';
        var ERR_UNKNOWN_NAME = 'Unknown Unicode token ';
        var ERR_UNKNOWN_REF = 'Unicode token missing data ';
        var ERR_ASTRAL_ONLY = 'Astral mode required for Unicode token ';
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.xregexp.xregexp.cache" id="apidoc.element.xregexp.xregexp.cache">
        function <span class="apidocSignatureSpan">xregexp.xregexp.</span>cache
        <span class="apidocSignatureSpan">(pattern, flags)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">cache = function (pattern, flags) {
    if (!regexCache[pattern]) {
        regexCache[pattern] = {};
    }
    return regexCache[pattern][flags] || (
        regexCache[pattern][flags] = XRegExp(pattern, flags)
    );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 *
 * @memberOf XRegExp
 * @param {String} pattern Regex pattern string.
 * @param {String} [flags] Any combination of XRegExp flags.
 * @returns {RegExp} Cached XRegExp object.
 * @example
 *
 * while (match = XRegExp.<span class="apidocCodeKeywordSpan">cache</span>('.', 'gs').exec(str)) {
 *   // The regex is compiled once only
 * }
 */
XRegExp.cache = function(pattern, flags) {
if (!regexCache[pattern]) {
    regexCache[pattern] = {};
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.xregexp.xregexp.escape" id="apidoc.element.xregexp.xregexp.escape">
        function <span class="apidocSignatureSpan">xregexp.xregexp.</span>escape
        <span class="apidocSignatureSpan">(str)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">escape = function (str) {
    return nativ.replace.call(toObject(str), /[-\[\]{}()*+?.,\\^$|#\s]/g, '\\$&amp;');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
left = XRegExp(left, basicFlags);
right = XRegExp(right, basicFlags);

if (escapeChar) {
    if (escapeChar.length &gt; 1) {
        throw new Error('Cannot use more than one escape character');
    }
    escapeChar = XRegExp.<span class="apidocCodeKeywordSpan">escape</span>(escapeChar);
    // Example of concatenated `esc` regex:
    // `escapeChar`: '%'
    // `left`: '&lt;'
    // `right`: '&gt;'
    // Regex is: /(?:%[\S\s]|(?:(?!&lt;|&gt;)[^%])+)+/
    esc = new RegExp(
        '(?:' + escapeChar + '[\\S\\s]|(?:(?!' +
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.xregexp.xregexp.exec" id="apidoc.element.xregexp.xregexp.exec">
        function <span class="apidocSignatureSpan">xregexp.xregexp.</span>exec
        <span class="apidocSignatureSpan">(str, regex, pos, sticky)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">exec = function (str, regex, pos, sticky) {
    var cacheKey = 'g';
    var addY = false;
    var fakeY = false;
    var match;
    var r2;

    addY = hasNativeY &amp;&amp; !!(sticky || (regex.sticky &amp;&amp; sticky !== false));
    if (addY) {
        cacheKey += 'y';
    } else if (sticky) {
        // Simulate sticky matching by appending an empty capture to the original regex. The
        // resulting regex will succeed no matter what at the current index (set with `lastIndex`),
        // and will not search the rest of the subject string. We'll know that the original regex
        // has failed if that last capture is `''` rather than `undefined` (i.e., if that last
        // capture participated in the match).
        fakeY = true;
        cacheKey += 'FakeY';
    }

    regex[REGEX_DATA] = regex[REGEX_DATA] || {};

    // Shares cached copies with `XRegExp.match`/`replace`
    r2 = regex[REGEX_DATA][cacheKey] || (
        regex[REGEX_DATA][cacheKey] = copyRegex(regex, {
            addG: true,
            addY: addY,
            source: fakeY ? regex.source + '|()' : undefined,
            removeY: sticky === false,
            isInternalOnly: true
        })
    );

    pos = pos || 0;
    r2.lastIndex = pos;

    // Fixed `exec` required for `lastIndex` fix, named backreferences, etc.
    match = fixed.exec.call(r2, str);

    // Get rid of the capture added by the pseudo-sticky matcher if needed. An empty string means
    // the original regexp failed (see above).
    if (fakeY &amp;&amp; match &amp;&amp; match.pop() === '') {
        match = null;
    }

    if (regex.global) {
        regex.lastIndex = match ? r2.lastIndex : 0;
    }

    return match;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
```js
// Using named capture and flag x (free-spacing and line comments)
var date = XRegExp(`(?&lt;year&gt;  [0-9]{4} ) -?  # year
                (?&lt;month&gt; [0-9]{2} ) -?  # month
                (?&lt;day&gt;   [0-9]{2} )     # day`, 'x');

// XRegExp.exec gives you named backreferences on the match result
var match = XRegExp.<span class="apidocCodeKeywordSpan">exec</span>('2017-02-22', date);
match.year; // -&gt; '2017'

// It also includes optional pos and sticky arguments
var pos = 3;
var result = [];
while (match = XRegExp.exec('&lt;1&gt;&lt;2&gt;&lt;3&gt;&lt;4&gt;5&lt;6&gt;', /&lt;(\d+)&gt;/,
pos, 'sticky')) {
result.push(match[1]);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.xregexp.xregexp.forEach" id="apidoc.element.xregexp.xregexp.forEach">
        function <span class="apidocSignatureSpan">xregexp.xregexp.</span>forEach
        <span class="apidocSignatureSpan">(str, regex, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">forEach = function (str, regex, callback) {
    var pos = 0;
    var i = -1;
    var match;

    while ((match = XRegExp.exec(str, regex, pos))) {
        // Because `regex` is provided to `callback`, the function could use the deprecated/
        // nonstandard `RegExp.prototype.compile` to mutate the regex. However, since `XRegExp.exec`
        // doesn't use `lastIndex` to set the search position, this can't lead to an infinite loop,
        // at least. Actually, because of the way `XRegExp.exec` caches globalized versions of
        // regexes, mutating the regex will not have any effect on the iteration or matched strings,
        // which is a nice side effect that brings extra safety.
        callback(match, ++i, str, regex);

        pos = match.index + (match[0].length || 1);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// The only caveat is that named captures must be referenced using numbered
// backreferences if used with native methods
'2017-02-22'.replace(date, '$2/$3/$1');
// -&gt; '02/22/2017'

// Use XRegExp.forEach to extract every other digit from a string
var evens = [];
XRegExp.<span class="apidocCodeKeywordSpan">forEach</span>('1a2345', /\d/, (match, i) =&gt; {
if (i % 2) evens.push(+match[0]);
});
// evens -&gt; [2, 4]

// Use XRegExp.matchChain to get numbers within &lt;b&gt; tags
XRegExp.matchChain('1 &lt;b&gt;2&lt;/b&gt; 3 &lt;B&gt;4 \n 56&lt;/B&gt;', [
XRegExp('(?is)&lt;b&gt;.*?&lt;/b&gt;'),
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.xregexp.xregexp.globalize" id="apidoc.element.xregexp.xregexp.globalize">
        function <span class="apidocSignatureSpan">xregexp.xregexp.</span>globalize
        <span class="apidocSignatureSpan">(regex)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">globalize = function (regex) {
    return copyRegex(regex, {addG: true});
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * regexes are not recompiled using XRegExp syntax.
 *
 * @memberOf XRegExp
 * @param {RegExp} regex Regex to globalize.
 * @returns {RegExp} Copy of the provided regex with flag `g` added.
 * @example
 *
 * var globalCopy = XRegExp.<span class="apidocCodeKeywordSpan">globalize</span>(/regex/);
 * globalCopy.global; // -&gt; true
 */
XRegExp.globalize = function(regex) {
    return copyRegex(regex, {addG: true});
};

/**
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.xregexp.xregexp.install" id="apidoc.element.xregexp.xregexp.install">
        function <span class="apidocSignatureSpan">xregexp.xregexp.</span>install
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">install = function (options) {
    options = prepareOptions(options);

    if (!features.astral &amp;&amp; options.astral) {
        setAstral(true);
    }

    if (!features.natives &amp;&amp; options.natives) {
        setNatives(true);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
unicodeWord.test('Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©'); // -&gt; true

// Test some Unicode scripts
XRegExp('^\\p{Hiragana}+$').test('ã²ã‚‰ãŒãª'); // -&gt; true
XRegExp('^[\\p{Latin}\\p{Common}]+$').test('Ãœber CafÃ©.'); // -&gt; true
```

By default, `\p{â€¦}` and `\P{â€¦}` support the Basic Multilingual Plane (i.e. code points up to `U+FFFF`). You can opt-in to full 21
-bit Unicode support (with code points up to `U+10FFFF`) on a per-regex basis by using flag `A`. This is called *astral mode*. You
 can automatically add flag `A` for all new regexes by running `XRegExp.<span class="apidocCodeKeywordSpan">install</span>('
;astral')`. When in astral mode, `\p{â€¦}` and `\P{â€¦}` always match a full code point rather than a code unit, using surrogate pairs for code points above `U+FFFF`.

```js
// Using flag A to match astral code points
XRegExp('^\\pS$').test('ðŸ’©'); // -&gt; false
XRegExp('^\\pS$', 'A').test('ðŸ’©'); // -&gt; true
XRegExp('(?A)^\\pS$').test('ðŸ’©'); // -&gt; true
// Using surrogate pair U+D83D U+DCA9 to represent U+1F4A9 (pile of poo)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.xregexp.xregexp.isInstalled" id="apidoc.element.xregexp.xregexp.isInstalled">
        function <span class="apidocSignatureSpan">xregexp.xregexp.</span>isInstalled
        <span class="apidocSignatureSpan">(feature)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isInstalled = function (feature) {
    return !!(features[feature]);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    return copyRegex(pattern);
}

// Copy the argument behavior of `RegExp`
pattern = pattern === undefined ? '' : String(pattern);
flags = flags === undefined ? '' : String(flags);

if (XRegExp.<span class="apidocCodeKeywordSpan">isInstalled</span>('astral') &amp;&amp; flags.indexOf('A') === -
1) {
    // This causes an error to be thrown if the Unicode Base addon is not available
    flags += 'A';
}

if (!patternCache[pattern]) {
    patternCache[pattern] = {};
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.xregexp.xregexp.isRegExp" id="apidoc.element.xregexp.xregexp.isRegExp">
        function <span class="apidocSignatureSpan">xregexp.xregexp.</span>isRegExp
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isRegExp = function (value) {
    return toString.call(value) === '[object RegExp]';
    //return isType(value, 'RegExp');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @param {String|RegExp} value Value to convert.
 * @param {Boolean} [addFlagX] Whether to apply the `x` flag in cases when `value` is not
 *   already a regex generated by XRegExp
 * @returns {RegExp} XRegExp object with XRegExp syntax applied.
 */
function asXRegExp(value, addFlagX) {
    var flags = addFlagX ? 'x' : '';
    return XRegExp.<span class="apidocCodeKeywordSpan">isRegExp</span>(value) ?
        (value[REGEX_DATA] &amp;&amp; value[REGEX_DATA].captureNames ?
            // Don't recompile, to preserve capture names
            value :
            // Recompile as XRegExp
            XRegExp(value.source, flags)
        ) :
        // Compile string as XRegExp
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.xregexp.xregexp.match" id="apidoc.element.xregexp.xregexp.match">
        function <span class="apidocSignatureSpan">xregexp.xregexp.</span>match
        <span class="apidocSignatureSpan">(str, regex, scope)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">match = function (str, regex, scope) {
    var global = (regex.global &amp;&amp; scope !== 'one') || scope === 'all';
    var cacheKey = ((global ? 'g' : '') + (regex.sticky ? 'y' : '')) || 'noGY';
    var result;
    var r2;

    regex[REGEX_DATA] = regex[REGEX_DATA] || {};

    // Shares cached copies with `XRegExp.exec`/`replace`
    r2 = regex[REGEX_DATA][cacheKey] || (
        regex[REGEX_DATA][cacheKey] = copyRegex(regex, {
            addG: !!global,
            removeG: scope === 'one',
            isInternalOnly: true
        })
    );

    result = nativ.match.call(toObject(str), r2);

    if (regex.global) {
        regex.lastIndex = (
            (scope === 'one' &amp;&amp; result) ?
                // Can't use `r2.lastIndex` since `r2` is nonglobal in this case
                (result.index + result[0].length) : 0
        );
    }

    return global ? (result || []) : (result &amp;&amp; result[0]);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
*   return an array of all matched strings. If not explicitly specified and `regex` uses flag g,
*   `scope` is 'all'.
* @returns {String|Array} In match-first mode: First match as a string, or `null`. In match-all
*   mode: Array of all matched strings, or an empty array.
* @example
*
* // Match first
* XRegExp.<span class="apidocCodeKeywordSpan">match</span>('abc', /\w/); // -&gt; 'a'
* XRegExp.match('abc', /\w/g, 'one'); // -&gt; 'a'
* XRegExp.match('abc', /x/g, 'one'); // -&gt; null
*
* // Match all
* XRegExp.match('abc', /\w/g); // -&gt; ['a', 'b', 'c']
* XRegExp.match('abc', /\w/, 'all'); // -&gt; ['a', 'b', 'c']
* XRegExp.match('abc', /x/, 'all'); // -&gt; []
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.xregexp.xregexp.matchChain" id="apidoc.element.xregexp.xregexp.matchChain">
        function <span class="apidocSignatureSpan">xregexp.xregexp.</span>matchChain
        <span class="apidocSignatureSpan">(str, chain)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">matchChain = function (str, chain) {
    return (function recurseChain(values, level) {
        var item = chain[level].regex ? chain[level] : {regex: chain[level]};
        var matches = [];

        function addMatch(match) {
            if (item.backref) {
                // Safari 4.0.5 (but not 5.0.5+) inappropriately uses sparse arrays to hold the
                // `undefined`s for backreferences to nonparticipating capturing groups. In such
                // cases, a `hasOwnProperty` or `in` check on its own would inappropriately throw
                // the exception, so also check if the backreference is a number that is within the
                // bounds of the array.
                if (!(match.hasOwnProperty(item.backref) || +item.backref &lt; match.length)) {
                    throw new ReferenceError('Backreference to undefined group: ' + item.backref);
                }

                matches.push(match[item.backref] || '');
            } else {
                matches.push(match[0]);
            }
        }

        for (var i = 0; i &lt; values.length; ++i) {
            XRegExp.forEach(values[i], item.regex, addMatch);
        }

        return ((level === chain.length - 1) || !matches.length) ?
            matches :
            recurseChain(matches, level + 1);
    }([str], 0));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var evens = [];
XRegExp.forEach('1a2345', /\d/, (match, i) =&gt; {
    if (i % 2) evens.push(+match[0]);
});
// evens -&gt; [2, 4]

// Use XRegExp.matchChain to get numbers within &lt;b&gt; tags
XRegExp.<span class="apidocCodeKeywordSpan">matchChain</span>('1 &lt;b&gt;2&lt;/b&gt; 3 &lt;B&gt;4 \n 56&lt;/
B&gt;', [
    XRegExp('(?is)&lt;b&gt;.*?&lt;/b&gt;'),
    /\d+/
]);
// -&gt; ['2', '4', '56']

// You can also pass forward and return specific backreferences
var html = '&lt;a href="http://xregexp.com/"&gt;XRegExp&lt;/a&gt;' +
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.xregexp.xregexp.replace" id="apidoc.element.xregexp.xregexp.replace">
        function <span class="apidocSignatureSpan">xregexp.xregexp.</span>replace
        <span class="apidocSignatureSpan">(str, search, replacement, scope)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">replace = function (str, search, replacement, scope) {
    var isRegex = XRegExp.isRegExp(search);
    var global = (search.global &amp;&amp; scope !== 'one') || scope === 'all';
    var cacheKey = ((global ? 'g' : '') + (search.sticky ? 'y' : '')) || 'noGY';
    var s2 = search;
    var result;

    if (isRegex) {
        search[REGEX_DATA] = search[REGEX_DATA] || {};

        // Shares cached copies with `XRegExp.exec`/`match`. Since a copy is used, `search`'s
        // `lastIndex` isn't updated *during* replacement iterations
        s2 = search[REGEX_DATA][cacheKey] || (
            search[REGEX_DATA][cacheKey] = copyRegex(search, {
                addG: !!global,
                removeG: scope === 'one',
                isInternalOnly: true
            })
        );
    } else if (global) {
        s2 = new RegExp(XRegExp.escape(String(search)), 'g');
    }

    // Fixed `replace` required for named backreferences, etc.
    result = fixed.replace.call(toObject(str), s2, replacement);

    if (isRegex &amp;&amp; search.global) {
        // Fixes IE, Safari bug (last tested IE 9, Safari 5.1)
        search.lastIndex = 0;
    }

    return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
while (match = XRegExp.exec('&lt;1&gt;&lt;2&gt;&lt;3&gt;&lt;4&gt;5&lt;6&gt;', /&lt;(\d+)&gt;/,
pos, 'sticky')) {
    result.push(match[1]);
    pos = match.index + match[0].length;
}
// result -&gt; ['2', '3', '4']

// XRegExp.replace allows named backreferences in replacements
XRegExp.<span class="apidocCodeKeywordSpan">replace</span>('2017-02-22', date, '${month}/${day}/${year}');
// -&gt; '02/22/2017'
XRegExp.replace('2017-02-22', date, (match) =&gt; {
    return match.month + '/' + match.day + '/' + match.year;
});
// -&gt; '02/22/2017'

// XRegExps compile to RegExps and work perfectly with native methods
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.xregexp.xregexp.replaceEach" id="apidoc.element.xregexp.xregexp.replaceEach">
        function <span class="apidocSignatureSpan">xregexp.xregexp.</span>replaceEach
        <span class="apidocSignatureSpan">(str, replacements)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">replaceEach = function (str, replacements) {
    var i;
    var r;

    for (i = 0; i &lt; replacements.length; ++i) {
        r = replacements[i];
        str = XRegExp.replace(str, r[0], r[1], r[2]);
    }

    return str;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
*
* @memberOf XRegExp
* @param {String} str String to search.
* @param {Array} replacements Array of replacement detail arrays.
* @returns {String} New string with all replacements.
* @example
*
* str = XRegExp.<span class="apidocCodeKeywordSpan">replaceEach</span>(str, [
*   [XRegExp('(?&lt;name&gt;a)'), 'z${name}'],
*   [/b/gi, 'y'],
*   [/c/g, 'x', 'one'], // scope 'one' overrides /g
*   [/d/, 'w', 'all'],  // scope 'all' overrides lack of /g
*   ['e', 'v', 'all'],  // scope 'all' allows replace-all for strings
*   [/f/g, function($0) {
*     return $0.toUpperCase();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.xregexp.xregexp.split" id="apidoc.element.xregexp.xregexp.split">
        function <span class="apidocSignatureSpan">xregexp.xregexp.</span>split
        <span class="apidocSignatureSpan">(str, separator, limit)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">split = function (str, separator, limit) {
    return fixed.split.call(toObject(str), separator, limit);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
           // extensions exist on `regex.prototype` anyway
           regex[p] = XRegExp.prototype[p];
       }
   }

   regex[REGEX_DATA].source = xSource;
   // Emulate the ES6 `flags` prop by ensuring flags are in alphabetical order
   regex[REGEX_DATA].flags = xFlags ? xFlags.<span class="apidocCodeKeywordSpan">split</span>('').sort().join('&amp;#
x27;) : xFlags;

   return regex;
}

/**
* Removes any duplicate characters from the provided string.
*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.xregexp.xregexp.test" id="apidoc.element.xregexp.xregexp.test">
        function <span class="apidocSignatureSpan">xregexp.xregexp.</span>test
        <span class="apidocSignatureSpan">(str, regex, pos, sticky)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">test = function (str, regex, pos, sticky) {
    // Do this the easy way :-)
    return !!XRegExp.exec(str, regex, pos, sticky);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// -&gt; '02/22/2017'
XRegExp.replace('2017-02-22', date, (match) =&gt; {
    return match.month + '/' + match.day + '/' + match.year;
});
// -&gt; '02/22/2017'

// XRegExps compile to RegExps and work perfectly with native methods
date.<span class="apidocCodeKeywordSpan">test</span>('2017-02-22');
// -&gt; true

// The only caveat is that named captures must be referenced using numbered
// backreferences if used with native methods
'2017-02-22'.replace(date, '$2/$3/$1');
// -&gt; '02/22/2017'
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.xregexp.xregexp.uninstall" id="apidoc.element.xregexp.xregexp.uninstall">
        function <span class="apidocSignatureSpan">xregexp.xregexp.</span>uninstall
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">uninstall = function (options) {
    options = prepareOptions(options);

    if (features.astral &amp;&amp; options.astral) {
        setAstral(false);
    }

    if (features.natives &amp;&amp; options.natives) {
        setNatives(false);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* uninstalled, so this is used to undo the actions of `XRegExp.install`.
*
* @memberOf XRegExp
* @param {Object|String} options Options object or string.
* @example
*
* // With an options object
* XRegExp.<span class="apidocCodeKeywordSpan">uninstall</span>({
*   // Disables support for astral code points in Unicode addons
*   astral: true,
*
*   // DEPRECATED: Restores native regex methods
*   natives: true
* });
*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.xregexp.xregexp.union" id="apidoc.element.xregexp.xregexp.union">
        function <span class="apidocSignatureSpan">xregexp.xregexp.</span>union
        <span class="apidocSignatureSpan">(patterns, flags, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">union = function (patterns, flags, options) {
    options = options || {};
    var conjunction = options.conjunction || 'or';
    var numCaptures = 0;
    var numPriorCaptures;
    var captureNames;

    function rewrite(match, paren, backref) {
        var name = captureNames[numCaptures - numPriorCaptures];

        // Capturing group
        if (paren) {
            ++numCaptures;
            // If the current capture has a name, preserve the name
            if (name) {
                return '(?&lt;' + name + '&gt;';
            }
        // Backreference
        } else if (backref) {
            // Rewrite the backreference
            return '\\' + (+backref + numPriorCaptures);
        }

        return match;
    }

    if (!(isType(patterns, 'Array') &amp;&amp; patterns.length)) {
        throw new TypeError('Must provide a nonempty array of patterns to merge');
    }

    var parts = /(\()(?!\?)|\\([1-9]\d*)|\\[\s\S]|\[(?:[^\\\]]|\\[\s\S])*\]/g;
    var output = [];
    var pattern;
    for (var i = 0; i &lt; patterns.length; ++i) {
        pattern = patterns[i];

        if (XRegExp.isRegExp(pattern)) {
            numPriorCaptures = numCaptures;
            captureNames = (pattern[REGEX_DATA] &amp;&amp; pattern[REGEX_DATA].captureNames) || [];

            // Rewrite backreferences. Passing to XRegExp dies on octals and ensures patterns are
            // independently valid; helps keep this simple. Named captures are put back
            output.push(nativ.replace.call(XRegExp(pattern.source).source, parts, rewrite));
        } else {
            output.push(XRegExp.escape(pattern));
        }
    }

    var separator = conjunction === 'none' ? '' : '|';
    return XRegExp(output.join(separator), flags);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
XRegExp.matchChain(html, [
    {regex: /&lt;a href="([^"]+)"&gt;/i, backref: 1},
    {regex: XRegExp('(?i)^https?://(?&lt;domain&gt;[^/?#]+)'), backref: 'domain'}
]);
// -&gt; ['xregexp.com', 'www.google.com']

// Merge strings and regexes into a single pattern with updated backreferences
XRegExp.<span class="apidocCodeKeywordSpan">union</span>(['a+b*c', /(dog)\1/, /(cat)\1/], 'i', {conjunction: &amp;#
x27;or'});
// -&gt; /a\+b\*c|(dog)\1|(cat)\2/i
```

These examples give the flavor of what's possible, but XRegExp has more syntax, flags, methods, options, and browser fixes
that aren't shown here. You can also augment XRegExp's regular expression syntax with addons (see below) or write your
 own. See [xregexp.com](http://xregexp.com/) for details.

## Addons
...</pre></li>
    </ul>




</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
</body></html>
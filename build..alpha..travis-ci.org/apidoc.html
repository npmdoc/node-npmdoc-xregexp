<div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a

        href="http://xregexp.com/"

    >xregexp (v3.2.0)</a>
</h1>
<h4>Extended regular expressions</h4>
<div class="apidocSectionDiv"><a
    href="#apidoc.tableOfContents"
    id="apidoc.tableOfContents"
><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.xregexp">module xregexp</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.xregexp.xregexp">
            function <span class="apidocSignatureSpan"></span>xregexp
            <span class="apidocSignatureSpan">(pattern, flags)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.xregexp._clipDuplicates">
            function <span class="apidocSignatureSpan">xregexp.</span>_clipDuplicates
            <span class="apidocSignatureSpan">(str)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.xregexp._dec">
            function <span class="apidocSignatureSpan">xregexp.</span>_dec
            <span class="apidocSignatureSpan">(hex)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.xregexp._getUnicodeProperty">
            function <span class="apidocSignatureSpan">xregexp.</span>_getUnicodeProperty
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.xregexp._hasNativeFlag">
            function <span class="apidocSignatureSpan">xregexp.</span>_hasNativeFlag
            <span class="apidocSignatureSpan">(flag)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.xregexp._hex">
            function <span class="apidocSignatureSpan">xregexp.</span>_hex
            <span class="apidocSignatureSpan">(dec)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.xregexp._pad4">
            function <span class="apidocSignatureSpan">xregexp.</span>_pad4
            <span class="apidocSignatureSpan">(str)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.xregexp.addToken">
            function <span class="apidocSignatureSpan">xregexp.</span>addToken
            <span class="apidocSignatureSpan">(regex, handler, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.xregexp.addUnicodeData">
            function <span class="apidocSignatureSpan">xregexp.</span>addUnicodeData
            <span class="apidocSignatureSpan">(data)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.xregexp.build">
            function <span class="apidocSignatureSpan">xregexp.</span>build
            <span class="apidocSignatureSpan">(pattern, subs, flags)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.xregexp.cache">
            function <span class="apidocSignatureSpan">xregexp.</span>cache
            <span class="apidocSignatureSpan">(pattern, flags)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.xregexp.escape">
            function <span class="apidocSignatureSpan">xregexp.</span>escape
            <span class="apidocSignatureSpan">(str)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.xregexp.exec">
            function <span class="apidocSignatureSpan">xregexp.</span>exec
            <span class="apidocSignatureSpan">(str, regex, pos, sticky)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.xregexp.forEach">
            function <span class="apidocSignatureSpan">xregexp.</span>forEach
            <span class="apidocSignatureSpan">(str, regex, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.xregexp.globalize">
            function <span class="apidocSignatureSpan">xregexp.</span>globalize
            <span class="apidocSignatureSpan">(regex)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.xregexp.index">
            function <span class="apidocSignatureSpan">xregexp.</span>index
            <span class="apidocSignatureSpan">(pattern, flags)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.xregexp.install">
            function <span class="apidocSignatureSpan">xregexp.</span>install
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.xregexp.isInstalled">
            function <span class="apidocSignatureSpan">xregexp.</span>isInstalled
            <span class="apidocSignatureSpan">(feature)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.xregexp.isRegExp">
            function <span class="apidocSignatureSpan">xregexp.</span>isRegExp
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.xregexp.match">
            function <span class="apidocSignatureSpan">xregexp.</span>match
            <span class="apidocSignatureSpan">(str, regex, scope)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.xregexp.matchChain">
            function <span class="apidocSignatureSpan">xregexp.</span>matchChain
            <span class="apidocSignatureSpan">(str, chain)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.xregexp.matchRecursive">
            function <span class="apidocSignatureSpan">xregexp.</span>matchRecursive
            <span class="apidocSignatureSpan">(str, left, right, flags, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.xregexp.replace">
            function <span class="apidocSignatureSpan">xregexp.</span>replace
            <span class="apidocSignatureSpan">(str, search, replacement, scope)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.xregexp.replaceEach">
            function <span class="apidocSignatureSpan">xregexp.</span>replaceEach
            <span class="apidocSignatureSpan">(str, replacements)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.xregexp.split">
            function <span class="apidocSignatureSpan">xregexp.</span>split
            <span class="apidocSignatureSpan">(str, separator, limit)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.xregexp.test">
            function <span class="apidocSignatureSpan">xregexp.</span>test
            <span class="apidocSignatureSpan">(str, regex, pos, sticky)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.xregexp.uninstall">
            function <span class="apidocSignatureSpan">xregexp.</span>uninstall
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.xregexp.union">
            function <span class="apidocSignatureSpan">xregexp.</span>union
            <span class="apidocSignatureSpan">(patterns, flags, options)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">xregexp.</span>version</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.xregexp.cache">module xregexp.cache</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.xregexp.cache.cache">
            function <span class="apidocSignatureSpan">xregexp.</span>cache
            <span class="apidocSignatureSpan">(pattern, flags)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.xregexp.cache.flush">
            function <span class="apidocSignatureSpan">xregexp.cache.</span>flush
            <span class="apidocSignatureSpan">(cacheName)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.xregexp.index">module xregexp.index</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.xregexp.index.index">
            function <span class="apidocSignatureSpan">xregexp.</span>index
            <span class="apidocSignatureSpan">(pattern, flags)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.xregexp.index._clipDuplicates">
            function <span class="apidocSignatureSpan">xregexp.index.</span>_clipDuplicates
            <span class="apidocSignatureSpan">(str)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.xregexp.index._dec">
            function <span class="apidocSignatureSpan">xregexp.index.</span>_dec
            <span class="apidocSignatureSpan">(hex)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.xregexp.index._getUnicodeProperty">
            function <span class="apidocSignatureSpan">xregexp.index.</span>_getUnicodeProperty
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.xregexp.index._hasNativeFlag">
            function <span class="apidocSignatureSpan">xregexp.index.</span>_hasNativeFlag
            <span class="apidocSignatureSpan">(flag)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.xregexp.index._hex">
            function <span class="apidocSignatureSpan">xregexp.index.</span>_hex
            <span class="apidocSignatureSpan">(dec)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.xregexp.index._pad4">
            function <span class="apidocSignatureSpan">xregexp.index.</span>_pad4
            <span class="apidocSignatureSpan">(str)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.xregexp.index.addToken">
            function <span class="apidocSignatureSpan">xregexp.index.</span>addToken
            <span class="apidocSignatureSpan">(regex, handler, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.xregexp.index.addUnicodeData">
            function <span class="apidocSignatureSpan">xregexp.index.</span>addUnicodeData
            <span class="apidocSignatureSpan">(data)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.xregexp.index.build">
            function <span class="apidocSignatureSpan">xregexp.index.</span>build
            <span class="apidocSignatureSpan">(pattern, subs, flags)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.xregexp.index.cache">
            function <span class="apidocSignatureSpan">xregexp.index.</span>cache
            <span class="apidocSignatureSpan">(pattern, flags)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.xregexp.index.escape">
            function <span class="apidocSignatureSpan">xregexp.index.</span>escape
            <span class="apidocSignatureSpan">(str)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.xregexp.index.exec">
            function <span class="apidocSignatureSpan">xregexp.index.</span>exec
            <span class="apidocSignatureSpan">(str, regex, pos, sticky)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.xregexp.index.forEach">
            function <span class="apidocSignatureSpan">xregexp.index.</span>forEach
            <span class="apidocSignatureSpan">(str, regex, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.xregexp.index.globalize">
            function <span class="apidocSignatureSpan">xregexp.index.</span>globalize
            <span class="apidocSignatureSpan">(regex)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.xregexp.index.install">
            function <span class="apidocSignatureSpan">xregexp.index.</span>install
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.xregexp.index.isInstalled">
            function <span class="apidocSignatureSpan">xregexp.index.</span>isInstalled
            <span class="apidocSignatureSpan">(feature)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.xregexp.index.isRegExp">
            function <span class="apidocSignatureSpan">xregexp.index.</span>isRegExp
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.xregexp.index.match">
            function <span class="apidocSignatureSpan">xregexp.index.</span>match
            <span class="apidocSignatureSpan">(str, regex, scope)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.xregexp.index.matchChain">
            function <span class="apidocSignatureSpan">xregexp.index.</span>matchChain
            <span class="apidocSignatureSpan">(str, chain)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.xregexp.index.matchRecursive">
            function <span class="apidocSignatureSpan">xregexp.index.</span>matchRecursive
            <span class="apidocSignatureSpan">(str, left, right, flags, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.xregexp.index.replace">
            function <span class="apidocSignatureSpan">xregexp.index.</span>replace
            <span class="apidocSignatureSpan">(str, search, replacement, scope)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.xregexp.index.replaceEach">
            function <span class="apidocSignatureSpan">xregexp.index.</span>replaceEach
            <span class="apidocSignatureSpan">(str, replacements)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.xregexp.index.split">
            function <span class="apidocSignatureSpan">xregexp.index.</span>split
            <span class="apidocSignatureSpan">(str, separator, limit)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.xregexp.index.test">
            function <span class="apidocSignatureSpan">xregexp.index.</span>test
            <span class="apidocSignatureSpan">(str, regex, pos, sticky)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.xregexp.index.uninstall">
            function <span class="apidocSignatureSpan">xregexp.index.</span>uninstall
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.xregexp.index.union">
            function <span class="apidocSignatureSpan">xregexp.index.</span>union
            <span class="apidocSignatureSpan">(patterns, flags, options)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">xregexp.index.</span>version</span>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.xregexp" id="apidoc.module.xregexp">module xregexp</a></h1>


    <h2>
        <a href="#apidoc.element.xregexp.xregexp" id="apidoc.element.xregexp.xregexp">
        function <span class="apidocSignatureSpan"></span>xregexp
        <span class="apidocSignatureSpan">(pattern, flags)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function XRegExp(pattern, flags) {
    if (XRegExp.isRegExp(pattern)) {
        if (flags !== undefined) {
            throw new TypeError(&#x27;Cannot supply flags when copying a RegExp&#x27;);
        }
        return copyRegex(pattern);
    }

    // Copy the argument behavior of `RegExp`
    pattern = pattern === undefined ? &#x27;&#x27; : String(pattern);
    flags = flags === undefined ? &#x27;&#x27; : String(flags);

    if (XRegExp.isInstalled(&#x27;astral&#x27;) &#x26;&#x26; flags.indexOf(&#x27;A&#x27;) === -1) {
        // This causes an error to be thrown if the Unicode Base addon is not available
        flags += &#x27;A&#x27;;
    }

    if (!patternCache[pattern]) {
        patternCache[pattern] = {};
    }

    if (!patternCache[pattern][flags]) {
        var context = {
            hasNamedCapture: false,
            captureNames: []
        };
        var scope = defaultScope;
        var output = &#x27;&#x27;;
        var pos = 0;
        var result;

        // Check for flag-related errors, and strip/apply flags in a leading mode modifier
        var applied = prepareFlags(pattern, flags);
        var appliedPattern = applied.pattern;
        var appliedFlags = applied.flags;

        // Use XRegExp&#x27;s tokens to translate the pattern to a native regex pattern.
        // `appliedPattern.length` may change on each iteration if tokens use `reparse`
        while (pos &#x3c; appliedPattern.length) {
            do {
                // Check for custom tokens at the current position
                result = runTokens(appliedPattern, appliedFlags, pos, scope, context);
                // If the matched token used the `reparse` option, splice its output into the
                // pattern before running tokens again at the same position
                if (result &#x26;&#x26; result.reparse) {
                    appliedPattern = appliedPattern.slice(0, pos) +
                        result.output +
                        appliedPattern.slice(pos + result.matchLength);
                }
            } while (result &#x26;&#x26; result.reparse);

            if (result) {
                output += result.output;
                pos += (result.matchLength || 1);
            } else {
                // Get the native token at the current position
                var token = XRegExp.exec(appliedPattern, nativeTokens[scope], pos, &#x27;sticky&#x27;)[0];
                output += token;
                pos += token.length;
                if (token === &#x27;[&#x27; &#x26;&#x26; scope === defaultScope) {
                    scope = classScope;
                } else if (token === &#x27;]&#x27; &#x26;&#x26; scope === classScope) {
                    scope = defaultScope;
                }
            }
        }

        patternCache[pattern][flags] = {
            // Use basic cleanup to collapse repeated empty groups like `(?:)(?:)` to `(?:)`. Empty
            // groups are sometimes inserted during regex transpilation in order to keep tokens
            // separated. However, more than one empty group in a row is never needed.
            pattern: nativ.replace.call(output, /(?:\(\?:\))+/g, &#x27;(?:)&#x27;),
            // Strip all but native flags
            flags: nativ.replace.call(appliedFlags, /[^gimuy]+/g, &#x27;&#x27;),
            // `context.captureNames` has an item for each capturing group, even if unnamed
            captures: context.hasNamedCapture ? context.captureNames : null
        };
    }

    var generated = patternCache[pattern][flags];
    return augment(
        new RegExp(generated.pattern, generated.flags),
        generated.captures,
        pattern,
        flags
    );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.xregexp._clipDuplicates" id="apidoc.element.xregexp._clipDuplicates">
        function <span class="apidocSignatureSpan">xregexp.</span>_clipDuplicates
        <span class="apidocSignatureSpan">(str)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function clipDuplicates(str) {
    return nativ.replace.call(str, /([\s\S])(?=[\s\S]*\1)/g, &#x27;&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// Used with `asXRegExp` calls for `pattern` and subpatterns in `subs`, to work around how
// some browsers convert `RegExp(&#x27;\n&#x27;)` to a regex that contains the literal characters `\`
// and `n`. See more details at &#x3c;https://github.com/slevithan/xregexp/pull/163&#x3e;.
var addFlagX = flags.indexOf(&#x27;x&#x27;) &#x3e; -1;
var inlineFlags = /^\(\?([\w$]+)\)/.exec(pattern);
// Add flags within a leading mode modifier to the overall pattern&#x27;s flags
if (inlineFlags) {
    flags = XRegExp.<span class="apidocCodeKeywordSpan">_clipDuplicates</span>(flags + inlineFlags[1]);
}

var data = {};
for (var p in subs) {
    if (subs.hasOwnProperty(p)) {
        // Passing to XRegExp enables extended syntax and ensures independent validity,
        // lest an unescaped `(`, `)`, `[`, or trailing `\` breaks the `(?:)` wrapper. For
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.xregexp._dec" id="apidoc.element.xregexp._dec">
        function <span class="apidocSignatureSpan">xregexp.</span>_dec
        <span class="apidocSignatureSpan">(hex)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function dec(hex) {
    return parseInt(hex, 16);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.xregexp._getUnicodeProperty" id="apidoc.element.xregexp._getUnicodeProperty">
        function <span class="apidocSignatureSpan">xregexp.</span>_getUnicodeProperty
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_getUnicodeProperty = function (name) {
    var slug = normalize(name);
    return unicode[slug];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.xregexp._hasNativeFlag" id="apidoc.element.xregexp._hasNativeFlag">
        function <span class="apidocSignatureSpan">xregexp.</span>_hasNativeFlag
        <span class="apidocSignatureSpan">(flag)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function hasNativeFlag(flag) {
    // Can&#x27;t check based on the presence of properties/getters since browsers might support such
    // properties even when they don&#x27;t support the corresponding flag in regex construction (tested
    // in Chrome 48, where `&#x27;unicode&#x27; in /x/` is true but trying to construct a regex with flag `u`
    // throws an error)
    var isSupported = true;
    try {
        // Can&#x27;t use regex literals for testing even in a `try` because regex literals with
        // unsupported flags cause a compilation error in IE
        new RegExp(&#x27;&#x27;, flag);
    } catch (exception) {
        isSupported = false;
    }
    return isSupported;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.xregexp._hex" id="apidoc.element.xregexp._hex">
        function <span class="apidocSignatureSpan">xregexp.</span>_hex
        <span class="apidocSignatureSpan">(dec)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function hex(dec) {
    return parseInt(dec, 10).toString(16);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.xregexp._pad4" id="apidoc.element.xregexp._pad4">
        function <span class="apidocSignatureSpan">xregexp.</span>_pad4
        <span class="apidocSignatureSpan">(str)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function pad4(str) {
    while (str.length &#x3c; 4) {
        str = &#x27;0&#x27; + str;
    }
    return str;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.xregexp.addToken" id="apidoc.element.xregexp.addToken">
        function <span class="apidocSignatureSpan">xregexp.</span>addToken
        <span class="apidocSignatureSpan">(regex, handler, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">addToken = function (regex, handler, options) {
    options = options || {};
    var optionalFlags = options.optionalFlags;
    var i;

    if (options.flag) {
        registerFlag(options.flag);
    }

    if (optionalFlags) {
        optionalFlags = nativ.split.call(optionalFlags, &#x27;&#x27;);
        for (i = 0; i &#x3c; optionalFlags.length; ++i) {
            registerFlag(optionalFlags[i]);
        }
    }

    // Add to the private list of syntax tokens
    tokens.push({
        regex: copyRegex(regex, {
            addG: true,
            addY: hasNativeY,
            isInternalOnly: true
        }),
        handler: handler,
        scope: options.scope || defaultScope,
        flag: options.flag,
        reparse: options.reparse,
        leadChar: options.leadChar
    });

    // Reset the pattern cache used by the `XRegExp` constructor, since the same pattern and flags
    // might now produce different results
    XRegExp.cache.flush(&#x27;patterns&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// ==--------------------------==
// Core functionality
// ==--------------------------==

/*
 * Add astral mode (flag A) and Unicode token syntax: `\p{..}`, `\P{..}`, `\p{^..}`, `\pC`.
 */
XRegExp.<span class="apidocCodeKeywordSpan">addToken</span>(
    // Use `*` instead of `+` to avoid capturing `^` as the token name in `\p{^}`
    /\\([pP])(?:{(\^?)([^}]*)}|([A-Za-z]))/,
    function(match, scope, flags) {
        var ERR_DOUBLE_NEG = &#x27;Invalid double negation &#x27;;
        var ERR_UNKNOWN_NAME = &#x27;Unknown Unicode token &#x27;;
        var ERR_UNKNOWN_REF = &#x27;Unicode token missing data &#x27;;
        var ERR_ASTRAL_ONLY = &#x27;Astral mode required for Unicode token &#x27;;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.xregexp.addUnicodeData" id="apidoc.element.xregexp.addUnicodeData">
        function <span class="apidocSignatureSpan">xregexp.</span>addUnicodeData
        <span class="apidocSignatureSpan">(data)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">addUnicodeData = function (data) {
    var ERR_NO_NAME = &#x27;Unicode token requires name&#x27;;
    var ERR_NO_DATA = &#x27;Unicode token has no character data &#x27;;
    var item;

    for (var i = 0; i &#x3c; data.length; ++i) {
        item = data[i];
        if (!item.name) {
            throw new Error(ERR_NO_NAME);
        }
        if (!(item.inverseOf || item.bmp || item.astral)) {
            throw new Error(ERR_NO_DATA + item.name);
        }
        unicode[normalize(item.name)] = item;
        if (item.alias) {
            unicode[normalize(item.alias)] = item;
        }
    }

    // Reset the pattern cache used by the `XRegExp` constructor, since the same pattern and
    // flags might now produce different results
    XRegExp.cache.flush(&#x27;patterns&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 *   escaped, apart from range-creating hyphens. The `astral` data can additionally use
 *   character classes and alternation, and should use surrogate pairs to represent astral code
 *   points. `inverseOf` can be used to avoid duplicating character data if a Unicode token is
 *   defined as the exact inverse of another token.
 * @example
 *
 * // Basic use
 * XRegExp.<span class="apidocCodeKeywordSpan">addUnicodeData</span>([{
 *   name: &#x27;XDigit&#x27;,
 *   alias: &#x27;Hexadecimal&#x27;,
 *   bmp: &#x27;0-9A-Fa-f&#x27;
 * }]);
 * XRegExp(&#x27;\\p{XDigit}:\\p{Hexadecimal}+&#x27;).test(&#x27;0:3D&#x27;); // -&#x3e; true
 */
XRegExp.addUnicodeData = function(data) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.xregexp.build" id="apidoc.element.xregexp.build">
        function <span class="apidocSignatureSpan">xregexp.</span>build
        <span class="apidocSignatureSpan">(pattern, subs, flags)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">build = function (pattern, subs, flags) {
    flags = flags || &#x27;&#x27;;
    // Used with `asXRegExp` calls for `pattern` and subpatterns in `subs`, to work around how
    // some browsers convert `RegExp(&#x27;\n&#x27;)` to a regex that contains the literal characters `\`
    // and `n`. See more details at &#x3c;https://github.com/slevithan/xregexp/pull/163&#x3e;.
    var addFlagX = flags.indexOf(&#x27;x&#x27;) &#x3e; -1;
    var inlineFlags = /^\(\?([\w$]+)\)/.exec(pattern);
    // Add flags within a leading mode modifier to the overall pattern&#x27;s flags
    if (inlineFlags) {
        flags = XRegExp._clipDuplicates(flags + inlineFlags[1]);
    }

    var data = {};
    for (var p in subs) {
        if (subs.hasOwnProperty(p)) {
            // Passing to XRegExp enables extended syntax and ensures independent validity,
            // lest an unescaped `(`, `)`, `[`, or trailing `\` breaks the `(?:)` wrapper. For
            // subpatterns provided as native regexes, it dies on octals and adds the property
            // used to hold extended regex instance data, for simplicity.
            var sub = asXRegExp(subs[p], addFlagX);
            data[p] = {
                // Deanchoring allows embedding independently useful anchored regexes. If you
                // really need to keep your anchors, double them (i.e., `^^...$$`).
                pattern: deanchor(sub.source),
                names: sub[REGEX_DATA].captureNames || []
            };
        }
    }

    // Passing to XRegExp dies on octals and ensures the outer pattern is independently valid;
    // helps keep this simple. Named captures will be put back.
    var patternAsRegex = asXRegExp(pattern, addFlagX);

    // &#x27;Caps&#x27; is short for &#x27;captures&#x27;
    var numCaps = 0;
    var numPriorCaps;
    var numOuterCaps = 0;
    var outerCapsMap = [0];
    var outerCapNames = patternAsRegex[REGEX_DATA].captureNames || [];
    var output = patternAsRegex.source.replace(parts, function($0, $1, $2, $3, $4) {
        var subName = $1 || $2;
        var capName;
        var intro;
        var localCapIndex;
        // Named subpattern
        if (subName) {
            if (!data.hasOwnProperty(subName)) {
                throw new ReferenceError(&#x27;Undefined property &#x27; + $0);
            }
            // Named subpattern was wrapped in a capturing group
            if ($1) {
                capName = outerCapNames[numOuterCaps];
                outerCapsMap[++numOuterCaps] = ++numCaps;
                // If it&#x27;s a named group, preserve the name. Otherwise, use the subpattern name
                // as the capture name
                intro = &#x27;(?&#x3c;&#x27; + (capName || subName) + &#x27;&#x3e;&#x27;;
            } else {
                intro = &#x27;(?:&#x27;;
            }
            numPriorCaps = numCaps;
            return intro + data[subName].pattern.replace(subParts, function(match, paren, backref) {
                // Capturing group
                if (paren) {
                    capName = data[subName].names[numCaps - numPriorCaps];
                    ++numCaps;
                    // If the current capture has a name, preserve the name
                    if (capName) {
                        return &#x27;(?&#x3c;&#x27; + capName + &#x27;&#x3e;&#x27;;
                    }
                // Backreference
                } else if (backref) {
                    localCapIndex = +backref - 1;
                    // Rewrite the backreference
                    return data[subName].names[localCapIndex] ?
                        // Need to preserve the backreference name in case using flag `n`
                        &#x27;\\k&#x3c;&#x27; + data[subName].names[localCapIndex] + &#x27;&#x3e;&#x27; :
                        &#x27;\\&#x27; + (+backref + numPriorCaps);
                }
                return match;
            }) + &#x27;)&#x27;;
        }
        // Capturing group
        if ($3) {
            capName = outerCapNames[numOuterCaps];
            outerCapsMap[++numOuterCaps] = ++numCaps;
            // If the current capture has a name, preserve the name
            if (capName) {
                return &#x27;(?&#x3c;&#x27; + capName + &#x27;&#x3e;&#x27; ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
XRegExp uses Unicode 9.0.0.

### XRegExp.build

Build regular expressions using named subpatterns, for readability and pattern reuse:

```js
var time = XRegExp.<span class="apidocCodeKeywordSpan">build</span>(&#x27;(?x)^ {{hours}} ({{minutes}}) $&#x27;, {
    hours: XRegExp.build(&#x27;{{h12}} : | {{h24}}&#x27;, {
        h12: /1[0-2]|0?[1-9]/,
        h24: /2[0-3]|[01][0-9]/
    }),
    minutes: /^[0-5][0-9]$/
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.xregexp.cache" id="apidoc.element.xregexp.cache">
        function <span class="apidocSignatureSpan">xregexp.</span>cache
        <span class="apidocSignatureSpan">(pattern, flags)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">cache = function (pattern, flags) {
    if (!regexCache[pattern]) {
        regexCache[pattern] = {};
    }
    return regexCache[pattern][flags] || (
        regexCache[pattern][flags] = XRegExp(pattern, flags)
    );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 *
 * @memberOf XRegExp
 * @param {String} pattern Regex pattern string.
 * @param {String} [flags] Any combination of XRegExp flags.
 * @returns {RegExp} Cached XRegExp object.
 * @example
 *
 * while (match = XRegExp.<span class="apidocCodeKeywordSpan">cache</span>(&#x27;.&#x27;, &#x27;gs&#x27;).exec(str)) {
 *   // The regex is compiled once only
 * }
 */
XRegExp.cache = function(pattern, flags) {
if (!regexCache[pattern]) {
    regexCache[pattern] = {};
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.xregexp.escape" id="apidoc.element.xregexp.escape">
        function <span class="apidocSignatureSpan">xregexp.</span>escape
        <span class="apidocSignatureSpan">(str)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">escape = function (str) {
    return nativ.replace.call(toObject(str), /[-\[\]{}()*+?.,\\^$|#\s]/g, &#x27;\\$&#x26;&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
left = XRegExp(left, basicFlags);
right = XRegExp(right, basicFlags);

if (escapeChar) {
    if (escapeChar.length &#x3e; 1) {
        throw new Error(&#x27;Cannot use more than one escape character&#x27;);
    }
    escapeChar = XRegExp.<span class="apidocCodeKeywordSpan">escape</span>(escapeChar);
    // Example of concatenated `esc` regex:
    // `escapeChar`: &#x27;%&#x27;
    // `left`: &#x27;&#x3c;&#x27;
    // `right`: &#x27;&#x3e;&#x27;
    // Regex is: /(?:%[\S\s]|(?:(?!&#x3c;|&#x3e;)[^%])+)+/
    esc = new RegExp(
        &#x27;(?:&#x27; + escapeChar + &#x27;[\\S\\s]|(?:(?!&#x27; +
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.xregexp.exec" id="apidoc.element.xregexp.exec">
        function <span class="apidocSignatureSpan">xregexp.</span>exec
        <span class="apidocSignatureSpan">(str, regex, pos, sticky)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">exec = function (str, regex, pos, sticky) {
    var cacheKey = &#x27;g&#x27;;
    var addY = false;
    var fakeY = false;
    var match;
    var r2;

    addY = hasNativeY &#x26;&#x26; !!(sticky || (regex.sticky &#x26;&#x26; sticky !== false));
    if (addY) {
        cacheKey += &#x27;y&#x27;;
    } else if (sticky) {
        // Simulate sticky matching by appending an empty capture to the original regex. The
        // resulting regex will succeed no matter what at the current index (set with `lastIndex`),
        // and will not search the rest of the subject string. We&#x27;ll know that the original regex
        // has failed if that last capture is `&#x27;&#x27;` rather than `undefined` (i.e., if that last
        // capture participated in the match).
        fakeY = true;
        cacheKey += &#x27;FakeY&#x27;;
    }

    regex[REGEX_DATA] = regex[REGEX_DATA] || {};

    // Shares cached copies with `XRegExp.match`/`replace`
    r2 = regex[REGEX_DATA][cacheKey] || (
        regex[REGEX_DATA][cacheKey] = copyRegex(regex, {
            addG: true,
            addY: addY,
            source: fakeY ? regex.source + &#x27;|()&#x27; : undefined,
            removeY: sticky === false,
            isInternalOnly: true
        })
    );

    pos = pos || 0;
    r2.lastIndex = pos;

    // Fixed `exec` required for `lastIndex` fix, named backreferences, etc.
    match = fixed.exec.call(r2, str);

    // Get rid of the capture added by the pseudo-sticky matcher if needed. An empty string means
    // the original regexp failed (see above).
    if (fakeY &#x26;&#x26; match &#x26;&#x26; match.pop() === &#x27;&#x27;) {
        match = null;
    }

    if (regex.global) {
        regex.lastIndex = match ? r2.lastIndex : 0;
    }

    return match;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
```js
// Using named capture and flag x (free-spacing and line comments)
var date = XRegExp(`(?&#x3c;year&#x3e;  [0-9]{4} ) -?  # year
                (?&#x3c;month&#x3e; [0-9]{2} ) -?  # month
                (?&#x3c;day&#x3e;   [0-9]{2} )     # day`, &#x27;x&#x27;);

// XRegExp.exec gives you named backreferences on the match result
var match = XRegExp.<span class="apidocCodeKeywordSpan">exec</span>(&#x27;2017-02-22&#x27;, date);
match.year; // -&#x3e; &#x27;2017&#x27;

// It also includes optional pos and sticky arguments
var pos = 3;
var result = [];
while (match = XRegExp.exec(&#x27;&#x3c;1&#x3e;&#x3c;2&#x3e;&#x3c;3&#x3e;&#x3c;4&#x3e;5&#x3c;6&#x3e;&#x27;, /&#x3c;(\d+)&#x3e;/,
pos, &#x27;sticky&#x27;)) {
result.push(match[1]);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.xregexp.forEach" id="apidoc.element.xregexp.forEach">
        function <span class="apidocSignatureSpan">xregexp.</span>forEach
        <span class="apidocSignatureSpan">(str, regex, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">forEach = function (str, regex, callback) {
    var pos = 0;
    var i = -1;
    var match;

    while ((match = XRegExp.exec(str, regex, pos))) {
        // Because `regex` is provided to `callback`, the function could use the deprecated/
        // nonstandard `RegExp.prototype.compile` to mutate the regex. However, since `XRegExp.exec`
        // doesn&#x27;t use `lastIndex` to set the search position, this can&#x27;t lead to an infinite loop,
        // at least. Actually, because of the way `XRegExp.exec` caches globalized versions of
        // regexes, mutating the regex will not have any effect on the iteration or matched strings,
        // which is a nice side effect that brings extra safety.
        callback(match, ++i, str, regex);

        pos = match.index + (match[0].length || 1);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// The only caveat is that named captures must be referenced using numbered
// backreferences if used with native methods
&#x27;2017-02-22&#x27;.replace(date, &#x27;$2/$3/$1&#x27;);
// -&#x3e; &#x27;02/22/2017&#x27;

// Use XRegExp.forEach to extract every other digit from a string
var evens = [];
XRegExp.<span class="apidocCodeKeywordSpan">forEach</span>(&#x27;1a2345&#x27;, /\d/, (match, i) =&#x3e; {
if (i % 2) evens.push(+match[0]);
});
// evens -&#x3e; [2, 4]

// Use XRegExp.matchChain to get numbers within &#x3c;b&#x3e; tags
XRegExp.matchChain(&#x27;1 &#x3c;b&#x3e;2&#x3c;/b&#x3e; 3 &#x3c;B&#x3e;4 \n 56&#x3c;/B&#x3e;&#x27;, [
XRegExp(&#x27;(?is)&#x3c;b&#x3e;.*?&#x3c;/b&#x3e;&#x27;),
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.xregexp.globalize" id="apidoc.element.xregexp.globalize">
        function <span class="apidocSignatureSpan">xregexp.</span>globalize
        <span class="apidocSignatureSpan">(regex)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">globalize = function (regex) {
    return copyRegex(regex, {addG: true});
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * regexes are not recompiled using XRegExp syntax.
 *
 * @memberOf XRegExp
 * @param {RegExp} regex Regex to globalize.
 * @returns {RegExp} Copy of the provided regex with flag `g` added.
 * @example
 *
 * var globalCopy = XRegExp.<span class="apidocCodeKeywordSpan">globalize</span>(/regex/);
 * globalCopy.global; // -&#x3e; true
 */
XRegExp.globalize = function(regex) {
    return copyRegex(regex, {addG: true});
};

/**
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.xregexp.index" id="apidoc.element.xregexp.index">
        function <span class="apidocSignatureSpan">xregexp.</span>index
        <span class="apidocSignatureSpan">(pattern, flags)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function XRegExp(pattern, flags) {
    if (XRegExp.isRegExp(pattern)) {
        if (flags !== undefined) {
            throw new TypeError(&#x27;Cannot supply flags when copying a RegExp&#x27;);
        }
        return copyRegex(pattern);
    }

    // Copy the argument behavior of `RegExp`
    pattern = pattern === undefined ? &#x27;&#x27; : String(pattern);
    flags = flags === undefined ? &#x27;&#x27; : String(flags);

    if (XRegExp.isInstalled(&#x27;astral&#x27;) &#x26;&#x26; flags.indexOf(&#x27;A&#x27;) === -1) {
        // This causes an error to be thrown if the Unicode Base addon is not available
        flags += &#x27;A&#x27;;
    }

    if (!patternCache[pattern]) {
        patternCache[pattern] = {};
    }

    if (!patternCache[pattern][flags]) {
        var context = {
            hasNamedCapture: false,
            captureNames: []
        };
        var scope = defaultScope;
        var output = &#x27;&#x27;;
        var pos = 0;
        var result;

        // Check for flag-related errors, and strip/apply flags in a leading mode modifier
        var applied = prepareFlags(pattern, flags);
        var appliedPattern = applied.pattern;
        var appliedFlags = applied.flags;

        // Use XRegExp&#x27;s tokens to translate the pattern to a native regex pattern.
        // `appliedPattern.length` may change on each iteration if tokens use `reparse`
        while (pos &#x3c; appliedPattern.length) {
            do {
                // Check for custom tokens at the current position
                result = runTokens(appliedPattern, appliedFlags, pos, scope, context);
                // If the matched token used the `reparse` option, splice its output into the
                // pattern before running tokens again at the same position
                if (result &#x26;&#x26; result.reparse) {
                    appliedPattern = appliedPattern.slice(0, pos) +
                        result.output +
                        appliedPattern.slice(pos + result.matchLength);
                }
            } while (result &#x26;&#x26; result.reparse);

            if (result) {
                output += result.output;
                pos += (result.matchLength || 1);
            } else {
                // Get the native token at the current position
                var token = XRegExp.exec(appliedPattern, nativeTokens[scope], pos, &#x27;sticky&#x27;)[0];
                output += token;
                pos += token.length;
                if (token === &#x27;[&#x27; &#x26;&#x26; scope === defaultScope) {
                    scope = classScope;
                } else if (token === &#x27;]&#x27; &#x26;&#x26; scope === classScope) {
                    scope = defaultScope;
                }
            }
        }

        patternCache[pattern][flags] = {
            // Use basic cleanup to collapse repeated empty groups like `(?:)(?:)` to `(?:)`. Empty
            // groups are sometimes inserted during regex transpilation in order to keep tokens
            // separated. However, more than one empty group in a row is never needed.
            pattern: nativ.replace.call(output, /(?:\(\?:\))+/g, &#x27;(?:)&#x27;),
            // Strip all but native flags
            flags: nativ.replace.call(appliedFlags, /[^gimuy]+/g, &#x27;&#x27;),
            // `context.captureNames` has an item for each capturing group, even if unnamed
            captures: context.hasNamedCapture ? context.captureNames : null
        };
    }

    var generated = patternCache[pattern][flags];
    return augment(
        new RegExp(generated.pattern, generated.flags),
        generated.captures,
        pattern,
        flags
    );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.xregexp.install" id="apidoc.element.xregexp.install">
        function <span class="apidocSignatureSpan">xregexp.</span>install
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">install = function (options) {
    options = prepareOptions(options);

    if (!features.astral &#x26;&#x26; options.astral) {
        setAstral(true);
    }

    if (!features.natives &#x26;&#x26; options.natives) {
        setNatives(true);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
unicodeWord.test(&#x27;العربية&#x27;); // -&#x3e; true

// Test some Unicode scripts
XRegExp(&#x27;^\\p{Hiragana}+$&#x27;).test(&#x27;ひらがな&#x27;); // -&#x3e; true
XRegExp(&#x27;^[\\p{Latin}\\p{Common}]+$&#x27;).test(&#x27;Über Café.&#x27;); // -&#x3e; true
```

By default, `\p{…}` and `\P{…}` support the Basic Multilingual Plane (i.e. code points up to `U+FFFF`). You can opt-in to full 21
-bit Unicode support (with code points up to `U+10FFFF`) on a per-regex basis by using flag `A`. This is called *astral mode*. You
 can automatically add flag `A` for all new regexes by running `XRegExp.<span class="apidocCodeKeywordSpan">install</span>(&#x27
;astral&#x27;)`. When in astral mode, `\p{…}` and `\P{…}` always match a full code point rather than a code unit, using surrogate pairs for code points above `U+FFFF`.

```js
// Using flag A to match astral code points
XRegExp(&#x27;^\\pS$&#x27;).test(&#x27;💩&#x27;); // -&#x3e; false
XRegExp(&#x27;^\\pS$&#x27;, &#x27;A&#x27;).test(&#x27;💩&#x27;); // -&#x3e; true
XRegExp(&#x27;(?A)^\\pS$&#x27;).test(&#x27;💩&#x27;); // -&#x3e; true
// Using surrogate pair U+D83D U+DCA9 to represent U+1F4A9 (pile of poo)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.xregexp.isInstalled" id="apidoc.element.xregexp.isInstalled">
        function <span class="apidocSignatureSpan">xregexp.</span>isInstalled
        <span class="apidocSignatureSpan">(feature)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isInstalled = function (feature) {
    return !!(features[feature]);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    return copyRegex(pattern);
}

// Copy the argument behavior of `RegExp`
pattern = pattern === undefined ? &#x27;&#x27; : String(pattern);
flags = flags === undefined ? &#x27;&#x27; : String(flags);

if (XRegExp.<span class="apidocCodeKeywordSpan">isInstalled</span>(&#x27;astral&#x27;) &#x26;&#x26; flags.indexOf(&#x27;A&#x27;) === -
1) {
    // This causes an error to be thrown if the Unicode Base addon is not available
    flags += &#x27;A&#x27;;
}

if (!patternCache[pattern]) {
    patternCache[pattern] = {};
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.xregexp.isRegExp" id="apidoc.element.xregexp.isRegExp">
        function <span class="apidocSignatureSpan">xregexp.</span>isRegExp
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isRegExp = function (value) {
    return toString.call(value) === &#x27;[object RegExp]&#x27;;
    //return isType(value, &#x27;RegExp&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @param {String|RegExp} value Value to convert.
 * @param {Boolean} [addFlagX] Whether to apply the `x` flag in cases when `value` is not
 *   already a regex generated by XRegExp
 * @returns {RegExp} XRegExp object with XRegExp syntax applied.
 */
function asXRegExp(value, addFlagX) {
    var flags = addFlagX ? &#x27;x&#x27; : &#x27;&#x27;;
    return XRegExp.<span class="apidocCodeKeywordSpan">isRegExp</span>(value) ?
        (value[REGEX_DATA] &#x26;&#x26; value[REGEX_DATA].captureNames ?
            // Don&#x27;t recompile, to preserve capture names
            value :
            // Recompile as XRegExp
            XRegExp(value.source, flags)
        ) :
        // Compile string as XRegExp
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.xregexp.match" id="apidoc.element.xregexp.match">
        function <span class="apidocSignatureSpan">xregexp.</span>match
        <span class="apidocSignatureSpan">(str, regex, scope)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">match = function (str, regex, scope) {
    var global = (regex.global &#x26;&#x26; scope !== &#x27;one&#x27;) || scope === &#x27;all&#x27;;
    var cacheKey = ((global ? &#x27;g&#x27; : &#x27;&#x27;) + (regex.sticky ? &#x27;y&#x27; : &#x27;&#x27;)) || &#x27;noGY&#x27;;
    var result;
    var r2;

    regex[REGEX_DATA] = regex[REGEX_DATA] || {};

    // Shares cached copies with `XRegExp.exec`/`replace`
    r2 = regex[REGEX_DATA][cacheKey] || (
        regex[REGEX_DATA][cacheKey] = copyRegex(regex, {
            addG: !!global,
            removeG: scope === &#x27;one&#x27;,
            isInternalOnly: true
        })
    );

    result = nativ.match.call(toObject(str), r2);

    if (regex.global) {
        regex.lastIndex = (
            (scope === &#x27;one&#x27; &#x26;&#x26; result) ?
                // Can&#x27;t use `r2.lastIndex` since `r2` is nonglobal in this case
                (result.index + result[0].length) : 0
        );
    }

    return global ? (result || []) : (result &#x26;&#x26; result[0]);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
*   return an array of all matched strings. If not explicitly specified and `regex` uses flag g,
*   `scope` is &#x27;all&#x27;.
* @returns {String|Array} In match-first mode: First match as a string, or `null`. In match-all
*   mode: Array of all matched strings, or an empty array.
* @example
*
* // Match first
* XRegExp.<span class="apidocCodeKeywordSpan">match</span>(&#x27;abc&#x27;, /\w/); // -&#x3e; &#x27;a&#x27;
* XRegExp.match(&#x27;abc&#x27;, /\w/g, &#x27;one&#x27;); // -&#x3e; &#x27;a&#x27;
* XRegExp.match(&#x27;abc&#x27;, /x/g, &#x27;one&#x27;); // -&#x3e; null
*
* // Match all
* XRegExp.match(&#x27;abc&#x27;, /\w/g); // -&#x3e; [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]
* XRegExp.match(&#x27;abc&#x27;, /\w/, &#x27;all&#x27;); // -&#x3e; [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]
* XRegExp.match(&#x27;abc&#x27;, /x/, &#x27;all&#x27;); // -&#x3e; []
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.xregexp.matchChain" id="apidoc.element.xregexp.matchChain">
        function <span class="apidocSignatureSpan">xregexp.</span>matchChain
        <span class="apidocSignatureSpan">(str, chain)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">matchChain = function (str, chain) {
    return (function recurseChain(values, level) {
        var item = chain[level].regex ? chain[level] : {regex: chain[level]};
        var matches = [];

        function addMatch(match) {
            if (item.backref) {
                // Safari 4.0.5 (but not 5.0.5+) inappropriately uses sparse arrays to hold the
                // `undefined`s for backreferences to nonparticipating capturing groups. In such
                // cases, a `hasOwnProperty` or `in` check on its own would inappropriately throw
                // the exception, so also check if the backreference is a number that is within the
                // bounds of the array.
                if (!(match.hasOwnProperty(item.backref) || +item.backref &#x3c; match.length)) {
                    throw new ReferenceError(&#x27;Backreference to undefined group: &#x27; + item.backref);
                }

                matches.push(match[item.backref] || &#x27;&#x27;);
            } else {
                matches.push(match[0]);
            }
        }

        for (var i = 0; i &#x3c; values.length; ++i) {
            XRegExp.forEach(values[i], item.regex, addMatch);
        }

        return ((level === chain.length - 1) || !matches.length) ?
            matches :
            recurseChain(matches, level + 1);
    }([str], 0));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var evens = [];
XRegExp.forEach(&#x27;1a2345&#x27;, /\d/, (match, i) =&#x3e; {
    if (i % 2) evens.push(+match[0]);
});
// evens -&#x3e; [2, 4]

// Use XRegExp.matchChain to get numbers within &#x3c;b&#x3e; tags
XRegExp.<span class="apidocCodeKeywordSpan">matchChain</span>(&#x27;1 &#x3c;b&#x3e;2&#x3c;/b&#x3e; 3 &#x3c;B&#x3e;4 \n 56&#x3c;/
B&#x3e;&#x27;, [
    XRegExp(&#x27;(?is)&#x3c;b&#x3e;.*?&#x3c;/b&#x3e;&#x27;),
    /\d+/
]);
// -&#x3e; [&#x27;2&#x27;, &#x27;4&#x27;, &#x27;56&#x27;]

// You can also pass forward and return specific backreferences
var html = &#x27;&#x3c;a href=&#x22;http://xregexp.com/&#x22;&#x3e;XRegExp&#x3c;/a&#x3e;&#x27; +
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.xregexp.matchRecursive" id="apidoc.element.xregexp.matchRecursive">
        function <span class="apidocSignatureSpan">xregexp.</span>matchRecursive
        <span class="apidocSignatureSpan">(str, left, right, flags, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">matchRecursive = function (str, left, right, flags, options) {
    flags = flags || &#x27;&#x27;;
    options = options || {};
    var global = flags.indexOf(&#x27;g&#x27;) &#x3e; -1;
    var sticky = flags.indexOf(&#x27;y&#x27;) &#x3e; -1;
    // Flag `y` is controlled internally
    var basicFlags = flags.replace(/y/g, &#x27;&#x27;);
    var escapeChar = options.escapeChar;
    var vN = options.valueNames;
    var output = [];
    var openTokens = 0;
    var delimStart = 0;
    var delimEnd = 0;
    var lastOuterEnd = 0;
    var outerStart;
    var innerStart;
    var leftMatch;
    var rightMatch;
    var esc;
    left = XRegExp(left, basicFlags);
    right = XRegExp(right, basicFlags);

    if (escapeChar) {
        if (escapeChar.length &#x3e; 1) {
            throw new Error(&#x27;Cannot use more than one escape character&#x27;);
        }
        escapeChar = XRegExp.escape(escapeChar);
        // Example of concatenated `esc` regex:
        // `escapeChar`: &#x27;%&#x27;
        // `left`: &#x27;&#x3c;&#x27;
        // `right`: &#x27;&#x3e;&#x27;
        // Regex is: /(?:%[\S\s]|(?:(?!&#x3c;|&#x3e;)[^%])+)+/
        esc = new RegExp(
            &#x27;(?:&#x27; + escapeChar + &#x27;[\\S\\s]|(?:(?!&#x27; +
                // Using `XRegExp.union` safely rewrites backreferences in `left` and `right`.
                // Intentionally not passing `basicFlags` to `XRegExp.union` since any syntax
                // transformation resulting from those flags was already applied to `left` and
                // `right` when they were passed through the XRegExp constructor above.
                XRegExp.union([left, right], &#x27;&#x27;, {conjunction: &#x27;or&#x27;}).source +
                &#x27;)[^&#x27; + escapeChar + &#x27;])+)+&#x27;,
            // Flags `gy` not needed here
            flags.replace(/[^imu]+/g, &#x27;&#x27;)
        );
    }

    while (true) {
        // If using an escape character, advance to the delimiter&#x27;s next starting position,
        // skipping any escaped characters in between
        if (escapeChar) {
            delimEnd += (XRegExp.exec(str, esc, delimEnd, &#x27;sticky&#x27;) || [&#x27;&#x27;])[0].length;
        }
        leftMatch = XRegExp.exec(str, left, delimEnd);
        rightMatch = XRegExp.exec(str, right, delimEnd);
        // Keep the leftmost match only
        if (leftMatch &#x26;&#x26; rightMatch) {
            if (leftMatch.index &#x3c;= rightMatch.index) {
                rightMatch = null;
            } else {
                leftMatch = null;
            }
        }
        // Paths (LM: leftMatch, RM: rightMatch, OT: openTokens):
        // LM | RM | OT | Result
        // 1  | 0  | 1  | loop
        // 1  | 0  | 0  | loop
        // 0  | 1  | 1  | loop
        // 0  | 1  | 0  | throw
        // 0  | 0  | 1  | throw
        // 0  | 0  | 0  | break
        // The paths above don&#x27;t include the sticky mode special case. The loop ends after the
        // first completed match if not `global`.
        if (leftMatch || rightMatch) {
            delimStart = (leftMatch || rightMatch).index;
            delimEnd = delimStart + (leftMatch || rightMatch)[0].length;
        } else if (!openTokens) {
            break;
        }
        if (sticky &#x26;&#x26; !openTokens &#x26;&#x26; delimStart &#x3e; lastOuterEnd) {
            break;
        }
        if (leftMatch) {
            if (!openTokens) {
                outerStart = delimStart;
                innerStart = delimEnd;
            }
            ++openTokens;
        } else if (rightMatch &#x26;&#x26; openTokens) {
            if (!--openTokens) {
                if (vN) {
                    if (vN[0] &#x26;&#x26; outerStart &#x3e; lastOuterEnd) {
                        output.push(row(vN[0], str.slice(lastOuterEnd, outerStart), lastOuterEnd, outerStart));
                    }
                    if (vN[1]) {
                        output.push(row(vN[1], str.slice(outerStart, innerStart), outerStart, innerStart));
                    }
                    if (vN[2]) {
                        output.push(row(vN[2], str.slice(innerStart, delimStart), innerStart, delimStart));
                    }
                    if (vN[3]) {
                        output.push(row(vN[3], str.slice(delimStart, d ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...

### XRegExp.matchRecursive

Match recursive constructs using XRegExp pattern strings as left and right delimiters:

```js
var str = &#x27;(t((e))s)t()(ing)&#x27;;
XRegExp.<span class="apidocCodeKeywordSpan">matchRecursive</span>(str, &#x27;\\(&#x27;, &#x27;\\)&#x27;, &#x27;g&#x27;);
// -&#x3e; [&#x27;t((e))s&#x27;, &#x27;&#x27;, &#x27;ing&#x27;]

// Extended information mode with valueNames
str = &#x27;Here is &#x3c;div&#x3e; &#x3c;div&#x3e;an&#x3c;/div&#x3e;&#x3c;/div&#x3e; example&#x27;;
XRegExp.matchRecursive(str, &#x27;&#x3c;div\\s*&#x3e;&#x27;, &#x27;&#x3c;/div&#x3e;&#x27;, &#x27;gi&#x27;, {
    valueNames: [&#x27;between&#x27;, &#x27;left&#x27;, &#x27;match&#x27;, &#x27;right&#x27;]
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.xregexp.replace" id="apidoc.element.xregexp.replace">
        function <span class="apidocSignatureSpan">xregexp.</span>replace
        <span class="apidocSignatureSpan">(str, search, replacement, scope)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">replace = function (str, search, replacement, scope) {
    var isRegex = XRegExp.isRegExp(search);
    var global = (search.global &#x26;&#x26; scope !== &#x27;one&#x27;) || scope === &#x27;all&#x27;;
    var cacheKey = ((global ? &#x27;g&#x27; : &#x27;&#x27;) + (search.sticky ? &#x27;y&#x27; : &#x27;&#x27;)) || &#x27;noGY&#x27;;
    var s2 = search;
    var result;

    if (isRegex) {
        search[REGEX_DATA] = search[REGEX_DATA] || {};

        // Shares cached copies with `XRegExp.exec`/`match`. Since a copy is used, `search`&#x27;s
        // `lastIndex` isn&#x27;t updated *during* replacement iterations
        s2 = search[REGEX_DATA][cacheKey] || (
            search[REGEX_DATA][cacheKey] = copyRegex(search, {
                addG: !!global,
                removeG: scope === &#x27;one&#x27;,
                isInternalOnly: true
            })
        );
    } else if (global) {
        s2 = new RegExp(XRegExp.escape(String(search)), &#x27;g&#x27;);
    }

    // Fixed `replace` required for named backreferences, etc.
    result = fixed.replace.call(toObject(str), s2, replacement);

    if (isRegex &#x26;&#x26; search.global) {
        // Fixes IE, Safari bug (last tested IE 9, Safari 5.1)
        search.lastIndex = 0;
    }

    return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
while (match = XRegExp.exec(&#x27;&#x3c;1&#x3e;&#x3c;2&#x3e;&#x3c;3&#x3e;&#x3c;4&#x3e;5&#x3c;6&#x3e;&#x27;, /&#x3c;(\d+)&#x3e;/,
pos, &#x27;sticky&#x27;)) {
    result.push(match[1]);
    pos = match.index + match[0].length;
}
// result -&#x3e; [&#x27;2&#x27;, &#x27;3&#x27;, &#x27;4&#x27;]

// XRegExp.replace allows named backreferences in replacements
XRegExp.<span class="apidocCodeKeywordSpan">replace</span>(&#x27;2017-02-22&#x27;, date, &#x27;${month}/${day}/${year}&#x27;);
// -&#x3e; &#x27;02/22/2017&#x27;
XRegExp.replace(&#x27;2017-02-22&#x27;, date, (match) =&#x3e; {
    return match.month + &#x27;/&#x27; + match.day + &#x27;/&#x27; + match.year;
});
// -&#x3e; &#x27;02/22/2017&#x27;

// XRegExps compile to RegExps and work perfectly with native methods
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.xregexp.replaceEach" id="apidoc.element.xregexp.replaceEach">
        function <span class="apidocSignatureSpan">xregexp.</span>replaceEach
        <span class="apidocSignatureSpan">(str, replacements)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">replaceEach = function (str, replacements) {
    var i;
    var r;

    for (i = 0; i &#x3c; replacements.length; ++i) {
        r = replacements[i];
        str = XRegExp.replace(str, r[0], r[1], r[2]);
    }

    return str;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
*
* @memberOf XRegExp
* @param {String} str String to search.
* @param {Array} replacements Array of replacement detail arrays.
* @returns {String} New string with all replacements.
* @example
*
* str = XRegExp.<span class="apidocCodeKeywordSpan">replaceEach</span>(str, [
*   [XRegExp(&#x27;(?&#x3c;name&#x3e;a)&#x27;), &#x27;z${name}&#x27;],
*   [/b/gi, &#x27;y&#x27;],
*   [/c/g, &#x27;x&#x27;, &#x27;one&#x27;], // scope &#x27;one&#x27; overrides /g
*   [/d/, &#x27;w&#x27;, &#x27;all&#x27;],  // scope &#x27;all&#x27; overrides lack of /g
*   [&#x27;e&#x27;, &#x27;v&#x27;, &#x27;all&#x27;],  // scope &#x27;all&#x27; allows replace-all for strings
*   [/f/g, function($0) {
*     return $0.toUpperCase();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.xregexp.split" id="apidoc.element.xregexp.split">
        function <span class="apidocSignatureSpan">xregexp.</span>split
        <span class="apidocSignatureSpan">(str, separator, limit)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">split = function (str, separator, limit) {
    return fixed.split.call(toObject(str), separator, limit);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
           // extensions exist on `regex.prototype` anyway
           regex[p] = XRegExp.prototype[p];
       }
   }

   regex[REGEX_DATA].source = xSource;
   // Emulate the ES6 `flags` prop by ensuring flags are in alphabetical order
   regex[REGEX_DATA].flags = xFlags ? xFlags.<span class="apidocCodeKeywordSpan">split</span>(&#x27;&#x27;).sort().join(&#x27;&#
x27;) : xFlags;

   return regex;
}

/**
* Removes any duplicate characters from the provided string.
*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.xregexp.test" id="apidoc.element.xregexp.test">
        function <span class="apidocSignatureSpan">xregexp.</span>test
        <span class="apidocSignatureSpan">(str, regex, pos, sticky)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">test = function (str, regex, pos, sticky) {
    // Do this the easy way :-)
    return !!XRegExp.exec(str, regex, pos, sticky);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// -&#x3e; &#x27;02/22/2017&#x27;
XRegExp.replace(&#x27;2017-02-22&#x27;, date, (match) =&#x3e; {
    return match.month + &#x27;/&#x27; + match.day + &#x27;/&#x27; + match.year;
});
// -&#x3e; &#x27;02/22/2017&#x27;

// XRegExps compile to RegExps and work perfectly with native methods
date.<span class="apidocCodeKeywordSpan">test</span>(&#x27;2017-02-22&#x27;);
// -&#x3e; true

// The only caveat is that named captures must be referenced using numbered
// backreferences if used with native methods
&#x27;2017-02-22&#x27;.replace(date, &#x27;$2/$3/$1&#x27;);
// -&#x3e; &#x27;02/22/2017&#x27;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.xregexp.uninstall" id="apidoc.element.xregexp.uninstall">
        function <span class="apidocSignatureSpan">xregexp.</span>uninstall
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">uninstall = function (options) {
    options = prepareOptions(options);

    if (features.astral &#x26;&#x26; options.astral) {
        setAstral(false);
    }

    if (features.natives &#x26;&#x26; options.natives) {
        setNatives(false);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* uninstalled, so this is used to undo the actions of `XRegExp.install`.
*
* @memberOf XRegExp
* @param {Object|String} options Options object or string.
* @example
*
* // With an options object
* XRegExp.<span class="apidocCodeKeywordSpan">uninstall</span>({
*   // Disables support for astral code points in Unicode addons
*   astral: true,
*
*   // DEPRECATED: Restores native regex methods
*   natives: true
* });
*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.xregexp.union" id="apidoc.element.xregexp.union">
        function <span class="apidocSignatureSpan">xregexp.</span>union
        <span class="apidocSignatureSpan">(patterns, flags, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">union = function (patterns, flags, options) {
    options = options || {};
    var conjunction = options.conjunction || &#x27;or&#x27;;
    var numCaptures = 0;
    var numPriorCaptures;
    var captureNames;

    function rewrite(match, paren, backref) {
        var name = captureNames[numCaptures - numPriorCaptures];

        // Capturing group
        if (paren) {
            ++numCaptures;
            // If the current capture has a name, preserve the name
            if (name) {
                return &#x27;(?&#x3c;&#x27; + name + &#x27;&#x3e;&#x27;;
            }
        // Backreference
        } else if (backref) {
            // Rewrite the backreference
            return &#x27;\\&#x27; + (+backref + numPriorCaptures);
        }

        return match;
    }

    if (!(isType(patterns, &#x27;Array&#x27;) &#x26;&#x26; patterns.length)) {
        throw new TypeError(&#x27;Must provide a nonempty array of patterns to merge&#x27;);
    }

    var parts = /(\()(?!\?)|\\([1-9]\d*)|\\[\s\S]|\[(?:[^\\\]]|\\[\s\S])*\]/g;
    var output = [];
    var pattern;
    for (var i = 0; i &#x3c; patterns.length; ++i) {
        pattern = patterns[i];

        if (XRegExp.isRegExp(pattern)) {
            numPriorCaptures = numCaptures;
            captureNames = (pattern[REGEX_DATA] &#x26;&#x26; pattern[REGEX_DATA].captureNames) || [];

            // Rewrite backreferences. Passing to XRegExp dies on octals and ensures patterns are
            // independently valid; helps keep this simple. Named captures are put back
            output.push(nativ.replace.call(XRegExp(pattern.source).source, parts, rewrite));
        } else {
            output.push(XRegExp.escape(pattern));
        }
    }

    var separator = conjunction === &#x27;none&#x27; ? &#x27;&#x27; : &#x27;|&#x27;;
    return XRegExp(output.join(separator), flags);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
XRegExp.matchChain(html, [
    {regex: /&#x3c;a href=&#x22;([^&#x22;]+)&#x22;&#x3e;/i, backref: 1},
    {regex: XRegExp(&#x27;(?i)^https?://(?&#x3c;domain&#x3e;[^/?#]+)&#x27;), backref: &#x27;domain&#x27;}
]);
// -&#x3e; [&#x27;xregexp.com&#x27;, &#x27;www.google.com&#x27;]

// Merge strings and regexes into a single pattern with updated backreferences
XRegExp.<span class="apidocCodeKeywordSpan">union</span>([&#x27;a+b*c&#x27;, /(dog)\1/, /(cat)\1/], &#x27;i&#x27;, {conjunction: &#
x27;or&#x27;});
// -&#x3e; /a\+b\*c|(dog)\1|(cat)\2/i
```

These examples give the flavor of what&#x27;s possible, but XRegExp has more syntax, flags, methods, options, and browser fixes
that aren&#x27;t shown here. You can also augment XRegExp&#x27;s regular expression syntax with addons (see below) or write your
 own. See [xregexp.com](http://xregexp.com/) for details.

## Addons
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.xregexp.cache" id="apidoc.module.xregexp.cache">module xregexp.cache</a></h1>


    <h2>
        <a href="#apidoc.element.xregexp.cache.cache" id="apidoc.element.xregexp.cache.cache">
        function <span class="apidocSignatureSpan">xregexp.</span>cache
        <span class="apidocSignatureSpan">(pattern, flags)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">cache = function (pattern, flags) {
    if (!regexCache[pattern]) {
        regexCache[pattern] = {};
    }
    return regexCache[pattern][flags] || (
        regexCache[pattern][flags] = XRegExp(pattern, flags)
    );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 *
 * @memberOf XRegExp
 * @param {String} pattern Regex pattern string.
 * @param {String} [flags] Any combination of XRegExp flags.
 * @returns {RegExp} Cached XRegExp object.
 * @example
 *
 * while (match = XRegExp.<span class="apidocCodeKeywordSpan">cache</span>(&#x27;.&#x27;, &#x27;gs&#x27;).exec(str)) {
 *   // The regex is compiled once only
 * }
 */
XRegExp.cache = function(pattern, flags) {
if (!regexCache[pattern]) {
    regexCache[pattern] = {};
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.xregexp.cache.flush" id="apidoc.element.xregexp.cache.flush">
        function <span class="apidocSignatureSpan">xregexp.cache.</span>flush
        <span class="apidocSignatureSpan">(cacheName)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">flush = function (cacheName) {
    if (cacheName === &#x27;patterns&#x27;) {
        // Flush the pattern cache used by the `XRegExp` constructor
        patternCache = {};
    } else {
        // Flush the regex cache populated by `XRegExp.cache`
        regexCache = {};
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        if (item.alias) {
            unicode[normalize(item.alias)] = item;
        }
    }

    // Reset the pattern cache used by the `XRegExp` constructor, since the same pattern and
    // flags might now produce different results
    XRegExp.cache.<span class="apidocCodeKeywordSpan">flush</span>(&#x27;patterns&#x27;);
};

/**
 * @ignore
 *
 * Return a reference to the internal Unicode definition structure for the given Unicode
 * Property if the given name is a legal Unicode Property for use in XRegExp `\p` or `\P` regex
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.xregexp.index" id="apidoc.module.xregexp.index">module xregexp.index</a></h1>


    <h2>
        <a href="#apidoc.element.xregexp.index.index" id="apidoc.element.xregexp.index.index">
        function <span class="apidocSignatureSpan">xregexp.</span>index
        <span class="apidocSignatureSpan">(pattern, flags)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function XRegExp(pattern, flags) {
    if (XRegExp.isRegExp(pattern)) {
        if (flags !== undefined) {
            throw new TypeError(&#x27;Cannot supply flags when copying a RegExp&#x27;);
        }
        return copyRegex(pattern);
    }

    // Copy the argument behavior of `RegExp`
    pattern = pattern === undefined ? &#x27;&#x27; : String(pattern);
    flags = flags === undefined ? &#x27;&#x27; : String(flags);

    if (XRegExp.isInstalled(&#x27;astral&#x27;) &#x26;&#x26; flags.indexOf(&#x27;A&#x27;) === -1) {
        // This causes an error to be thrown if the Unicode Base addon is not available
        flags += &#x27;A&#x27;;
    }

    if (!patternCache[pattern]) {
        patternCache[pattern] = {};
    }

    if (!patternCache[pattern][flags]) {
        var context = {
            hasNamedCapture: false,
            captureNames: []
        };
        var scope = defaultScope;
        var output = &#x27;&#x27;;
        var pos = 0;
        var result;

        // Check for flag-related errors, and strip/apply flags in a leading mode modifier
        var applied = prepareFlags(pattern, flags);
        var appliedPattern = applied.pattern;
        var appliedFlags = applied.flags;

        // Use XRegExp&#x27;s tokens to translate the pattern to a native regex pattern.
        // `appliedPattern.length` may change on each iteration if tokens use `reparse`
        while (pos &#x3c; appliedPattern.length) {
            do {
                // Check for custom tokens at the current position
                result = runTokens(appliedPattern, appliedFlags, pos, scope, context);
                // If the matched token used the `reparse` option, splice its output into the
                // pattern before running tokens again at the same position
                if (result &#x26;&#x26; result.reparse) {
                    appliedPattern = appliedPattern.slice(0, pos) +
                        result.output +
                        appliedPattern.slice(pos + result.matchLength);
                }
            } while (result &#x26;&#x26; result.reparse);

            if (result) {
                output += result.output;
                pos += (result.matchLength || 1);
            } else {
                // Get the native token at the current position
                var token = XRegExp.exec(appliedPattern, nativeTokens[scope], pos, &#x27;sticky&#x27;)[0];
                output += token;
                pos += token.length;
                if (token === &#x27;[&#x27; &#x26;&#x26; scope === defaultScope) {
                    scope = classScope;
                } else if (token === &#x27;]&#x27; &#x26;&#x26; scope === classScope) {
                    scope = defaultScope;
                }
            }
        }

        patternCache[pattern][flags] = {
            // Use basic cleanup to collapse repeated empty groups like `(?:)(?:)` to `(?:)`. Empty
            // groups are sometimes inserted during regex transpilation in order to keep tokens
            // separated. However, more than one empty group in a row is never needed.
            pattern: nativ.replace.call(output, /(?:\(\?:\))+/g, &#x27;(?:)&#x27;),
            // Strip all but native flags
            flags: nativ.replace.call(appliedFlags, /[^gimuy]+/g, &#x27;&#x27;),
            // `context.captureNames` has an item for each capturing group, even if unnamed
            captures: context.hasNamedCapture ? context.captureNames : null
        };
    }

    var generated = patternCache[pattern][flags];
    return augment(
        new RegExp(generated.pattern, generated.flags),
        generated.captures,
        pattern,
        flags
    );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.xregexp.index._clipDuplicates" id="apidoc.element.xregexp.index._clipDuplicates">
        function <span class="apidocSignatureSpan">xregexp.index.</span>_clipDuplicates
        <span class="apidocSignatureSpan">(str)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function clipDuplicates(str) {
    return nativ.replace.call(str, /([\s\S])(?=[\s\S]*\1)/g, &#x27;&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// Used with `asXRegExp` calls for `pattern` and subpatterns in `subs`, to work around how
// some browsers convert `RegExp(&#x27;\n&#x27;)` to a regex that contains the literal characters `\`
// and `n`. See more details at &#x3c;https://github.com/slevithan/xregexp/pull/163&#x3e;.
var addFlagX = flags.indexOf(&#x27;x&#x27;) &#x3e; -1;
var inlineFlags = /^\(\?([\w$]+)\)/.exec(pattern);
// Add flags within a leading mode modifier to the overall pattern&#x27;s flags
if (inlineFlags) {
    flags = XRegExp.<span class="apidocCodeKeywordSpan">_clipDuplicates</span>(flags + inlineFlags[1]);
}

var data = {};
for (var p in subs) {
    if (subs.hasOwnProperty(p)) {
        // Passing to XRegExp enables extended syntax and ensures independent validity,
        // lest an unescaped `(`, `)`, `[`, or trailing `\` breaks the `(?:)` wrapper. For
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.xregexp.index._dec" id="apidoc.element.xregexp.index._dec">
        function <span class="apidocSignatureSpan">xregexp.index.</span>_dec
        <span class="apidocSignatureSpan">(hex)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function dec(hex) {
    return parseInt(hex, 16);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.xregexp.index._getUnicodeProperty" id="apidoc.element.xregexp.index._getUnicodeProperty">
        function <span class="apidocSignatureSpan">xregexp.index.</span>_getUnicodeProperty
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_getUnicodeProperty = function (name) {
    var slug = normalize(name);
    return unicode[slug];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.xregexp.index._hasNativeFlag" id="apidoc.element.xregexp.index._hasNativeFlag">
        function <span class="apidocSignatureSpan">xregexp.index.</span>_hasNativeFlag
        <span class="apidocSignatureSpan">(flag)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function hasNativeFlag(flag) {
    // Can&#x27;t check based on the presence of properties/getters since browsers might support such
    // properties even when they don&#x27;t support the corresponding flag in regex construction (tested
    // in Chrome 48, where `&#x27;unicode&#x27; in /x/` is true but trying to construct a regex with flag `u`
    // throws an error)
    var isSupported = true;
    try {
        // Can&#x27;t use regex literals for testing even in a `try` because regex literals with
        // unsupported flags cause a compilation error in IE
        new RegExp(&#x27;&#x27;, flag);
    } catch (exception) {
        isSupported = false;
    }
    return isSupported;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.xregexp.index._hex" id="apidoc.element.xregexp.index._hex">
        function <span class="apidocSignatureSpan">xregexp.index.</span>_hex
        <span class="apidocSignatureSpan">(dec)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function hex(dec) {
    return parseInt(dec, 10).toString(16);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.xregexp.index._pad4" id="apidoc.element.xregexp.index._pad4">
        function <span class="apidocSignatureSpan">xregexp.index.</span>_pad4
        <span class="apidocSignatureSpan">(str)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function pad4(str) {
    while (str.length &#x3c; 4) {
        str = &#x27;0&#x27; + str;
    }
    return str;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.xregexp.index.addToken" id="apidoc.element.xregexp.index.addToken">
        function <span class="apidocSignatureSpan">xregexp.index.</span>addToken
        <span class="apidocSignatureSpan">(regex, handler, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">addToken = function (regex, handler, options) {
    options = options || {};
    var optionalFlags = options.optionalFlags;
    var i;

    if (options.flag) {
        registerFlag(options.flag);
    }

    if (optionalFlags) {
        optionalFlags = nativ.split.call(optionalFlags, &#x27;&#x27;);
        for (i = 0; i &#x3c; optionalFlags.length; ++i) {
            registerFlag(optionalFlags[i]);
        }
    }

    // Add to the private list of syntax tokens
    tokens.push({
        regex: copyRegex(regex, {
            addG: true,
            addY: hasNativeY,
            isInternalOnly: true
        }),
        handler: handler,
        scope: options.scope || defaultScope,
        flag: options.flag,
        reparse: options.reparse,
        leadChar: options.leadChar
    });

    // Reset the pattern cache used by the `XRegExp` constructor, since the same pattern and flags
    // might now produce different results
    XRegExp.cache.flush(&#x27;patterns&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// ==--------------------------==
// Core functionality
// ==--------------------------==

/*
 * Add astral mode (flag A) and Unicode token syntax: `\p{..}`, `\P{..}`, `\p{^..}`, `\pC`.
 */
XRegExp.<span class="apidocCodeKeywordSpan">addToken</span>(
    // Use `*` instead of `+` to avoid capturing `^` as the token name in `\p{^}`
    /\\([pP])(?:{(\^?)([^}]*)}|([A-Za-z]))/,
    function(match, scope, flags) {
        var ERR_DOUBLE_NEG = &#x27;Invalid double negation &#x27;;
        var ERR_UNKNOWN_NAME = &#x27;Unknown Unicode token &#x27;;
        var ERR_UNKNOWN_REF = &#x27;Unicode token missing data &#x27;;
        var ERR_ASTRAL_ONLY = &#x27;Astral mode required for Unicode token &#x27;;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.xregexp.index.addUnicodeData" id="apidoc.element.xregexp.index.addUnicodeData">
        function <span class="apidocSignatureSpan">xregexp.index.</span>addUnicodeData
        <span class="apidocSignatureSpan">(data)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">addUnicodeData = function (data) {
    var ERR_NO_NAME = &#x27;Unicode token requires name&#x27;;
    var ERR_NO_DATA = &#x27;Unicode token has no character data &#x27;;
    var item;

    for (var i = 0; i &#x3c; data.length; ++i) {
        item = data[i];
        if (!item.name) {
            throw new Error(ERR_NO_NAME);
        }
        if (!(item.inverseOf || item.bmp || item.astral)) {
            throw new Error(ERR_NO_DATA + item.name);
        }
        unicode[normalize(item.name)] = item;
        if (item.alias) {
            unicode[normalize(item.alias)] = item;
        }
    }

    // Reset the pattern cache used by the `XRegExp` constructor, since the same pattern and
    // flags might now produce different results
    XRegExp.cache.flush(&#x27;patterns&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 *   escaped, apart from range-creating hyphens. The `astral` data can additionally use
 *   character classes and alternation, and should use surrogate pairs to represent astral code
 *   points. `inverseOf` can be used to avoid duplicating character data if a Unicode token is
 *   defined as the exact inverse of another token.
 * @example
 *
 * // Basic use
 * XRegExp.<span class="apidocCodeKeywordSpan">addUnicodeData</span>([{
 *   name: &#x27;XDigit&#x27;,
 *   alias: &#x27;Hexadecimal&#x27;,
 *   bmp: &#x27;0-9A-Fa-f&#x27;
 * }]);
 * XRegExp(&#x27;\\p{XDigit}:\\p{Hexadecimal}+&#x27;).test(&#x27;0:3D&#x27;); // -&#x3e; true
 */
XRegExp.addUnicodeData = function(data) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.xregexp.index.build" id="apidoc.element.xregexp.index.build">
        function <span class="apidocSignatureSpan">xregexp.index.</span>build
        <span class="apidocSignatureSpan">(pattern, subs, flags)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">build = function (pattern, subs, flags) {
    flags = flags || &#x27;&#x27;;
    // Used with `asXRegExp` calls for `pattern` and subpatterns in `subs`, to work around how
    // some browsers convert `RegExp(&#x27;\n&#x27;)` to a regex that contains the literal characters `\`
    // and `n`. See more details at &#x3c;https://github.com/slevithan/xregexp/pull/163&#x3e;.
    var addFlagX = flags.indexOf(&#x27;x&#x27;) &#x3e; -1;
    var inlineFlags = /^\(\?([\w$]+)\)/.exec(pattern);
    // Add flags within a leading mode modifier to the overall pattern&#x27;s flags
    if (inlineFlags) {
        flags = XRegExp._clipDuplicates(flags + inlineFlags[1]);
    }

    var data = {};
    for (var p in subs) {
        if (subs.hasOwnProperty(p)) {
            // Passing to XRegExp enables extended syntax and ensures independent validity,
            // lest an unescaped `(`, `)`, `[`, or trailing `\` breaks the `(?:)` wrapper. For
            // subpatterns provided as native regexes, it dies on octals and adds the property
            // used to hold extended regex instance data, for simplicity.
            var sub = asXRegExp(subs[p], addFlagX);
            data[p] = {
                // Deanchoring allows embedding independently useful anchored regexes. If you
                // really need to keep your anchors, double them (i.e., `^^...$$`).
                pattern: deanchor(sub.source),
                names: sub[REGEX_DATA].captureNames || []
            };
        }
    }

    // Passing to XRegExp dies on octals and ensures the outer pattern is independently valid;
    // helps keep this simple. Named captures will be put back.
    var patternAsRegex = asXRegExp(pattern, addFlagX);

    // &#x27;Caps&#x27; is short for &#x27;captures&#x27;
    var numCaps = 0;
    var numPriorCaps;
    var numOuterCaps = 0;
    var outerCapsMap = [0];
    var outerCapNames = patternAsRegex[REGEX_DATA].captureNames || [];
    var output = patternAsRegex.source.replace(parts, function($0, $1, $2, $3, $4) {
        var subName = $1 || $2;
        var capName;
        var intro;
        var localCapIndex;
        // Named subpattern
        if (subName) {
            if (!data.hasOwnProperty(subName)) {
                throw new ReferenceError(&#x27;Undefined property &#x27; + $0);
            }
            // Named subpattern was wrapped in a capturing group
            if ($1) {
                capName = outerCapNames[numOuterCaps];
                outerCapsMap[++numOuterCaps] = ++numCaps;
                // If it&#x27;s a named group, preserve the name. Otherwise, use the subpattern name
                // as the capture name
                intro = &#x27;(?&#x3c;&#x27; + (capName || subName) + &#x27;&#x3e;&#x27;;
            } else {
                intro = &#x27;(?:&#x27;;
            }
            numPriorCaps = numCaps;
            return intro + data[subName].pattern.replace(subParts, function(match, paren, backref) {
                // Capturing group
                if (paren) {
                    capName = data[subName].names[numCaps - numPriorCaps];
                    ++numCaps;
                    // If the current capture has a name, preserve the name
                    if (capName) {
                        return &#x27;(?&#x3c;&#x27; + capName + &#x27;&#x3e;&#x27;;
                    }
                // Backreference
                } else if (backref) {
                    localCapIndex = +backref - 1;
                    // Rewrite the backreference
                    return data[subName].names[localCapIndex] ?
                        // Need to preserve the backreference name in case using flag `n`
                        &#x27;\\k&#x3c;&#x27; + data[subName].names[localCapIndex] + &#x27;&#x3e;&#x27; :
                        &#x27;\\&#x27; + (+backref + numPriorCaps);
                }
                return match;
            }) + &#x27;)&#x27;;
        }
        // Capturing group
        if ($3) {
            capName = outerCapNames[numOuterCaps];
            outerCapsMap[++numOuterCaps] = ++numCaps;
            // If the current capture has a name, preserve the name
            if (capName) {
                return &#x27;(?&#x3c;&#x27; + capName + &#x27;&#x3e;&#x27; ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
XRegExp uses Unicode 9.0.0.

### XRegExp.build

Build regular expressions using named subpatterns, for readability and pattern reuse:

```js
var time = XRegExp.<span class="apidocCodeKeywordSpan">build</span>(&#x27;(?x)^ {{hours}} ({{minutes}}) $&#x27;, {
    hours: XRegExp.build(&#x27;{{h12}} : | {{h24}}&#x27;, {
        h12: /1[0-2]|0?[1-9]/,
        h24: /2[0-3]|[01][0-9]/
    }),
    minutes: /^[0-5][0-9]$/
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.xregexp.index.cache" id="apidoc.element.xregexp.index.cache">
        function <span class="apidocSignatureSpan">xregexp.index.</span>cache
        <span class="apidocSignatureSpan">(pattern, flags)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">cache = function (pattern, flags) {
    if (!regexCache[pattern]) {
        regexCache[pattern] = {};
    }
    return regexCache[pattern][flags] || (
        regexCache[pattern][flags] = XRegExp(pattern, flags)
    );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 *
 * @memberOf XRegExp
 * @param {String} pattern Regex pattern string.
 * @param {String} [flags] Any combination of XRegExp flags.
 * @returns {RegExp} Cached XRegExp object.
 * @example
 *
 * while (match = XRegExp.<span class="apidocCodeKeywordSpan">cache</span>(&#x27;.&#x27;, &#x27;gs&#x27;).exec(str)) {
 *   // The regex is compiled once only
 * }
 */
XRegExp.cache = function(pattern, flags) {
if (!regexCache[pattern]) {
    regexCache[pattern] = {};
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.xregexp.index.escape" id="apidoc.element.xregexp.index.escape">
        function <span class="apidocSignatureSpan">xregexp.index.</span>escape
        <span class="apidocSignatureSpan">(str)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">escape = function (str) {
    return nativ.replace.call(toObject(str), /[-\[\]{}()*+?.,\\^$|#\s]/g, &#x27;\\$&#x26;&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
left = XRegExp(left, basicFlags);
right = XRegExp(right, basicFlags);

if (escapeChar) {
    if (escapeChar.length &#x3e; 1) {
        throw new Error(&#x27;Cannot use more than one escape character&#x27;);
    }
    escapeChar = XRegExp.<span class="apidocCodeKeywordSpan">escape</span>(escapeChar);
    // Example of concatenated `esc` regex:
    // `escapeChar`: &#x27;%&#x27;
    // `left`: &#x27;&#x3c;&#x27;
    // `right`: &#x27;&#x3e;&#x27;
    // Regex is: /(?:%[\S\s]|(?:(?!&#x3c;|&#x3e;)[^%])+)+/
    esc = new RegExp(
        &#x27;(?:&#x27; + escapeChar + &#x27;[\\S\\s]|(?:(?!&#x27; +
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.xregexp.index.exec" id="apidoc.element.xregexp.index.exec">
        function <span class="apidocSignatureSpan">xregexp.index.</span>exec
        <span class="apidocSignatureSpan">(str, regex, pos, sticky)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">exec = function (str, regex, pos, sticky) {
    var cacheKey = &#x27;g&#x27;;
    var addY = false;
    var fakeY = false;
    var match;
    var r2;

    addY = hasNativeY &#x26;&#x26; !!(sticky || (regex.sticky &#x26;&#x26; sticky !== false));
    if (addY) {
        cacheKey += &#x27;y&#x27;;
    } else if (sticky) {
        // Simulate sticky matching by appending an empty capture to the original regex. The
        // resulting regex will succeed no matter what at the current index (set with `lastIndex`),
        // and will not search the rest of the subject string. We&#x27;ll know that the original regex
        // has failed if that last capture is `&#x27;&#x27;` rather than `undefined` (i.e., if that last
        // capture participated in the match).
        fakeY = true;
        cacheKey += &#x27;FakeY&#x27;;
    }

    regex[REGEX_DATA] = regex[REGEX_DATA] || {};

    // Shares cached copies with `XRegExp.match`/`replace`
    r2 = regex[REGEX_DATA][cacheKey] || (
        regex[REGEX_DATA][cacheKey] = copyRegex(regex, {
            addG: true,
            addY: addY,
            source: fakeY ? regex.source + &#x27;|()&#x27; : undefined,
            removeY: sticky === false,
            isInternalOnly: true
        })
    );

    pos = pos || 0;
    r2.lastIndex = pos;

    // Fixed `exec` required for `lastIndex` fix, named backreferences, etc.
    match = fixed.exec.call(r2, str);

    // Get rid of the capture added by the pseudo-sticky matcher if needed. An empty string means
    // the original regexp failed (see above).
    if (fakeY &#x26;&#x26; match &#x26;&#x26; match.pop() === &#x27;&#x27;) {
        match = null;
    }

    if (regex.global) {
        regex.lastIndex = match ? r2.lastIndex : 0;
    }

    return match;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
```js
// Using named capture and flag x (free-spacing and line comments)
var date = XRegExp(`(?&#x3c;year&#x3e;  [0-9]{4} ) -?  # year
                (?&#x3c;month&#x3e; [0-9]{2} ) -?  # month
                (?&#x3c;day&#x3e;   [0-9]{2} )     # day`, &#x27;x&#x27;);

// XRegExp.exec gives you named backreferences on the match result
var match = XRegExp.<span class="apidocCodeKeywordSpan">exec</span>(&#x27;2017-02-22&#x27;, date);
match.year; // -&#x3e; &#x27;2017&#x27;

// It also includes optional pos and sticky arguments
var pos = 3;
var result = [];
while (match = XRegExp.exec(&#x27;&#x3c;1&#x3e;&#x3c;2&#x3e;&#x3c;3&#x3e;&#x3c;4&#x3e;5&#x3c;6&#x3e;&#x27;, /&#x3c;(\d+)&#x3e;/,
pos, &#x27;sticky&#x27;)) {
result.push(match[1]);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.xregexp.index.forEach" id="apidoc.element.xregexp.index.forEach">
        function <span class="apidocSignatureSpan">xregexp.index.</span>forEach
        <span class="apidocSignatureSpan">(str, regex, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">forEach = function (str, regex, callback) {
    var pos = 0;
    var i = -1;
    var match;

    while ((match = XRegExp.exec(str, regex, pos))) {
        // Because `regex` is provided to `callback`, the function could use the deprecated/
        // nonstandard `RegExp.prototype.compile` to mutate the regex. However, since `XRegExp.exec`
        // doesn&#x27;t use `lastIndex` to set the search position, this can&#x27;t lead to an infinite loop,
        // at least. Actually, because of the way `XRegExp.exec` caches globalized versions of
        // regexes, mutating the regex will not have any effect on the iteration or matched strings,
        // which is a nice side effect that brings extra safety.
        callback(match, ++i, str, regex);

        pos = match.index + (match[0].length || 1);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// The only caveat is that named captures must be referenced using numbered
// backreferences if used with native methods
&#x27;2017-02-22&#x27;.replace(date, &#x27;$2/$3/$1&#x27;);
// -&#x3e; &#x27;02/22/2017&#x27;

// Use XRegExp.forEach to extract every other digit from a string
var evens = [];
XRegExp.<span class="apidocCodeKeywordSpan">forEach</span>(&#x27;1a2345&#x27;, /\d/, (match, i) =&#x3e; {
if (i % 2) evens.push(+match[0]);
});
// evens -&#x3e; [2, 4]

// Use XRegExp.matchChain to get numbers within &#x3c;b&#x3e; tags
XRegExp.matchChain(&#x27;1 &#x3c;b&#x3e;2&#x3c;/b&#x3e; 3 &#x3c;B&#x3e;4 \n 56&#x3c;/B&#x3e;&#x27;, [
XRegExp(&#x27;(?is)&#x3c;b&#x3e;.*?&#x3c;/b&#x3e;&#x27;),
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.xregexp.index.globalize" id="apidoc.element.xregexp.index.globalize">
        function <span class="apidocSignatureSpan">xregexp.index.</span>globalize
        <span class="apidocSignatureSpan">(regex)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">globalize = function (regex) {
    return copyRegex(regex, {addG: true});
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * regexes are not recompiled using XRegExp syntax.
 *
 * @memberOf XRegExp
 * @param {RegExp} regex Regex to globalize.
 * @returns {RegExp} Copy of the provided regex with flag `g` added.
 * @example
 *
 * var globalCopy = XRegExp.<span class="apidocCodeKeywordSpan">globalize</span>(/regex/);
 * globalCopy.global; // -&#x3e; true
 */
XRegExp.globalize = function(regex) {
    return copyRegex(regex, {addG: true});
};

/**
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.xregexp.index.install" id="apidoc.element.xregexp.index.install">
        function <span class="apidocSignatureSpan">xregexp.index.</span>install
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">install = function (options) {
    options = prepareOptions(options);

    if (!features.astral &#x26;&#x26; options.astral) {
        setAstral(true);
    }

    if (!features.natives &#x26;&#x26; options.natives) {
        setNatives(true);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
unicodeWord.test(&#x27;العربية&#x27;); // -&#x3e; true

// Test some Unicode scripts
XRegExp(&#x27;^\\p{Hiragana}+$&#x27;).test(&#x27;ひらがな&#x27;); // -&#x3e; true
XRegExp(&#x27;^[\\p{Latin}\\p{Common}]+$&#x27;).test(&#x27;Über Café.&#x27;); // -&#x3e; true
```

By default, `\p{…}` and `\P{…}` support the Basic Multilingual Plane (i.e. code points up to `U+FFFF`). You can opt-in to full 21
-bit Unicode support (with code points up to `U+10FFFF`) on a per-regex basis by using flag `A`. This is called *astral mode*. You
 can automatically add flag `A` for all new regexes by running `XRegExp.<span class="apidocCodeKeywordSpan">install</span>(&#x27
;astral&#x27;)`. When in astral mode, `\p{…}` and `\P{…}` always match a full code point rather than a code unit, using surrogate pairs for code points above `U+FFFF`.

```js
// Using flag A to match astral code points
XRegExp(&#x27;^\\pS$&#x27;).test(&#x27;💩&#x27;); // -&#x3e; false
XRegExp(&#x27;^\\pS$&#x27;, &#x27;A&#x27;).test(&#x27;💩&#x27;); // -&#x3e; true
XRegExp(&#x27;(?A)^\\pS$&#x27;).test(&#x27;💩&#x27;); // -&#x3e; true
// Using surrogate pair U+D83D U+DCA9 to represent U+1F4A9 (pile of poo)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.xregexp.index.isInstalled" id="apidoc.element.xregexp.index.isInstalled">
        function <span class="apidocSignatureSpan">xregexp.index.</span>isInstalled
        <span class="apidocSignatureSpan">(feature)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isInstalled = function (feature) {
    return !!(features[feature]);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    return copyRegex(pattern);
}

// Copy the argument behavior of `RegExp`
pattern = pattern === undefined ? &#x27;&#x27; : String(pattern);
flags = flags === undefined ? &#x27;&#x27; : String(flags);

if (XRegExp.<span class="apidocCodeKeywordSpan">isInstalled</span>(&#x27;astral&#x27;) &#x26;&#x26; flags.indexOf(&#x27;A&#x27;) === -
1) {
    // This causes an error to be thrown if the Unicode Base addon is not available
    flags += &#x27;A&#x27;;
}

if (!patternCache[pattern]) {
    patternCache[pattern] = {};
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.xregexp.index.isRegExp" id="apidoc.element.xregexp.index.isRegExp">
        function <span class="apidocSignatureSpan">xregexp.index.</span>isRegExp
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isRegExp = function (value) {
    return toString.call(value) === &#x27;[object RegExp]&#x27;;
    //return isType(value, &#x27;RegExp&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @param {String|RegExp} value Value to convert.
 * @param {Boolean} [addFlagX] Whether to apply the `x` flag in cases when `value` is not
 *   already a regex generated by XRegExp
 * @returns {RegExp} XRegExp object with XRegExp syntax applied.
 */
function asXRegExp(value, addFlagX) {
    var flags = addFlagX ? &#x27;x&#x27; : &#x27;&#x27;;
    return XRegExp.<span class="apidocCodeKeywordSpan">isRegExp</span>(value) ?
        (value[REGEX_DATA] &#x26;&#x26; value[REGEX_DATA].captureNames ?
            // Don&#x27;t recompile, to preserve capture names
            value :
            // Recompile as XRegExp
            XRegExp(value.source, flags)
        ) :
        // Compile string as XRegExp
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.xregexp.index.match" id="apidoc.element.xregexp.index.match">
        function <span class="apidocSignatureSpan">xregexp.index.</span>match
        <span class="apidocSignatureSpan">(str, regex, scope)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">match = function (str, regex, scope) {
    var global = (regex.global &#x26;&#x26; scope !== &#x27;one&#x27;) || scope === &#x27;all&#x27;;
    var cacheKey = ((global ? &#x27;g&#x27; : &#x27;&#x27;) + (regex.sticky ? &#x27;y&#x27; : &#x27;&#x27;)) || &#x27;noGY&#x27;;
    var result;
    var r2;

    regex[REGEX_DATA] = regex[REGEX_DATA] || {};

    // Shares cached copies with `XRegExp.exec`/`replace`
    r2 = regex[REGEX_DATA][cacheKey] || (
        regex[REGEX_DATA][cacheKey] = copyRegex(regex, {
            addG: !!global,
            removeG: scope === &#x27;one&#x27;,
            isInternalOnly: true
        })
    );

    result = nativ.match.call(toObject(str), r2);

    if (regex.global) {
        regex.lastIndex = (
            (scope === &#x27;one&#x27; &#x26;&#x26; result) ?
                // Can&#x27;t use `r2.lastIndex` since `r2` is nonglobal in this case
                (result.index + result[0].length) : 0
        );
    }

    return global ? (result || []) : (result &#x26;&#x26; result[0]);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
*   return an array of all matched strings. If not explicitly specified and `regex` uses flag g,
*   `scope` is &#x27;all&#x27;.
* @returns {String|Array} In match-first mode: First match as a string, or `null`. In match-all
*   mode: Array of all matched strings, or an empty array.
* @example
*
* // Match first
* XRegExp.<span class="apidocCodeKeywordSpan">match</span>(&#x27;abc&#x27;, /\w/); // -&#x3e; &#x27;a&#x27;
* XRegExp.match(&#x27;abc&#x27;, /\w/g, &#x27;one&#x27;); // -&#x3e; &#x27;a&#x27;
* XRegExp.match(&#x27;abc&#x27;, /x/g, &#x27;one&#x27;); // -&#x3e; null
*
* // Match all
* XRegExp.match(&#x27;abc&#x27;, /\w/g); // -&#x3e; [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]
* XRegExp.match(&#x27;abc&#x27;, /\w/, &#x27;all&#x27;); // -&#x3e; [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]
* XRegExp.match(&#x27;abc&#x27;, /x/, &#x27;all&#x27;); // -&#x3e; []
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.xregexp.index.matchChain" id="apidoc.element.xregexp.index.matchChain">
        function <span class="apidocSignatureSpan">xregexp.index.</span>matchChain
        <span class="apidocSignatureSpan">(str, chain)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">matchChain = function (str, chain) {
    return (function recurseChain(values, level) {
        var item = chain[level].regex ? chain[level] : {regex: chain[level]};
        var matches = [];

        function addMatch(match) {
            if (item.backref) {
                // Safari 4.0.5 (but not 5.0.5+) inappropriately uses sparse arrays to hold the
                // `undefined`s for backreferences to nonparticipating capturing groups. In such
                // cases, a `hasOwnProperty` or `in` check on its own would inappropriately throw
                // the exception, so also check if the backreference is a number that is within the
                // bounds of the array.
                if (!(match.hasOwnProperty(item.backref) || +item.backref &#x3c; match.length)) {
                    throw new ReferenceError(&#x27;Backreference to undefined group: &#x27; + item.backref);
                }

                matches.push(match[item.backref] || &#x27;&#x27;);
            } else {
                matches.push(match[0]);
            }
        }

        for (var i = 0; i &#x3c; values.length; ++i) {
            XRegExp.forEach(values[i], item.regex, addMatch);
        }

        return ((level === chain.length - 1) || !matches.length) ?
            matches :
            recurseChain(matches, level + 1);
    }([str], 0));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var evens = [];
XRegExp.forEach(&#x27;1a2345&#x27;, /\d/, (match, i) =&#x3e; {
    if (i % 2) evens.push(+match[0]);
});
// evens -&#x3e; [2, 4]

// Use XRegExp.matchChain to get numbers within &#x3c;b&#x3e; tags
XRegExp.<span class="apidocCodeKeywordSpan">matchChain</span>(&#x27;1 &#x3c;b&#x3e;2&#x3c;/b&#x3e; 3 &#x3c;B&#x3e;4 \n 56&#x3c;/
B&#x3e;&#x27;, [
    XRegExp(&#x27;(?is)&#x3c;b&#x3e;.*?&#x3c;/b&#x3e;&#x27;),
    /\d+/
]);
// -&#x3e; [&#x27;2&#x27;, &#x27;4&#x27;, &#x27;56&#x27;]

// You can also pass forward and return specific backreferences
var html = &#x27;&#x3c;a href=&#x22;http://xregexp.com/&#x22;&#x3e;XRegExp&#x3c;/a&#x3e;&#x27; +
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.xregexp.index.matchRecursive" id="apidoc.element.xregexp.index.matchRecursive">
        function <span class="apidocSignatureSpan">xregexp.index.</span>matchRecursive
        <span class="apidocSignatureSpan">(str, left, right, flags, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">matchRecursive = function (str, left, right, flags, options) {
    flags = flags || &#x27;&#x27;;
    options = options || {};
    var global = flags.indexOf(&#x27;g&#x27;) &#x3e; -1;
    var sticky = flags.indexOf(&#x27;y&#x27;) &#x3e; -1;
    // Flag `y` is controlled internally
    var basicFlags = flags.replace(/y/g, &#x27;&#x27;);
    var escapeChar = options.escapeChar;
    var vN = options.valueNames;
    var output = [];
    var openTokens = 0;
    var delimStart = 0;
    var delimEnd = 0;
    var lastOuterEnd = 0;
    var outerStart;
    var innerStart;
    var leftMatch;
    var rightMatch;
    var esc;
    left = XRegExp(left, basicFlags);
    right = XRegExp(right, basicFlags);

    if (escapeChar) {
        if (escapeChar.length &#x3e; 1) {
            throw new Error(&#x27;Cannot use more than one escape character&#x27;);
        }
        escapeChar = XRegExp.escape(escapeChar);
        // Example of concatenated `esc` regex:
        // `escapeChar`: &#x27;%&#x27;
        // `left`: &#x27;&#x3c;&#x27;
        // `right`: &#x27;&#x3e;&#x27;
        // Regex is: /(?:%[\S\s]|(?:(?!&#x3c;|&#x3e;)[^%])+)+/
        esc = new RegExp(
            &#x27;(?:&#x27; + escapeChar + &#x27;[\\S\\s]|(?:(?!&#x27; +
                // Using `XRegExp.union` safely rewrites backreferences in `left` and `right`.
                // Intentionally not passing `basicFlags` to `XRegExp.union` since any syntax
                // transformation resulting from those flags was already applied to `left` and
                // `right` when they were passed through the XRegExp constructor above.
                XRegExp.union([left, right], &#x27;&#x27;, {conjunction: &#x27;or&#x27;}).source +
                &#x27;)[^&#x27; + escapeChar + &#x27;])+)+&#x27;,
            // Flags `gy` not needed here
            flags.replace(/[^imu]+/g, &#x27;&#x27;)
        );
    }

    while (true) {
        // If using an escape character, advance to the delimiter&#x27;s next starting position,
        // skipping any escaped characters in between
        if (escapeChar) {
            delimEnd += (XRegExp.exec(str, esc, delimEnd, &#x27;sticky&#x27;) || [&#x27;&#x27;])[0].length;
        }
        leftMatch = XRegExp.exec(str, left, delimEnd);
        rightMatch = XRegExp.exec(str, right, delimEnd);
        // Keep the leftmost match only
        if (leftMatch &#x26;&#x26; rightMatch) {
            if (leftMatch.index &#x3c;= rightMatch.index) {
                rightMatch = null;
            } else {
                leftMatch = null;
            }
        }
        // Paths (LM: leftMatch, RM: rightMatch, OT: openTokens):
        // LM | RM | OT | Result
        // 1  | 0  | 1  | loop
        // 1  | 0  | 0  | loop
        // 0  | 1  | 1  | loop
        // 0  | 1  | 0  | throw
        // 0  | 0  | 1  | throw
        // 0  | 0  | 0  | break
        // The paths above don&#x27;t include the sticky mode special case. The loop ends after the
        // first completed match if not `global`.
        if (leftMatch || rightMatch) {
            delimStart = (leftMatch || rightMatch).index;
            delimEnd = delimStart + (leftMatch || rightMatch)[0].length;
        } else if (!openTokens) {
            break;
        }
        if (sticky &#x26;&#x26; !openTokens &#x26;&#x26; delimStart &#x3e; lastOuterEnd) {
            break;
        }
        if (leftMatch) {
            if (!openTokens) {
                outerStart = delimStart;
                innerStart = delimEnd;
            }
            ++openTokens;
        } else if (rightMatch &#x26;&#x26; openTokens) {
            if (!--openTokens) {
                if (vN) {
                    if (vN[0] &#x26;&#x26; outerStart &#x3e; lastOuterEnd) {
                        output.push(row(vN[0], str.slice(lastOuterEnd, outerStart), lastOuterEnd, outerStart));
                    }
                    if (vN[1]) {
                        output.push(row(vN[1], str.slice(outerStart, innerStart), outerStart, innerStart));
                    }
                    if (vN[2]) {
                        output.push(row(vN[2], str.slice(innerStart, delimStart), innerStart, delimStart));
                    }
                    if (vN[3]) {
                        output.push(row(vN[3], str.slice(delimStart, d ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...

### XRegExp.matchRecursive

Match recursive constructs using XRegExp pattern strings as left and right delimiters:

```js
var str = &#x27;(t((e))s)t()(ing)&#x27;;
XRegExp.<span class="apidocCodeKeywordSpan">matchRecursive</span>(str, &#x27;\\(&#x27;, &#x27;\\)&#x27;, &#x27;g&#x27;);
// -&#x3e; [&#x27;t((e))s&#x27;, &#x27;&#x27;, &#x27;ing&#x27;]

// Extended information mode with valueNames
str = &#x27;Here is &#x3c;div&#x3e; &#x3c;div&#x3e;an&#x3c;/div&#x3e;&#x3c;/div&#x3e; example&#x27;;
XRegExp.matchRecursive(str, &#x27;&#x3c;div\\s*&#x3e;&#x27;, &#x27;&#x3c;/div&#x3e;&#x27;, &#x27;gi&#x27;, {
    valueNames: [&#x27;between&#x27;, &#x27;left&#x27;, &#x27;match&#x27;, &#x27;right&#x27;]
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.xregexp.index.replace" id="apidoc.element.xregexp.index.replace">
        function <span class="apidocSignatureSpan">xregexp.index.</span>replace
        <span class="apidocSignatureSpan">(str, search, replacement, scope)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">replace = function (str, search, replacement, scope) {
    var isRegex = XRegExp.isRegExp(search);
    var global = (search.global &#x26;&#x26; scope !== &#x27;one&#x27;) || scope === &#x27;all&#x27;;
    var cacheKey = ((global ? &#x27;g&#x27; : &#x27;&#x27;) + (search.sticky ? &#x27;y&#x27; : &#x27;&#x27;)) || &#x27;noGY&#x27;;
    var s2 = search;
    var result;

    if (isRegex) {
        search[REGEX_DATA] = search[REGEX_DATA] || {};

        // Shares cached copies with `XRegExp.exec`/`match`. Since a copy is used, `search`&#x27;s
        // `lastIndex` isn&#x27;t updated *during* replacement iterations
        s2 = search[REGEX_DATA][cacheKey] || (
            search[REGEX_DATA][cacheKey] = copyRegex(search, {
                addG: !!global,
                removeG: scope === &#x27;one&#x27;,
                isInternalOnly: true
            })
        );
    } else if (global) {
        s2 = new RegExp(XRegExp.escape(String(search)), &#x27;g&#x27;);
    }

    // Fixed `replace` required for named backreferences, etc.
    result = fixed.replace.call(toObject(str), s2, replacement);

    if (isRegex &#x26;&#x26; search.global) {
        // Fixes IE, Safari bug (last tested IE 9, Safari 5.1)
        search.lastIndex = 0;
    }

    return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
while (match = XRegExp.exec(&#x27;&#x3c;1&#x3e;&#x3c;2&#x3e;&#x3c;3&#x3e;&#x3c;4&#x3e;5&#x3c;6&#x3e;&#x27;, /&#x3c;(\d+)&#x3e;/,
pos, &#x27;sticky&#x27;)) {
    result.push(match[1]);
    pos = match.index + match[0].length;
}
// result -&#x3e; [&#x27;2&#x27;, &#x27;3&#x27;, &#x27;4&#x27;]

// XRegExp.replace allows named backreferences in replacements
XRegExp.<span class="apidocCodeKeywordSpan">replace</span>(&#x27;2017-02-22&#x27;, date, &#x27;${month}/${day}/${year}&#x27;);
// -&#x3e; &#x27;02/22/2017&#x27;
XRegExp.replace(&#x27;2017-02-22&#x27;, date, (match) =&#x3e; {
    return match.month + &#x27;/&#x27; + match.day + &#x27;/&#x27; + match.year;
});
// -&#x3e; &#x27;02/22/2017&#x27;

// XRegExps compile to RegExps and work perfectly with native methods
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.xregexp.index.replaceEach" id="apidoc.element.xregexp.index.replaceEach">
        function <span class="apidocSignatureSpan">xregexp.index.</span>replaceEach
        <span class="apidocSignatureSpan">(str, replacements)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">replaceEach = function (str, replacements) {
    var i;
    var r;

    for (i = 0; i &#x3c; replacements.length; ++i) {
        r = replacements[i];
        str = XRegExp.replace(str, r[0], r[1], r[2]);
    }

    return str;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
*
* @memberOf XRegExp
* @param {String} str String to search.
* @param {Array} replacements Array of replacement detail arrays.
* @returns {String} New string with all replacements.
* @example
*
* str = XRegExp.<span class="apidocCodeKeywordSpan">replaceEach</span>(str, [
*   [XRegExp(&#x27;(?&#x3c;name&#x3e;a)&#x27;), &#x27;z${name}&#x27;],
*   [/b/gi, &#x27;y&#x27;],
*   [/c/g, &#x27;x&#x27;, &#x27;one&#x27;], // scope &#x27;one&#x27; overrides /g
*   [/d/, &#x27;w&#x27;, &#x27;all&#x27;],  // scope &#x27;all&#x27; overrides lack of /g
*   [&#x27;e&#x27;, &#x27;v&#x27;, &#x27;all&#x27;],  // scope &#x27;all&#x27; allows replace-all for strings
*   [/f/g, function($0) {
*     return $0.toUpperCase();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.xregexp.index.split" id="apidoc.element.xregexp.index.split">
        function <span class="apidocSignatureSpan">xregexp.index.</span>split
        <span class="apidocSignatureSpan">(str, separator, limit)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">split = function (str, separator, limit) {
    return fixed.split.call(toObject(str), separator, limit);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
           // extensions exist on `regex.prototype` anyway
           regex[p] = XRegExp.prototype[p];
       }
   }

   regex[REGEX_DATA].source = xSource;
   // Emulate the ES6 `flags` prop by ensuring flags are in alphabetical order
   regex[REGEX_DATA].flags = xFlags ? xFlags.<span class="apidocCodeKeywordSpan">split</span>(&#x27;&#x27;).sort().join(&#x27;&#
x27;) : xFlags;

   return regex;
}

/**
* Removes any duplicate characters from the provided string.
*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.xregexp.index.test" id="apidoc.element.xregexp.index.test">
        function <span class="apidocSignatureSpan">xregexp.index.</span>test
        <span class="apidocSignatureSpan">(str, regex, pos, sticky)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">test = function (str, regex, pos, sticky) {
    // Do this the easy way :-)
    return !!XRegExp.exec(str, regex, pos, sticky);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// -&#x3e; &#x27;02/22/2017&#x27;
XRegExp.replace(&#x27;2017-02-22&#x27;, date, (match) =&#x3e; {
    return match.month + &#x27;/&#x27; + match.day + &#x27;/&#x27; + match.year;
});
// -&#x3e; &#x27;02/22/2017&#x27;

// XRegExps compile to RegExps and work perfectly with native methods
date.<span class="apidocCodeKeywordSpan">test</span>(&#x27;2017-02-22&#x27;);
// -&#x3e; true

// The only caveat is that named captures must be referenced using numbered
// backreferences if used with native methods
&#x27;2017-02-22&#x27;.replace(date, &#x27;$2/$3/$1&#x27;);
// -&#x3e; &#x27;02/22/2017&#x27;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.xregexp.index.uninstall" id="apidoc.element.xregexp.index.uninstall">
        function <span class="apidocSignatureSpan">xregexp.index.</span>uninstall
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">uninstall = function (options) {
    options = prepareOptions(options);

    if (features.astral &#x26;&#x26; options.astral) {
        setAstral(false);
    }

    if (features.natives &#x26;&#x26; options.natives) {
        setNatives(false);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* uninstalled, so this is used to undo the actions of `XRegExp.install`.
*
* @memberOf XRegExp
* @param {Object|String} options Options object or string.
* @example
*
* // With an options object
* XRegExp.<span class="apidocCodeKeywordSpan">uninstall</span>({
*   // Disables support for astral code points in Unicode addons
*   astral: true,
*
*   // DEPRECATED: Restores native regex methods
*   natives: true
* });
*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.xregexp.index.union" id="apidoc.element.xregexp.index.union">
        function <span class="apidocSignatureSpan">xregexp.index.</span>union
        <span class="apidocSignatureSpan">(patterns, flags, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">union = function (patterns, flags, options) {
    options = options || {};
    var conjunction = options.conjunction || &#x27;or&#x27;;
    var numCaptures = 0;
    var numPriorCaptures;
    var captureNames;

    function rewrite(match, paren, backref) {
        var name = captureNames[numCaptures - numPriorCaptures];

        // Capturing group
        if (paren) {
            ++numCaptures;
            // If the current capture has a name, preserve the name
            if (name) {
                return &#x27;(?&#x3c;&#x27; + name + &#x27;&#x3e;&#x27;;
            }
        // Backreference
        } else if (backref) {
            // Rewrite the backreference
            return &#x27;\\&#x27; + (+backref + numPriorCaptures);
        }

        return match;
    }

    if (!(isType(patterns, &#x27;Array&#x27;) &#x26;&#x26; patterns.length)) {
        throw new TypeError(&#x27;Must provide a nonempty array of patterns to merge&#x27;);
    }

    var parts = /(\()(?!\?)|\\([1-9]\d*)|\\[\s\S]|\[(?:[^\\\]]|\\[\s\S])*\]/g;
    var output = [];
    var pattern;
    for (var i = 0; i &#x3c; patterns.length; ++i) {
        pattern = patterns[i];

        if (XRegExp.isRegExp(pattern)) {
            numPriorCaptures = numCaptures;
            captureNames = (pattern[REGEX_DATA] &#x26;&#x26; pattern[REGEX_DATA].captureNames) || [];

            // Rewrite backreferences. Passing to XRegExp dies on octals and ensures patterns are
            // independently valid; helps keep this simple. Named captures are put back
            output.push(nativ.replace.call(XRegExp(pattern.source).source, parts, rewrite));
        } else {
            output.push(XRegExp.escape(pattern));
        }
    }

    var separator = conjunction === &#x27;none&#x27; ? &#x27;&#x27; : &#x27;|&#x27;;
    return XRegExp(output.join(separator), flags);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
XRegExp.matchChain(html, [
    {regex: /&#x3c;a href=&#x22;([^&#x22;]+)&#x22;&#x3e;/i, backref: 1},
    {regex: XRegExp(&#x27;(?i)^https?://(?&#x3c;domain&#x3e;[^/?#]+)&#x27;), backref: &#x27;domain&#x27;}
]);
// -&#x3e; [&#x27;xregexp.com&#x27;, &#x27;www.google.com&#x27;]

// Merge strings and regexes into a single pattern with updated backreferences
XRegExp.<span class="apidocCodeKeywordSpan">union</span>([&#x27;a+b*c&#x27;, /(dog)\1/, /(cat)\1/], &#x27;i&#x27;, {conjunction: &#
x27;or&#x27;});
// -&#x3e; /a\+b\*c|(dog)\1|(cat)\2/i
```

These examples give the flavor of what&#x27;s possible, but XRegExp has more syntax, flags, methods, options, and browser fixes
that aren&#x27;t shown here. You can also augment XRegExp&#x27;s regular expression syntax with addons (see below) or write your
 own. See [xregexp.com](http://xregexp.com/) for details.

## Addons
...</pre></li>
    </ul>




</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>

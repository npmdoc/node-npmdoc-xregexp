<html><head></head><body><div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a href="http://xregexp.com/">xregexp (v3.1.1)</a>
</h1>
<h4>Extended regular expressions</h4>
<div class="apidocSectionDiv"><a href="#apidoc.tableOfContents" id="apidoc.tableOfContents"><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.xregexp">module xregexp</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.xregexp._dec">
            function <span class="apidocSignatureSpan">xregexp.</span>_dec
            <span class="apidocSignatureSpan">(hex)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.xregexp._hasNativeFlag">
            function <span class="apidocSignatureSpan">xregexp.</span>_hasNativeFlag
            <span class="apidocSignatureSpan">(flag)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.xregexp._hex">
            function <span class="apidocSignatureSpan">xregexp.</span>_hex
            <span class="apidocSignatureSpan">(dec)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.xregexp._pad4">
            function <span class="apidocSignatureSpan">xregexp.</span>_pad4
            <span class="apidocSignatureSpan">(str)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.xregexp.addToken">
            function <span class="apidocSignatureSpan">xregexp.</span>addToken
            <span class="apidocSignatureSpan">(regex, handler, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.xregexp.addUnicodeData">
            function <span class="apidocSignatureSpan">xregexp.</span>addUnicodeData
            <span class="apidocSignatureSpan">(data)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.xregexp.build">
            function <span class="apidocSignatureSpan">xregexp.</span>build
            <span class="apidocSignatureSpan">(pattern, subs, flags)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.xregexp.cache">
            function <span class="apidocSignatureSpan">xregexp.</span>cache
            <span class="apidocSignatureSpan">(pattern, flags)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.xregexp.escape">
            function <span class="apidocSignatureSpan">xregexp.</span>escape
            <span class="apidocSignatureSpan">(str)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.xregexp.exec">
            function <span class="apidocSignatureSpan">xregexp.</span>exec
            <span class="apidocSignatureSpan">(str, regex, pos, sticky)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.xregexp.forEach">
            function <span class="apidocSignatureSpan">xregexp.</span>forEach
            <span class="apidocSignatureSpan">(str, regex, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.xregexp.globalize">
            function <span class="apidocSignatureSpan">xregexp.</span>globalize
            <span class="apidocSignatureSpan">(regex)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.xregexp.install">
            function <span class="apidocSignatureSpan">xregexp.</span>install
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.xregexp.isInstalled">
            function <span class="apidocSignatureSpan">xregexp.</span>isInstalled
            <span class="apidocSignatureSpan">(feature)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.xregexp.isRegExp">
            function <span class="apidocSignatureSpan">xregexp.</span>isRegExp
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.xregexp.match">
            function <span class="apidocSignatureSpan">xregexp.</span>match
            <span class="apidocSignatureSpan">(str, regex, scope)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.xregexp.matchChain">
            function <span class="apidocSignatureSpan">xregexp.</span>matchChain
            <span class="apidocSignatureSpan">(str, chain)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.xregexp.matchRecursive">
            function <span class="apidocSignatureSpan">xregexp.</span>matchRecursive
            <span class="apidocSignatureSpan">(str, left, right, flags, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.xregexp.replace">
            function <span class="apidocSignatureSpan">xregexp.</span>replace
            <span class="apidocSignatureSpan">(str, search, replacement, scope)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.xregexp.replaceEach">
            function <span class="apidocSignatureSpan">xregexp.</span>replaceEach
            <span class="apidocSignatureSpan">(str, replacements)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.xregexp.split">
            function <span class="apidocSignatureSpan">xregexp.</span>split
            <span class="apidocSignatureSpan">(str, separator, limit)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.xregexp.test">
            function <span class="apidocSignatureSpan">xregexp.</span>test
            <span class="apidocSignatureSpan">(str, regex, pos, sticky)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.xregexp.uninstall">
            function <span class="apidocSignatureSpan">xregexp.</span>uninstall
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.xregexp.union">
            function <span class="apidocSignatureSpan">xregexp.</span>union
            <span class="apidocSignatureSpan">(patterns, flags)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">xregexp.</span>version</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.xregexp.cache">module xregexp.cache</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.xregexp.cache.cache">
            function <span class="apidocSignatureSpan">xregexp.</span>cache
            <span class="apidocSignatureSpan">(pattern, flags)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.xregexp.cache.flush">
            function <span class="apidocSignatureSpan">xregexp.cache.</span>flush
            <span class="apidocSignatureSpan">(cacheName)</span>
            </a>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.xregexp" id="apidoc.module.xregexp">module xregexp</a></h1>


    <h2>
        <a href="#apidoc.element.xregexp._dec" id="apidoc.element.xregexp._dec">
        function <span class="apidocSignatureSpan">xregexp.</span>_dec
        <span class="apidocSignatureSpan">(hex)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function dec(hex) {
    return parseInt(hex, 16);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.xregexp._hasNativeFlag" id="apidoc.element.xregexp._hasNativeFlag">
        function <span class="apidocSignatureSpan">xregexp.</span>_hasNativeFlag
        <span class="apidocSignatureSpan">(flag)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function hasNativeFlag(flag) {
    // Can't check based on the presense of properties/getters since browsers might support such
    // properties even when they don't support the corresponding flag in regex construction (tested
    // in Chrome 48, where `'unicode' in /x/` is true but trying to construct a regex with flag `u`
    // throws an error)
    var isSupported = true;
    try {
        // Can't use regex literals for testing even in a `try` because regex literals with
        // unsupported flags cause a compilation error in IE
        new RegExp('', flag);
    } catch (exception) {
        isSupported = false;
    }
    if (isSupported &amp;&amp; flag === 'y') {
        // Work around Safari 9.1.1 bug
        return new RegExp('aa|.', 'y').test('b');
    }
    return isSupported;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.xregexp._hex" id="apidoc.element.xregexp._hex">
        function <span class="apidocSignatureSpan">xregexp.</span>_hex
        <span class="apidocSignatureSpan">(dec)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function hex(dec) {
    return parseInt(dec, 10).toString(16);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.xregexp._pad4" id="apidoc.element.xregexp._pad4">
        function <span class="apidocSignatureSpan">xregexp.</span>_pad4
        <span class="apidocSignatureSpan">(str)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function pad4(str) {
    while (str.length &lt; 4) {
        str = '0' + str;
    }
    return str;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.xregexp.addToken" id="apidoc.element.xregexp.addToken">
        function <span class="apidocSignatureSpan">xregexp.</span>addToken
        <span class="apidocSignatureSpan">(regex, handler, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">addToken = function (regex, handler, options) {
    options = options || {};
    var optionalFlags = options.optionalFlags, i;

    if (options.flag) {
        registerFlag(options.flag);
    }

    if (optionalFlags) {
        optionalFlags = nativ.split.call(optionalFlags, '');
        for (i = 0; i &lt; optionalFlags.length; ++i) {
            registerFlag(optionalFlags[i]);
        }
    }

    // Add to the private list of syntax tokens
    tokens.push({
        regex: copyRegex(regex, {
            addG: true,
            addY: hasNativeY,
            isInternalOnly: true
        }),
        handler: handler,
        scope: options.scope || defaultScope,
        flag: options.flag,
        reparse: options.reparse,
        leadChar: options.leadChar
    });

    // Reset the pattern cache used by the `XRegExp` constructor, since the same pattern and flags
    // might now produce different results
    XRegExp.cache.flush('patterns');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.xregexp.addUnicodeData" id="apidoc.element.xregexp.addUnicodeData">
        function <span class="apidocSignatureSpan">xregexp.</span>addUnicodeData
        <span class="apidocSignatureSpan">(data)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">addUnicodeData = function (data) {
    var ERR_NO_NAME = 'Unicode token requires name',
        ERR_NO_DATA = 'Unicode token has no character data ',
        item,
        i;

    for (i = 0; i &lt; data.length; ++i) {
        item = data[i];
        if (!item.name) {
            throw new Error(ERR_NO_NAME);
        }
        if (!(item.inverseOf || item.bmp || item.astral)) {
            throw new Error(ERR_NO_DATA + item.name);
        }
        unicode[normalize(item.name)] = item;
        if (item.alias) {
            unicode[normalize(item.alias)] = item;
        }
    }

    // Reset the pattern cache used by the `XRegExp` constructor, since the same pattern and
    // flags might now produce different results
    XRegExp.cache.flush('patterns');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.xregexp.build" id="apidoc.element.xregexp.build">
        function <span class="apidocSignatureSpan">xregexp.</span>build
        <span class="apidocSignatureSpan">(pattern, subs, flags)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">build = function (pattern, subs, flags) {
    var inlineFlags = /^\(\?([\w$]+)\)/.exec(pattern),
        data = {},
        numCaps = 0, // 'Caps' is short for captures
        numPriorCaps,
        numOuterCaps = 0,
        outerCapsMap = [0],
        outerCapNames,
        sub,
        p;

    // Add flags within a leading mode modifier to the overall pattern's flags
    if (inlineFlags) {
        flags = flags || '';
        inlineFlags[1].replace(/./g, function(flag) {
            // Don't add duplicates
            flags += (flags.indexOf(flag) &gt; -1 ? '' : flag);
        });
    }

    for (p in subs) {
        if (subs.hasOwnProperty(p)) {
            // Passing to XRegExp enables extended syntax and ensures independent validity,
            // lest an unescaped `(`, `)`, `[`, or trailing `\` breaks the `(?:)` wrapper. For
            // subpatterns provided as native regexes, it dies on octals and adds the property
            // used to hold extended regex instance data, for simplicity
            sub = asXRegExp(subs[p]);
            data[p] = {
                // Deanchoring allows embedding independently useful anchored regexes. If you
                // really need to keep your anchors, double them (i.e., `^^...$$`)
                pattern: deanchor(sub.source),
                names: sub[REGEX_DATA].captureNames || []
            };
        }
    }

    // Passing to XRegExp dies on octals and ensures the outer pattern is independently valid;
    // helps keep this simple. Named captures will be put back
    pattern = asXRegExp(pattern);
    outerCapNames = pattern[REGEX_DATA].captureNames || [];
    pattern = pattern.source.replace(parts, function($0, $1, $2, $3, $4) {
        var subName = $1 || $2,
            capName,
            intro,
            localCapIndex;
        // Named subpattern
        if (subName) {
            if (!data.hasOwnProperty(subName)) {
                throw new ReferenceError('Undefined property ' + $0);
            }
            // Named subpattern was wrapped in a capturing group
            if ($1) {
                capName = outerCapNames[numOuterCaps];
                outerCapsMap[++numOuterCaps] = ++numCaps;
                // If it's a named group, preserve the name. Otherwise, use the subpattern name
                // as the capture name
                intro = '(?&lt;' + (capName || subName) + '&gt;';
            } else {
                intro = '(?:';
            }
            numPriorCaps = numCaps;
            return intro + data[subName].pattern.replace(subParts, function(match, paren, backref) {
                // Capturing group
                if (paren) {
                    capName = data[subName].names[numCaps - numPriorCaps];
                    ++numCaps;
                    // If the current capture has a name, preserve the name
                    if (capName) {
                        return '(?&lt;' + capName + '&gt;';
                    }
                // Backreference
                } else if (backref) {
                    localCapIndex = +backref - 1;
                    // Rewrite the backreference
                    return data[subName].names[localCapIndex] ?
                        // Need to preserve the backreference name in case using flag `n`
                        '\\k&lt;' + data[subName].names[localCapIndex] + '&gt;' :
                        '\\' + (+backref + numPriorCaps);
                }
                return match;
            }) + ')';
        }
        // Capturing group
        if ($3) {
            capName = outerCapNames[numOuterCaps];
            outerCapsMap[++numOuterCaps] = ++numCaps;
            // If the current capture has a name, preserve the name
            if (capName) {
                return '(?&lt;' + capName + '&gt;';
            }
        // Backreference
        } else if ($4) {
            localCapIndex = +$4 - 1;
            // Rewrite the backreference
            return outerCapNames[localCapIndex] ?
                // Need to preserve the backreference name in case using flag `n`
                '\\k&lt;' + outerCapNames[localCapInde ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
XRegExp uses Unicode 8.0.0.

### XRegExp.build

Build regular expressions using named subpatterns, for readability and pattern reuse:

```js
var time = XRegExp.<span class="apidocCodeKeywordSpan">build</span>('(?x)^ {{hours}} ({{minutes}}) $', {
    hours: XRegExp.build('{{h12}} : | {{h24}}', {
        h12: /1[0-2]|0?[1-9]/,
        h24: /2[0-3]|[01][0-9]/
    }),
    minutes: /^[0-5][0-9]$/
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.xregexp.cache" id="apidoc.element.xregexp.cache">
        function <span class="apidocSignatureSpan">xregexp.</span>cache
        <span class="apidocSignatureSpan">(pattern, flags)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">cache = function (pattern, flags) {
    if (!regexCache[pattern]) {
        regexCache[pattern] = {};
    }
    return regexCache[pattern][flags] || (
        regexCache[pattern][flags] = XRegExp(pattern, flags)
    );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.xregexp.escape" id="apidoc.element.xregexp.escape">
        function <span class="apidocSignatureSpan">xregexp.</span>escape
        <span class="apidocSignatureSpan">(str)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">escape = function (str) {
    return nativ.replace.call(toObject(str), /[-[\]{}()*+?.,\\^$|#\s]/g, '\\$&amp;');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.xregexp.exec" id="apidoc.element.xregexp.exec">
        function <span class="apidocSignatureSpan">xregexp.</span>exec
        <span class="apidocSignatureSpan">(str, regex, pos, sticky)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">exec = function (str, regex, pos, sticky) {
    var cacheKey = 'g',
        addY = false,
        match,
        r2;

    addY = hasNativeY &amp;&amp; !!(sticky || (regex.sticky &amp;&amp; sticky !== false));
    if (addY) {
        cacheKey += 'y';
    }

    regex[REGEX_DATA] = regex[REGEX_DATA] || {};

    // Shares cached copies with `XRegExp.match`/`replace`
    r2 = regex[REGEX_DATA][cacheKey] || (
        regex[REGEX_DATA][cacheKey] = copyRegex(regex, {
            addG: true,
            addY: addY,
            removeY: sticky === false,
            isInternalOnly: true
        })
    );

    r2.lastIndex = pos = pos || 0;

    // Fixed `exec` required for `lastIndex` fix, named backreferences, etc.
    match = fixed.exec.call(r2, str);

    if (sticky &amp;&amp; match &amp;&amp; match.index !== pos) {
        match = null;
    }

    if (regex.global) {
        regex.lastIndex = match ? r2.lastIndex : 0;
    }

    return match;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
```js
// Using named capture and flag x (free-spacing and line comments)
var date = XRegExp('(?&lt;year&gt;  [0-9]{4} ) -?  # year  \n\
                (?&lt;month&gt; [0-9]{2} ) -?  # month \n\
                (?&lt;day&gt;   [0-9]{2} )     # day   ', 'x');

// XRegExp.exec gives you named backreferences on the match result
var match = XRegExp.<span class="apidocCodeKeywordSpan">exec</span>('2015-02-22', date);
match.year; // -&gt; '2015'

// It also includes optional pos and sticky arguments
var pos = 3;
var result = [];
while (match = XRegExp.exec('&lt;1&gt;&lt;2&gt;&lt;3&gt;&lt;4&gt;5&lt;6&gt;', /&lt;(\d+)&gt;/,
pos, 'sticky')) {
result.push(match[1]);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.xregexp.forEach" id="apidoc.element.xregexp.forEach">
        function <span class="apidocSignatureSpan">xregexp.</span>forEach
        <span class="apidocSignatureSpan">(str, regex, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">forEach = function (str, regex, callback) {
    var pos = 0,
        i = -1,
        match;

    while ((match = XRegExp.exec(str, regex, pos))) {
        // Because `regex` is provided to `callback`, the function could use the deprecated/
        // nonstandard `RegExp.prototype.compile` to mutate the regex. However, since `XRegExp.exec`
        // doesn't use `lastIndex` to set the search position, this can't lead to an infinite loop,
        // at least. Actually, because of the way `XRegExp.exec` caches globalized versions of
        // regexes, mutating the regex will not have any effect on the iteration or matched strings,
        // which is a nice side effect that brings extra safety.
        callback(match, ++i, str, regex);

        pos = match.index + (match[0].length || 1);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// The only caveat is that named captures must be referenced using numbered
// backreferences if used with native methods
'2015-02-22'.replace(date, '$2/$3/$1');
// -&gt; '02/22/2015'

// Extract every other digit from a string using XRegExp.forEach
var evens = [];
XRegExp.<span class="apidocCodeKeywordSpan">forEach</span>('1a2345', /\d/, function(match, i) {
if (i % 2) evens.push(+match[0]);
});
// evens -&gt; [2, 4]

// Get numbers within &lt;b&gt; tags using XRegExp.matchChain
XRegExp.matchChain('1 &lt;b&gt;2&lt;/b&gt; 3 &lt;b&gt;4 a 56&lt;/b&gt;', [
XRegExp('(?is)&lt;b&gt;.*?&lt;/b&gt;'),
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.xregexp.globalize" id="apidoc.element.xregexp.globalize">
        function <span class="apidocSignatureSpan">xregexp.</span>globalize
        <span class="apidocSignatureSpan">(regex)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">globalize = function (regex) {
    return copyRegex(regex, {addG: true});
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.xregexp.install" id="apidoc.element.xregexp.install">
        function <span class="apidocSignatureSpan">xregexp.</span>install
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">install = function (options) {
    options = prepareOptions(options);

    if (!features.astral &amp;&amp; options.astral) {
        setAstral(true);
    }

    if (!features.natives &amp;&amp; options.natives) {
        setNatives(true);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
unicodeWord.test('Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©'); // -&gt; true

// Test some Unicode scripts
XRegExp('^\\p{Hiragana}+$').test('ã²ã‚‰ãŒãª'); // -&gt; true
XRegExp('^[\\p{Latin}\\p{Common}]+$').test('Ãœber CafÃ©.'); // -&gt; true
```

By default, `\p{â€¦}` and `\P{â€¦}` support the Basic Multilingual Plane (i.e. code points up to `U+FFFF`). You can opt-in to full 21
-bit Unicode support (with code points up to `U+10FFFF`) on a per-regex basis by using flag `A`. In XRegExp, this is called *astral
 mode*. You can automatically add flag `A` for all new regexes by running `XRegExp.<span class="apidocCodeKeywordSpan">install<!--
span-->('astral')`. When in astral mode, `\p{â€¦}` and `\P{â€¦}` always match a full code point rather than a code unit, using surrogate pairs for code points above `U+FFFF`.

```js
// Using flag A to match astral code points
XRegExp('^\\pS$').test('ðŸ’©'); // -&gt; false
XRegExp('^\\pS$', 'A').test('ðŸ’©'); // -&gt; true
XRegExp('(?A)^\\pS$').test('ðŸ’©'); // -&gt; true
// Using surrogate pair U+D83D U+DCA9 to represent U+1F4A9 (pile of poo)
...</span></pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.xregexp.isInstalled" id="apidoc.element.xregexp.isInstalled">
        function <span class="apidocSignatureSpan">xregexp.</span>isInstalled
        <span class="apidocSignatureSpan">(feature)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isInstalled = function (feature) {
    return !!(features[feature]);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.xregexp.isRegExp" id="apidoc.element.xregexp.isRegExp">
        function <span class="apidocSignatureSpan">xregexp.</span>isRegExp
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isRegExp = function (value) {
    return toString.call(value) === '[object RegExp]';
    //return isType(value, 'RegExp');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.xregexp.match" id="apidoc.element.xregexp.match">
        function <span class="apidocSignatureSpan">xregexp.</span>match
        <span class="apidocSignatureSpan">(str, regex, scope)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">match = function (str, regex, scope) {
    var global = (regex.global &amp;&amp; scope !== 'one') || scope === 'all',
        cacheKey = ((global ? 'g' : '') + (regex.sticky ? 'y' : '')) || 'noGY',
        result,
        r2;

    regex[REGEX_DATA] = regex[REGEX_DATA] || {};

    // Shares cached copies with `XRegExp.exec`/`replace`
    r2 = regex[REGEX_DATA][cacheKey] || (
        regex[REGEX_DATA][cacheKey] = copyRegex(regex, {
            addG: !!global,
            removeG: scope === 'one',
            isInternalOnly: true
        })
    );

    result = nativ.match.call(toObject(str), r2);

    if (regex.global) {
        regex.lastIndex = (
            (scope === 'one' &amp;&amp; result) ?
                // Can't use `r2.lastIndex` since `r2` is nonglobal in this case
                (result.index + result[0].length) : 0
        );
    }

    return global ? (result || []) : (result &amp;&amp; result[0]);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.xregexp.matchChain" id="apidoc.element.xregexp.matchChain">
        function <span class="apidocSignatureSpan">xregexp.</span>matchChain
        <span class="apidocSignatureSpan">(str, chain)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">matchChain = function (str, chain) {
    return (function recurseChain(values, level) {
        var item = chain[level].regex ? chain[level] : {regex: chain[level]};
        var matches = [];

        function addMatch(match) {
            if (item.backref) {
                // Safari 4.0.5 (but not 5.0.5+) inappropriately uses sparse arrays to hold the
                // `undefined`s for backreferences to nonparticipating capturing groups. In such
                // cases, a `hasOwnProperty` or `in` check on its own would inappropriately throw
                // the exception, so also check if the backreference is a number that is within the
                // bounds of the array.
                if (!(match.hasOwnProperty(item.backref) || +item.backref &lt; match.length)) {
                    throw new ReferenceError('Backreference to undefined group: ' + item.backref);
                }

                matches.push(match[item.backref] || '');
            } else {
                matches.push(match[0]);
            }
        }

        for (var i = 0; i &lt; values.length; ++i) {
            XRegExp.forEach(values[i], item.regex, addMatch);
        }

        return ((level === chain.length - 1) || !matches.length) ?
            matches :
            recurseChain(matches, level + 1);
    }([str], 0));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var evens = [];
XRegExp.forEach('1a2345', /\d/, function(match, i) {
    if (i % 2) evens.push(+match[0]);
});
// evens -&gt; [2, 4]

// Get numbers within &lt;b&gt; tags using XRegExp.matchChain
XRegExp.<span class="apidocCodeKeywordSpan">matchChain</span>('1 &lt;b&gt;2&lt;/b&gt; 3 &lt;b&gt;4 a 56&lt;/b
&gt;', [
    XRegExp('(?is)&lt;b&gt;.*?&lt;/b&gt;'),
    /\d+/
]);
// -&gt; ['2', '4', '56']

// You can also pass forward and return specific backreferences
var html = '&lt;a href="http://xregexp.com/"&gt;XRegExp&lt;/a&gt;' +
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.xregexp.matchRecursive" id="apidoc.element.xregexp.matchRecursive">
        function <span class="apidocSignatureSpan">xregexp.</span>matchRecursive
        <span class="apidocSignatureSpan">(str, left, right, flags, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">matchRecursive = function (str, left, right, flags, options) {
    flags = flags || '';
    options = options || {};
    var global = flags.indexOf('g') &gt; -1,
        sticky = flags.indexOf('y') &gt; -1,
        // Flag `y` is controlled internally
        basicFlags = flags.replace(/y/g, ''),
        escapeChar = options.escapeChar,
        vN = options.valueNames,
        output = [],
        openTokens = 0,
        delimStart = 0,
        delimEnd = 0,
        lastOuterEnd = 0,
        outerStart,
        innerStart,
        leftMatch,
        rightMatch,
        esc;
    left = XRegExp(left, basicFlags);
    right = XRegExp(right, basicFlags);

    if (escapeChar) {
        if (escapeChar.length &gt; 1) {
            throw new Error('Cannot use more than one escape character');
        }
        escapeChar = XRegExp.escape(escapeChar);
        // Using `XRegExp.union` safely rewrites backreferences in `left` and `right`
        esc = new RegExp(
            '(?:' + escapeChar + '[\\S\\s]|(?:(?!' +
                XRegExp.union([left, right]).source +
                ')[^' + escapeChar + '])+)+',
            // Flags `gy` not needed here
            flags.replace(/[^imu]+/g, '')
        );
    }

    while (true) {
        // If using an escape character, advance to the delimiter's next starting position,
        // skipping any escaped characters in between
        if (escapeChar) {
            delimEnd += (XRegExp.exec(str, esc, delimEnd, 'sticky') || [''])[0].length;
        }
        leftMatch = XRegExp.exec(str, left, delimEnd);
        rightMatch = XRegExp.exec(str, right, delimEnd);
        // Keep the leftmost match only
        if (leftMatch &amp;&amp; rightMatch) {
            if (leftMatch.index &lt;= rightMatch.index) {
                rightMatch = null;
            } else {
                leftMatch = null;
            }
        }
        // Paths (LM: leftMatch, RM: rightMatch, OT: openTokens):
        // LM | RM | OT | Result
        // 1  | 0  | 1  | loop
        // 1  | 0  | 0  | loop
        // 0  | 1  | 1  | loop
        // 0  | 1  | 0  | throw
        // 0  | 0  | 1  | throw
        // 0  | 0  | 0  | break
        // The paths above don't include the sticky mode special case. The loop ends after the
        // first completed match if not `global`.
        if (leftMatch || rightMatch) {
            delimStart = (leftMatch || rightMatch).index;
            delimEnd = delimStart + (leftMatch || rightMatch)[0].length;
        } else if (!openTokens) {
            break;
        }
        if (sticky &amp;&amp; !openTokens &amp;&amp; delimStart &gt; lastOuterEnd) {
            break;
        }
        if (leftMatch) {
            if (!openTokens) {
                outerStart = delimStart;
                innerStart = delimEnd;
            }
            ++openTokens;
        } else if (rightMatch &amp;&amp; openTokens) {
            if (!--openTokens) {
                if (vN) {
                    if (vN[0] &amp;&amp; outerStart &gt; lastOuterEnd) {
                        output.push(row(vN[0], str.slice(lastOuterEnd, outerStart), lastOuterEnd, outerStart));
                    }
                    if (vN[1]) {
                        output.push(row(vN[1], str.slice(outerStart, innerStart), outerStart, innerStart));
                    }
                    if (vN[2]) {
                        output.push(row(vN[2], str.slice(innerStart, delimStart), innerStart, delimStart));
                    }
                    if (vN[3]) {
                        output.push(row(vN[3], str.slice(delimStart, delimEnd), delimStart, delimEnd));
                    }
                } else {
                    output.push(str.slice(innerStart, delimStart));
                }
                lastOuterEnd = delimEnd;
                if (!global) {
                    break;
                }
            }
        } else {
            throw new Error('Unbalanced delimiter found in string');
        }
        // If the delimiter matched an empty string, avoid an infinite loop
        if (delimStart === delimEnd) {
            ++delimEnd;
        }
    }

    if (global &amp;&amp; !sticky &amp;&amp; vN &amp; ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...

### XRegExp.matchRecursive

Match recursive constructs using XRegExp pattern strings as left and right delimiters:

```js
var str = '(t((e))s)t()(ing)';
XRegExp.<span class="apidocCodeKeywordSpan">matchRecursive</span>(str, '\\(', '\\)', 'g');
// -&gt; ['t((e))s', '', 'ing']

// Extended information mode with valueNames
str = 'Here is &lt;div&gt; &lt;div&gt;an&lt;/div&gt;&lt;/div&gt; example';
XRegExp.matchRecursive(str, '&lt;div\\s*&gt;', '&lt;/div&gt;', 'gi', {
    valueNames: ['between', 'left', 'match', 'right']
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.xregexp.replace" id="apidoc.element.xregexp.replace">
        function <span class="apidocSignatureSpan">xregexp.</span>replace
        <span class="apidocSignatureSpan">(str, search, replacement, scope)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">replace = function (str, search, replacement, scope) {
    var isRegex = XRegExp.isRegExp(search),
        global = (search.global &amp;&amp; scope !== 'one') || scope === 'all',
        cacheKey = ((global ? 'g' : '') + (search.sticky ? 'y' : '')) || 'noGY',
        s2 = search,
        result;

    if (isRegex) {
        search[REGEX_DATA] = search[REGEX_DATA] || {};

        // Shares cached copies with `XRegExp.exec`/`match`. Since a copy is used, `search`'s
        // `lastIndex` isn't updated *during* replacement iterations
        s2 = search[REGEX_DATA][cacheKey] || (
            search[REGEX_DATA][cacheKey] = copyRegex(search, {
                addG: !!global,
                removeG: scope === 'one',
                isInternalOnly: true
            })
        );
    } else if (global) {
        s2 = new RegExp(XRegExp.escape(String(search)), 'g');
    }

    // Fixed `replace` required for named backreferences, etc.
    result = fixed.replace.call(toObject(str), s2, replacement);

    if (isRegex &amp;&amp; search.global) {
        // Fixes IE, Safari bug (last tested IE 9, Safari 5.1)
        search.lastIndex = 0;
    }

    return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
while (match = XRegExp.exec('&lt;1&gt;&lt;2&gt;&lt;3&gt;&lt;4&gt;5&lt;6&gt;', /&lt;(\d+)&gt;/,
pos, 'sticky')) {
    result.push(match[1]);
    pos = match.index + match[0].length;
}
// result -&gt; ['2', '3', '4']

// XRegExp.replace allows named backreferences in replacements
XRegExp.<span class="apidocCodeKeywordSpan">replace</span>('2015-02-22', date, '${month}/${day}/${year}');
// -&gt; '02/22/2015'
XRegExp.replace('2015-02-22', date, function(match) {
    return match.month + '/' + match.day + '/' + match.year;
});
// -&gt; '02/22/2015'

// In fact, XRegExps compile to RegExps and work perfectly with native methods
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.xregexp.replaceEach" id="apidoc.element.xregexp.replaceEach">
        function <span class="apidocSignatureSpan">xregexp.</span>replaceEach
        <span class="apidocSignatureSpan">(str, replacements)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">replaceEach = function (str, replacements) {
    var i, r;

    for (i = 0; i &lt; replacements.length; ++i) {
        r = replacements[i];
        str = XRegExp.replace(str, r[0], r[1], r[2]);
    }

    return str;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.xregexp.split" id="apidoc.element.xregexp.split">
        function <span class="apidocSignatureSpan">xregexp.</span>split
        <span class="apidocSignatureSpan">(str, separator, limit)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">split = function (str, separator, limit) {
    return fixed.split.call(toObject(str), separator, limit);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.xregexp.test" id="apidoc.element.xregexp.test">
        function <span class="apidocSignatureSpan">xregexp.</span>test
        <span class="apidocSignatureSpan">(str, regex, pos, sticky)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">test = function (str, regex, pos, sticky) {
    // Do this the easy way :-)
    return !!XRegExp.exec(str, regex, pos, sticky);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// -&gt; '02/22/2015'
XRegExp.replace('2015-02-22', date, function(match) {
    return match.month + '/' + match.day + '/' + match.year;
});
// -&gt; '02/22/2015'

// In fact, XRegExps compile to RegExps and work perfectly with native methods
date.<span class="apidocCodeKeywordSpan">test</span>('2015-02-22');
// -&gt; true

// The only caveat is that named captures must be referenced using numbered
// backreferences if used with native methods
'2015-02-22'.replace(date, '$2/$3/$1');
// -&gt; '02/22/2015'
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.xregexp.uninstall" id="apidoc.element.xregexp.uninstall">
        function <span class="apidocSignatureSpan">xregexp.</span>uninstall
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">uninstall = function (options) {
    options = prepareOptions(options);

    if (features.astral &amp;&amp; options.astral) {
        setAstral(false);
    }

    if (features.natives &amp;&amp; options.natives) {
        setNatives(false);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.xregexp.union" id="apidoc.element.xregexp.union">
        function <span class="apidocSignatureSpan">xregexp.</span>union
        <span class="apidocSignatureSpan">(patterns, flags)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">union = function (patterns, flags) {
    var numCaptures = 0;
    var numPriorCaptures;
    var captureNames;

    function rewrite(match, paren, backref) {
        var name = captureNames[numCaptures - numPriorCaptures];

        // Capturing group
        if (paren) {
            ++numCaptures;
            // If the current capture has a name, preserve the name
            if (name) {
                return '(?&lt;' + name + '&gt;';
            }
        // Backreference
        } else if (backref) {
            // Rewrite the backreference
            return '\\' + (+backref + numPriorCaptures);
        }

        return match;
    }

    if (!(isType(patterns, 'Array') &amp;&amp; patterns.length)) {
        throw new TypeError('Must provide a nonempty array of patterns to merge');
    }

    var parts = /(\()(?!\?)|\\([1-9]\d*)|\\[\s\S]|\[(?:[^\\\]]|\\[\s\S])*]/g;
    var output = [];
    var pattern;
    for (var i = 0; i &lt; patterns.length; ++i) {
        pattern = patterns[i];

        if (XRegExp.isRegExp(pattern)) {
            numPriorCaptures = numCaptures;
            captureNames = (pattern[REGEX_DATA] &amp;&amp; pattern[REGEX_DATA].captureNames) || [];

            // Rewrite backreferences. Passing to XRegExp dies on octals and ensures patterns are
            // independently valid; helps keep this simple. Named captures are put back
            output.push(nativ.replace.call(XRegExp(pattern.source).source, parts, rewrite));
        } else {
            output.push(XRegExp.escape(pattern));
        }
    }

    return XRegExp(output.join('|'), flags);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
XRegExp.matchChain(html, [
    {regex: /&lt;a href="([^"]+)"&gt;/i, backref: 1},
    {regex: XRegExp('(?i)^https?://(?&lt;domain&gt;[^/?#]+)'), backref: 'domain'}
]);
// -&gt; ['xregexp.com', 'www.google.com']

// Merge strings and regexes into a single pattern with updated backreferences
XRegExp.<span class="apidocCodeKeywordSpan">union</span>(['a+b*c', /(dog)\1/, /(cat)\1/], 'i');
// -&gt; /a\+b\*c|(dog)\1|(cat)\2/i
```

These examples give the flavor of what's possible, but XRegExp has more syntax, flags, methods, options, and browser fixes
that aren't shown here. You can even augment XRegExp's regular expression syntax with addons (see below) or write your
 own. See [xregexp.com](http://xregexp.com/) for details.

## Addons
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.xregexp.cache" id="apidoc.module.xregexp.cache">module xregexp.cache</a></h1>


    <h2>
        <a href="#apidoc.element.xregexp.cache.cache" id="apidoc.element.xregexp.cache.cache">
        function <span class="apidocSignatureSpan">xregexp.</span>cache
        <span class="apidocSignatureSpan">(pattern, flags)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">cache = function (pattern, flags) {
    if (!regexCache[pattern]) {
        regexCache[pattern] = {};
    }
    return regexCache[pattern][flags] || (
        regexCache[pattern][flags] = XRegExp(pattern, flags)
    );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.xregexp.cache.flush" id="apidoc.element.xregexp.cache.flush">
        function <span class="apidocSignatureSpan">xregexp.cache.</span>flush
        <span class="apidocSignatureSpan">(cacheName)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">flush = function (cacheName) {
    if (cacheName === 'patterns') {
        // Flush the pattern cache used by the `XRegExp` constructor
        patternCache = {};
    } else {
        // Flush the regex cache populated by `XRegExp.cache`
        regexCache = {};
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
</body></html>